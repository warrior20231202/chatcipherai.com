<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash SHA-256 Explorer: Der unumkehrbare Bildhauer der digitalen Welt.</title>
    <meta name="description"
          content="Pr√§gt den einzigartigen Fingerabdruck der Informationen mit 256-Bit-Verschl√ºsselung, sch√ºtzt die Integrit√§t und Authentizit√§t der Daten.">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="icon" type="image/jpg" href="./images/cipher.jpg">
    <style>    
        html {
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100vh;
            align-items: center;
            margin: 0;
            padding: 0 20px 20px 20px;
            background-color: #0A0F24;
            color: #FFFFFF;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(10, 15, 36, 0.0);
            transition: background-color 0.5s ease;
            z-index: 1000;
            height: 40px;
        }

        .navbar.solid {
            background-color: rgba(10, 15, 36, 1);
        }

        #menuIcon {
            cursor: pointer;
            transition: color 0.3s ease;
        }

        #menuIcon:hover {
            color: #a3a2a2;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            position: relative;
            left: -10px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        .navbar .langUl {
            left: 87px;
            width: 100px;
        }

        .navbar.active ul {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 35px;
            left: 10px;
            width: 15%;
            background-color: rgba(119, 136, 153, 0.8);
            padding: 10px 0;
        }

        .navbar.active ul li {
            margin-bottom: 1px;
        }

        .navbar.active ul li:last-child {
            margin-bottom: 0;
        }

        .navbar ul {
            display: none;
            flex-direction: column;
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: transparent;
            padding: 10px 0;
            list-style: none;
            margin: 0;
            width: 12%;
        }

        .navbar.active ul {
            display: flex;
        }

        .section.interactive-tool {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #bbbaba;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 1000px;
            margin-top: 30px;
            margin-bottom: 150px;
        }

        .sections-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 120px;
            margin-right: -10px;
        }

        .sections-container h2,
        .sections-container p {
            text-align: left;
            width: 80%;
        }

        p {
            margin-bottom: 30px;
            text-align: left;
            font-size: 1.2em;
            line-height: 1.6;
            margin-bottom: 15px;
            text-align: center; 
        }

        h2 {
            margin-bottom: 10px;
            font-size: 28px;
            margin-top: 50px;
        }

        h3 {
            margin-top: 50px;
            font-size: 22px;
        }

        h4 {
            font-size: 20px;
        }

        .sections-container h2:hover {
            color: #4bcfcf;
            transition: color 0.3s ease;
        }

        .navbar li a {
            color: white;
            padding: 5px;
            text-decoration: none;
            font-size: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            display: block;
            border-radius: 5px;
        }

        .navbar ul li {
            margin-bottom: 1px;
        }

        .navbar ul li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .navbar h1 {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 35px;
            margin-right: 0;
            font-size: 30px;
        }

        .navbar-dark {
            background-color: #0A0F24;
        }

        .morse-code-container {
            display: flex;
            align-items: center;
        }

        .morse-code-container .copy-button {
            margin-right: 5px;
            margin-left: 0;
        }

        button {
            cursor: pointer;
            margin: 10px;
            padding: 8px 15px;
            margin-left: 5px;
            background-color: #c0c0c0;
            border: none;
            border-radius: 5px;
            color: #FFFFFF;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #a8a8a8;
        }

        .style-selector {
            position: absolute;
            top: 0px;
            right: 50px;
            margin-top: 10px;
        }

        .style-selector button {
            background-color: #0a0f24;
            padding: 5px 10px;
            margin-right: 1px;
            color: #F5F5F5;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .style-selector button:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .dark-mode {
            background-color: #0A0F24;
            color: white;
        }

        .light-mode {
            background-color: white;
            color: #0A0F24;
        }

        .light-mode .navbar,
        .light-mode .container {
            background-color: #FFFFFF;
            color: #0A0F24;
        }

        .light-mode .navbar ul {
            background-color: transparent;
            color: #0A0F24;
        }

        .dark-mode .navbar ul li a:hover {
            color: #30eded;
        }

        .light-mode .navbar ul li:hover {
            color: #0A0F24;
            background-color: rgba(255, 255, 255, 1);
            border-radius: 5px;
        }

        .navbar {
            justify-content: flex-start;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            margin-left: 30px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        #languageSelect {
            padding: 5px 10px;
            margin-left: 10px;
            border-radius: 5px;
            border: none;
            background-color: #5f9ea0;
            color: white;
            cursor: pointer;
        }

        #languageSelect:hover {
            background-color: #2F4F4F;
        }

        .language-dropdown {
            width: 6%;
            display: none;
            list-style: none;
            padding: 10px 0;
            margin: 0;
            position: absolute;
            top: 40px;
            left: 100px;
            background-color: rgba(119, 136, 153, 0.8);
        }

        .language-dropdown li a {
            color: #FFFFFF;
            padding: 5px;
            margin: 1px;
            text-decoration: none;
            display: block;
            border-radius: 8px;
        }

        .language-dropdown li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .table-container {
            display: none;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .table-container.active {
            display: block;
        }

        .button-container {
            display: flex;
            justify-content: center;
            margin-right: 20px
        }

        .button-container button {
            margin-right: 30px;
        }

        .footer {
            position: relative;
            width: 100%;
            background-color: #0A0F24;
            color: #FFFFFF;
            text-align: center;
            padding: 10px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            margin-bottom: -20px;
        }

        .footer a {
            color: #F5F5F5;
            text-decoration: none;
            margin: 0 12px;
            transition: color 0.3s ease;
        }

        .footer a:hover {
            color: #a3a2a2;
        }

        .footer p {
            margin: 0;
            font-size: 16px;
        }

        .learnMore {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .moreContent {
            width: 80%;
            margin: auto;
            text-align: left;
            padding: 10px;
            display: none;
            margin-left: 0px;
        }

        .moreContent p {
            margin-bottom: 16px;
            font-size: 1.2em;
            line-height: 1.6;
            padding-bottom: 5px;
        }

        #moreContent1 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent1 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        #moreContent2 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent2 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        .clear-all-button {
            background-color: #47d7ff;
        }

        .clear-all-button:hover {
            background-color: #57f7ff;
        }

        figure {
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            text-align: center;
            width: 100%;
            margin: 0 auto;
        }

        img {
            max-width: 75%;
            height: auto;
            margin-left: -290px;
            margin-top: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        figcaption.workflow,
        figcaption.Irreversibility,
        figcaption.Resistance,
        figcaption.Merkle-Damg√•rd,
        figcaption.Compare,
        figcaption.sponge {
            width: 100%;
            margin-left: -300px;
            color: #007bff;
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 10px;
        }

        .navbar li {
            position: relative;
        }

        .navbar li>a {
            display: block;
        }

        .navbar .submenu {
            display: none;
            position: absolute;
            left: 101%;
            top: 0;
            background-color: transparent;
            border-radius: 5px;
            padding: 0;
            min-width: 150px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .navbar .submenu li {
            display: block;
            border-bottom: none;
            width: 75%;
        }

        .navbar .submenu li:last-child {
            border-bottom: none;
        }

        .navbar li:hover>.submenu {
            display: block;
        }

        .navbar .submenu a {
            color: #ffffff;
            padding: 5px;
            text-decoration: none;
            display: block;
            transition: background-color 0.3s ease;
        }

        .navbar .submenu a:hover {
            background-color: rgba(255, 255, 255, 0.206);
        }

        .input-group {
            display: flex;
            width: 80%;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 40px;
        }

        .input-group>div {
            flex: 1;
            margin-right: 20px;
        }

        .input-group>div:last-child {
            margin-right: 0;
        }

        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 10px 15px 10px 5px;
            border: 1px solid #eae6e6;
            border-radius: 5px;
            box-sizing: border-box;
        }

        button,
        input[type="submit"],
        input[type="file"]::file-selector-button {
            background-color: #0a0f24;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s;
        }

        button:hover,
        input[type="submit"]:hover,
        input[type="file"]::file-selector-button:hover {
            background-color: #c0c0c0;
            color: #0A0F24;
        }

        .compare-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        input[type="file"] {
            display: block;
        }

        .outPut {
            width: 100%;
            white-space: normal;
            word-break: break-all;
        }

        #backToTop {
            position: absolute;
            bottom: 5px;
            right: 30px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #0a0f24;
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
            display: block;
        }

        #backToTop:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .introduce {
            margin-left: 220px;
        }

        .introduce li {
            font-size: 17px;
            line-height: 1.5;
            word-wrap: break-word;
            width: 80%;
            padding-bottom: 10px; 
        }

        .language-list{
            float: right;
        }
        .language-list a{
            margin-left: 20px;
            color: white;
        }

        .language-list a:hover{
            color: #4bcfcf;
        }

        .language-list a {
            text-decoration: none;
        }

        .attention {
            margin-top: 20px;
            font-size: 0.8em;
        }

        .highlight-key { 
            font-weight: 800;
        }

        @media screen and (max-width: 768px) {
            .navbar h1 {
                font-size: 18px;
                position: absolute;
                top: -25px;
            }

            .sections-container {
                margin-left: auto;
                margin-right: auto;
                align-items: center;
                width: 100%;
            }

            .sections-container h2 {
                font-size: 1.2em;
            }

            .sections-container p {
                font-size: 0.9em;
            }
            
            .introduce {
                width: 100%;
                padding: 10px;
                margin-left: 90px;
            }

            .introduce h2 {
                font-size: 1.2em; 
            }

            h3 {
                font-size: 0.9em; 
            }

            h4 {
                font-size: 0.8em; 
            }

            .introduce p {
                font-size: 0.9em; 
            }

            .introduce li {
                font-size: 14px;
                margin-left: -20px;
            }

            figure {
                display: flex;
                flex-direction: column;
                align-items: center; 
                justify-content: center; 
                text-align: center;
                width: 100%;
                margin: 0 auto;
            }

            img {
                max-width: 80%;
                height: auto;
                margin-left: -90px;
                margin-top: 20px;
            }

            figcaption.workflow,
            figcaption.Irreversibility,
            figcaption.Resistance,
            figcaption.Merkle-Damg√•rd,
            figcaption.Compare,
            figcaption.sponge {
                width: 100%;
                margin-left: -100px;
                color: #007bff;
                font-size: 0.8em;
                font-weight: bold;
                margin-top: 10px;
            }

            .footer p {
                margin: 0;
                font-size: 10px;
            }

            pre {
                display: none;
            }

            #backToTop {
                content: '‚ñ≤';
                padding: 4px 5px;
                font-size: 14px;
                right: 10px;
                bottom: 0px;
            }
   
            .input-group {
                flex-direction: column;
            }

            .section.interactive-tool {
                width: 320px;
            }
            .navbar ul {
                width: 25%;
            }

            .navbar ul li {
                padding: 0 5px 0 0;
            }

            .navbar li a {
                padding: 5px;
            }

            .navbar li a {
                font-size: 10px;
                width: 100%;
                padding: 5px 0px 5px 5px;
            }

            .navbar .submenu {
                left: 100%;
            }

            .navbar .submenu li {
                display: block;
                border-bottom: none;
                width: 50%;
                padding: 0 5px 0 0;
            }

            .navbar .submenu li a {
                padding: 5px 0px 5px 5px;
            }

            #menuIcon {
                font-size: 0; /* Hide text */
            }
            #menuIcon::before {
                content: '\2630'; /* Unicode character for ‚ò∞ */
                font-size: 16px; /* Or any other size you prefer */
            }

            #languageIcon {
                font-size: 0;
            }

            #languageIcon::before {
                content: '\2637'; /* Unicode character for ‚ò∞ */
                font-size: 16px; /* Or any other size you prefer */
            }

            .navbar .langUl {
                left: 42px;
                width: 65px;
            }

            #darkStyle {
                font-size: 0;
                margin-left: 10px;
                padding: 5px 8px;
            }

            #lightStyle {
                font-size: 0;
                margin-right: -10px;
            }

            #darkStyle::before {
                font-size: 9px;
            }

            #lightStyle::before {
                font-size: 10px;
            }

            #darkStyle::before {
                content: "üåô";
            }

            #lightStyle::before {
                content: "‚òÄ";
            }

            #hashCompareInput {
                width: 240px;
            }

            .social-links i {
                font-size: 12px;
            }

            .attention {
                margin-top: 10px;
                font-size: 0.5em;
            }
        }
    </style>
</head>

<body class="dark-mode">
    <header>
        <nav class="navbar">
            <div id="menuIcon">&#9776; Men√º</div>
            <div id="menuItems"></div>
            <ul class="menuUl">
                <li>
                    <a href="https://chatcipherai.com/de/chatcipherai.html">Kryptosystem-Welt</a>
                    <ul class="submenu">
                        <li><a href="https://chatcipherai.com/de/Caesar_Cipher.html">Caesar-Chiffre</a></li>
                        <li><a href="https://chatcipherai.com/de/Playfair_Cipher.html">Playfair-Chiffre</a></li>
                        <li><a href="https://chatcipherai.com/de/Hill_Cipher.html">Hill-Chiffre</a></li>  
                    </ul>
                </li>
                <li><a href="https://chatcipherai.com/de/Hash_value_test.html">Hashwert-Test</a></li>
                <li><a href="https://chatcipherai.com/de/Morsecode_main.html">Morsecode-√úbersetzer</a></li>
                <li><a href="https://chatcipherai.com/de/Shortcut_Key_Description.html">Tastenkombinationen Erkl√§rung</a></li>
            </ul> 

            <div id="languageIcon">&#x2637; Sprache</div>
            <div id="languageItems">
                <ul class="langUl">
                    <li><a href="https://chatcipherai.com/en/Hash_value_test.html" title="English">English</a></li>
                    <li><a href="https://chatcipherai.com/fr/Hash_value_test.html" title="Fran√ßais">Fran√ßais</a></li>
                    <li><a href="https://chatcipherai.com/es/Hash_value_test.html" title="Espa√±ol">Espa√±ol</a></li>
                    <li><a href="https://chatcipherai.com/zh-CN/Hash_value_test.html" title="‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ">‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ</a></li>
                    <li><a href="https://chatcipherai.com/zh-TW/Hash_value_test.html" title="‰∏≠ÊñáÔºàÁπÅ‰ΩìÔºâ">‰∏≠ÊñáÔºàÁπÅ‰ΩìÔºâ</a></li>
                    <li><a href="https://chatcipherai.com/ar/Hash_value_test.html" title="ÿßŸÑÿπÿ±ÿ®Ÿäÿ©">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</a></li>
                    <li><a href="https://chatcipherai.com/ru/Hash_value_test.html" title="–†—É—Å—Å–∫–∏–π">–†—É—Å—Å–∫–∏–π</a></li>
                    <li><a href="https://chatcipherai.com/pt/Hash_value_test.html" title="Portugu√™s">Portugu√™s</a></li>
                    <li><a href="https://chatcipherai.com/de/Hash_value_test.html" title="Deutsch">Deutsch</a></li>
                    <li><a href="https://chatcipherai.com/hi/Hash_value_test.html" title="‡§π‡§ø‡§®‡•ç‡§¶‡•Ä">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</a></li>
                    <li><a href="https://chatcipherai.com/nl/Hash_value_test.html" title="Nederlands">Nederlands</a></li>
                </ul> 
            </div> 

            <h1>Hash SHA-256 Explorer</h1>
            <div class="style-selector">
                <button id="darkStyle">üåô Dunkler Stil(<span class="highlight-key">N</span>)</button>
                <button id="lightStyle">‚òÄ Heller Stil(<span class="highlight-key">L</span>)</button>
            </div> 
        </nav>
    </header>

    <main class="sections-container">
        <section class="section interactive-tool">
            <h2>Hash-Wert-Test</h2>
            <p>Geben Sie Text ein, um den Prozess der Echtzeit-Umwandlung in einen Hash-Wert anzuzeigen,
                <br>
                oder w√§hlen Sie eine Datei aus, um den Hash-Wert der Datei zu berechnen.
            </p>
            
            <div class="input-group">
                <div>
                    <p>Generiere Text-Hash-Wert</p>
                    <input type="text" class="input_value" id="textInput" placeholder="Text eingeben" oninput="generateHash()" />
                    <button onclick="copyTextHash()">Text-Hash kopieren</button>
                    <div id="processOutput"></div>
                    <div id="hashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Vergleiche Text-Hash-Wert</p>
                    <input type="text" class="input_value" id="hashCompareInput"
                        placeholder="Geben Sie den Hash-Wert zur Vergleich ein" />
                    <button onclick="compareTextHash()">Vergleichen</button>
                    <div id="textCompareResult"></div>
                </div>
            </div>
            
            <div class="input-group">
                <div>
                    <p>Datei-Hash-Wert generieren</p>
                    <input type="file" id="fileInput" onchange="generateFileHash()" />
                    <button onclick="copyFileHash()">Datei-Hash kopieren</button>
                    <div id="fileHashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Datei-Hash-Wert vergleichen</p>
                    <input type="file" id="compareFileInput" onchange="compareFileHash()" />
                    <div id="fileCompareResult" class="outPut"></div>
                </div>
            </div>
            
            <div class="input-group">
                <div>
                    <p>Hash-Wert 1 eingeben</p>
                    <input type="text" class="input_value" id="hashInput1" placeholder="Hash-Wert 1 eingeben" />
                </div>
                <div>
                    <p>Hash-Wert 2 eingeben</p>
                    <input type="text" class="input_value" id="hashInput2" placeholder="Hash-Wert 2 eingeben" />
                    <button onclick="compareHashValues()">Vergleichen</button>
                    <div id="hashComparisonResult" class="outPut"></div>
                </div>
            </div>
            
            <button id="clearAllButton" class="clear-all-button" onclick="clearAll()">Alles l√∂schen(<span class="highlight-key">A</span>)</button>
            <div class="attention">
                Freundliche Erinnerung: Bevor Sie Daten eingeben, √ºberpr√ºfen Sie bitte sorgf√§ltig die Genauigkeit und Sensibilit√§t der Informationen. Wir empfehlen Ihnen, wichtige Daten vorsichtig hochzuladen, da dies hilft, Ihre Privatsph√§re und Sicherheit besser zu sch√ºtzen.
            </div>            
        </section>
        
        <section class="introduce">
            <p><strong><em>"Im digitalen Zeitalter von heute ist die Datensicherheit nicht nur der Grundstein zum Schutz der pers√∂nlichen Privatsph√§re und der Unternehmensgeheimnisse, sondern auch der Schl√ºssel zur Aufrechterhaltung des sozialen Vertrauens und der wirtschaftlichen Stabilit√§t."</em></strong></p>
            <div>
                <h2>Was ist ein Hash-Wert?</h2>
                <p>
                    Ein Hash-Wert ist eine feste Zeichenkette oder Zahl, die von beliebigen Eingabedaten mittels einer Hash-Funktion generiert wird.
                    Diese Funktionen akzeptieren verschiedene Eingaben wie Texte, Bilder und Videos und erzeugen einen festen, nicht umkehrbaren Hash-Wert.
                    Hash-Werte sind deterministisch, was bedeutet, dass identische Eingaben immer denselben Ausgang erzeugen. Sie bieten auch Kollisionsschutz,
                    was es herausfordernd macht, unterschiedliche Eingaben zu finden, die denselben Ausgang ergeben.
                </p>
            </div>
            
            <div>
                <h2>Funktionen des Hash-Werts</h2>
                <p>
                    Hash-Werte spielen eine wesentliche Rolle in der Informatik und der IT, indem sie eine feste Zusammenfassung von Daten unabh√§ngig von deren Gr√∂√üe bieten.
                    Diese Funktionen erleichtern verschiedene Anwendungen:
                </p>
                <ul>
                    <li><strong>Datenintegrit√§tspr√ºfung:</strong> Wird verwendet, um zu √ºberpr√ºfen, ob Daten w√§hrend der √úbertragung unver√§ndert bleiben und die Integrit√§t heruntergeladener Dateien zu gew√§hrleisten.</li>
                    <li><strong>Passwortspeicherung:</strong> Passw√∂rter werden als Hash-Werte zur Sicherheit gespeichert, was es schwierig macht, originale Passw√∂rter aus kompromittierten Datenbanken wiederherzustellen.</li>
                    <li><strong>Schnelle Datenabruf:</strong> Hash-Werte dienen als Indizes in Hashtabellen und erm√∂glichen effiziente Datenoperationen.</li>
                    <li><strong>Datendeduplizierung:</strong> Hilft bei der Identifizierung und Entfernung von Duplikaten durch Vergleich von Hash-Werten.</li>
                    <li><strong>Digitale Signatur und √úberpr√ºfung:</strong> Gew√§hrleistet Datenintegrit√§t und -herkunft durch Public-Key-Kryptografie und Hash-Funktionen.</li>
                    <li><strong>Blockchain-Technologie:</strong> Nutzt Hash-Werte zur Sicherung von Transaktionsdatens√§tzen und zur Gew√§hrleistung der Unver√§nderlichkeit von Daten.</li>
                    <li><strong>F√§lschungssichere Zeitstempel:</strong> Bietet einen unumkehrbaren Zeitstempel f√ºr Daten, der in rechtlichen und urheberrechtlichen Schutzma√ünahmen n√ºtzlich ist.</li>
                </ul>
                <p>
                    Der Grund, warum Hash-Werte in diesen Bereichen effektiv sind, liegt in ihren Schl√ºsselmerkmalen von Geschwindigkeit, Determinismus, Unumkehrbarkeit und Kollisionsschutz.
                    Bei ordnungsgem√§√üer Verwendung k√∂nnen Hash-Funktionen robuste Unterst√ºtzung bei der Sicherung von Daten, der Verbesserung der Effizienz und der √úberpr√ºfung der Authentizit√§t von Informationen bieten.
                </p>
            </div>
            
            <div>
                <h2>Was ist eine Hash-Funktion?</h2>
                <p>
                    Eine Hash-Funktion ist eine mathematische Konstruktion, die Eingabedaten (oder "Nachrichten") auf eine feste Zeichenfolge abbildet, typischerweise einen numerischen Wert, wie im folgenden Diagramm dargestellt. Weit verbreitet in der Datenverwaltung und Informationssicherheit, 
                    zeichnet sich eine Hash-Funktion durch ihre effiziente Rechenleistung, konsistente Ausgabel√§nge, Unumkehrbarkeit, Empfindlichkeit gegen√ºber Eingabevariationen und Kollisionsbest√§ndigkeit aus.
                </p>
                <figure>
                    <img src="./images/Hash input output.jpg" alt="Ablaufdiagramm einer Hash-Funktion" />
                    <figcaption class="workflow">Ablaufdiagramm einer Hash-Funktion</figcaption>
                </figure>
            </div>
            
            <div>
                <h3>Effiziente Rechenleistung</h3>
                <p>
                    Hash-Funktionen k√∂nnen schnell Hash-Werte aus Daten jeder Form berechnen, unabh√§ngig von der Gr√∂√üe der Daten. Diese Eigenschaft ist entscheidend f√ºr Anwendungen, die einen schnellen Zugriff auf Daten erfordern, wie z. B. Hashtabellen. 
                    Dies liegt daran, dass die Geschwindigkeit der Hash-Funktion bei der Speicherung von Daten in Hashtabellen die Geschwindigkeit des Datenabrufs bestimmt. Hashtabellen verwenden Hash-Funktionen, um schnell den Speicherort der Daten zu lokalisieren, wobei sie auf die schnelle Rechenf√§higkeit von Hash-Funktionen vertrauen.
                </p>
            
                <p>
                    Dar√ºber hinaus beeinflusst die Effizienz von Hash-Funktionen direkt die Gesamtleistung eines Systems, das gro√üe Datenmengen verarbeiten muss. Wenn eine Hash-Funktion langsam ausgef√ºhrt wird, wird sie zu einem Engpass in der Systemleistung. Einige Echtzeitsysteme, 
                    wie die Paketfilterung in Netzwerkger√§ten, erfordern die sofortige Berechnung von Hash-Werten f√ºr Daten, um schnelle Entscheidungen zu treffen. In diesen F√§llen ist die Effizienz von Hash-Funktionen gleicherma√üen wichtig.
                </p>
            
                <p>
                    Nehmen Sie beispielsweise eine Online-E-Commerce-Plattform, auf der Benutzer Produktbezeichnungen in die Suchleiste eingeben, um Produkte zu finden. Das Backend-System kann Hash-Funktionen verwenden, um schnell Produktinformationen zu lokalisieren, die in Hashtabellen gespeichert sind. 
                    Wenn der Prozess der Hash-Funktionsberechnung langsam ist, wird die Benutzererfahrung stark beeintr√§chtigt, da die Benutzer l√§nger auf Suchergebnisse warten m√ºssen. In dieser Situation gew√§hrleistet die effiziente Rechenleistung von Hash-Funktionen schnelle Reaktionszeiten und verbessert so die Benutzererfahrung.
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent1">[Erfahren Sie mehr]</a>
                </p>
            </div>
            
            <div id="moreContent1" class="moreContent" style="display:none;" style="color: #007bff; font-size: 1.0em;">
                <p>Die Gr√ºnde, warum Hash-Funktionen die Rechenleistung verbessern k√∂nnen, sind haupts√§chlich auf die folgenden Designmerkmale zur√ºckzuf√ºhren:</p>
                <ul>
                    <li><strong>Einfache Operationen:</strong> Hash-Funktionen verwenden in der Regel einfache mathematische und bitweise Operationen, die aufgrund direkter CPU-Hardwareunterst√ºtzung sehr schnell ausgef√ºhrt werden.</li>
                    <li><strong>Vermeidung von Schleifenabh√§ngigkeiten:</strong> Durch die Vermeidung von Schleifenabh√§ngigkeiten erm√∂glichen Hash-Funktionen eine pipelined Verarbeitung, wodurch die Geschwindigkeit erh√∂ht wird.</li>
                    <li><strong>Parallele Verarbeitung:</strong> Moderne Hash-Funktionen sind f√ºr die parallele Verarbeitung konzipiert, was die Effizienz auf Mehrkernprozessoren verbessert.</li>
                    <li><strong>Feste Ausgabegr√∂√üe:</strong> Die feste Ausgabel√§nge vereinfacht die Speicherzuweisung und den Datenvergleich, was das Programmiermodell und die Effizienz verbessert.</li>
                    <li><strong>Vorverarbeitung und Nachverarbeitung:</strong> Hash-Funktionen k√∂nnen gro√üe Datenmengen verarbeiten, indem sie sie in Bl√∂cke unterteilen, Hash-Werte separat berechnen und dann kombinieren, was die Effizienz erh√∂ht.</li>
                    <li><strong>Optimierte Algorithmuspfade:</strong> Die Reduzierung von Verzweigungen w√§hrend der Ausf√ºhrung erh√∂ht die Genauigkeit der Befehlsvorhersage auf CPUs und damit die Geschwindigkeit.</li>
                    <li><strong>Cache-freundlich:</strong> Das Entwerfen von Hash-Funktionen, um Cache-Miss-Raten zu minimieren, erh√∂ht die Verarbeitungsgeschwindigkeit erheblich.</li>
                    <li><strong>Hardware-Optimierung:</strong> Dedizierte Hardware-Beschleuniger k√∂nnen die Geschwindigkeit von Hash-Berechnungen erheblich erh√∂hen, insbesondere f√ºr kryptografische Hash-Funktionen wie die SHA-Serie.</li>
                    <li><strong>Zustandslosigkeit:</strong> Hash-Funktionen speichern keine Zustandsinformationen und erm√∂glichen so eine leichte Verarbeitung jeder neuen Eingabe.</li>
                    <li><strong>Universalit√§t:</strong> Hash-Funktionen sind universell f√ºr alle Arten von Eingabedaten und eliminieren die Notwendigkeit f√ºr benutzerdefinierte Algorithmen f√ºr verschiedene Datentypen.</li>
                </ul>
            </div>
            
            <div>
                <h3>Konsistenz der Ausgabel√§nge bei Hash-Funktionen</h3>
                <p>
                    Hash-Funktionen wandeln Eingaben beliebiger L√§nge durch eine komplexe Abfolge von Berechnungen in eine Ausgabe fester L√§nge um. Dieser Prozess umfasst oft das Aufteilen der Eingabedaten in Bl√∂cke fester Gr√∂√üe (f√ºr Eingaben, die die Gr√∂√üe der Verarbeitungseinheit √ºberschreiten), 
                    das Anwenden einer Reihe von mathematischen und logischen Operationen auf jeden Block und das anschlie√üende Kombinieren oder Akkumulieren der Ergebnisse dieser Operationen auf irgendeine Weise, um letztendlich einen Hash-Wert fester Gr√∂√üe zu erzeugen.
                </p>
                <p>
                    <strong>Warum ist das wichtig?</strong>
                    Die Konsistenz der Ausgabel√§nge tr√§gt dazu bei, die Sicherheit von Hash-Funktionen zu gew√§hrleisten. Wenn die L√§nge der Hash-Ausgabe variieren k√∂nnte, k√∂nnte dies Informationen √ºber die Gr√∂√üe der Originaldaten preisgeben, was in einigen Szenarien m√∂glicherweise ausgenutzt werden k√∂nnte, um das System anzugreifen. 
                    Dar√ºber hinaus erschwert eine feste Ausgabel√§nge es Angreifern, Eigenschaften der Eingabedaten anhand der Ausgabel√§nge zu ermitteln. Gleichzeitig vereinfachen feste Ausgabel√§ngen die Speicherung und den Vergleich von Hash-Werten. 
                    Systemdesigner k√∂nnen im Voraus wissen, wie viel Platz jeder Hash-Wert einnehmen wird, was f√ºr Szenarien wie Datenbankdesign und Netzwerk√ºbertragung sehr wichtig ist. Dar√ºber hinaus ist die Konsistenz der Ausgabel√§nge sehr effizient f√ºr den Vergleich von Hash-Werten, da nur Daten fester L√§nge verglichen werden m√ºssen. 
                    Dies ist besonders wichtig bei der Verwendung von Hashtabellen f√ºr schnelle Datenabrufe.
                </p>
                <p>
                    Nehmen Sie zum Beispiel SHA-256 als Beispiel. Diese weit verbreitete kryptografische Hash-Funktion erzeugt immer einen 256-Bit (d. h. 32-Byte) Hash-Wert, unabh√§ngig davon, ob die Eingabedaten ein einzelnes Byte oder mehrere Millionen Bytes umfassen. Diese Konsistenz gew√§hrleistet, dass SHA-256-Hash-Werte f√ºr verschiedene Sicherheitsanwendungen verwendet werden k√∂nnen, 
                    wie zum Beispiel digitale Signaturen und Message Authentication Codes (MACs), w√§hrend gleichzeitig der Datenverarbeitungs- und Speicherungsworkflow vereinfacht wird.
                </p>
            </div>

            <div>
                <h3>Irreversibilit√§t von Hash-Funktionen</h3>
                <p>
                    Hash-Funktionen sind unidirektional, was bedeutet, dass es unm√∂glich ist, aus dem Hash-Wert die Originaldaten abzuleiten. Diese Eigenschaft ist besonders wichtig beim Speichern von Passw√∂rtern, da selbst bei Kompromittierung der Datenbank Angreifer die Passw√∂rter nicht aus den Hash-Werten wiederherstellen k√∂nnen. 
                    Die Irreversibilit√§t von Hash-Funktionen basiert haupts√§chlich auf den folgenden Prinzipien und Merkmalen:
                </p>
                <ul>
                    <li><strong>Kompression:</strong> Hash-Funktionen k√∂nnen Eingaben beliebiger L√§nge (die in der praktischen Anwendung sehr gro√ü sein k√∂nnen) auf eine Ausgabe fester L√§nge abbilden. Dies bedeutet, dass unendlich viele m√∂gliche Eingaben auf eine endliche Anzahl von Ausgaben abgebildet werden. Da der Ausgaberaum (Hash-Werte) viel kleiner ist als der Eingaberaum, werden verschiedene Eingaben zwangsl√§ufig denselben Ausgang (Hash-Wert) erzeugen, ein Ph√§nomen, das als "Kollision" bekannt ist. Aufgrund dieser Kompression ist es unm√∂glich, die spezifische Eingabe aus einem gegebenen Ausgang (Hash-Wert) zu bestimmen.</li>
                    <li><strong>Hohe Nichtlinearit√§t und Komplexit√§t:</strong> Hash-Funktionen werden unter Verwendung komplexer mathematischer und logischer Operationen (wie bitweise Operationen, Modulo-Operationen usw.) entwickelt, um sicherzustellen, dass die Ausgabe sehr empfindlich auf die Eingabe reagiert. Selbst geringf√ºgige √Ñnderungen an der Eingabe (z. B. √Ñnderung eines Bits) k√∂nnen signifikante und unvorhersehbare √Ñnderungen an der Ausgabe (dem Hash-Wert) bewirken. Diese hohe Nichtlinearit√§t und die Zuf√§lligkeit der Ausgabe machen es √§u√üerst schwierig, die Originaldaten aus dem Hash-Wert abzuleiten.</li>
                    <li><strong>Unidirektionalit√§t:</strong> Die Gestaltung von Hash-Funktionen gew√§hrleistet, dass ihr Betrieb einseitig ist; das hei√üt, w√§hrend die Berechnung des Hash-Werts einfach ist, ist der umgekehrte Prozess (das Wiederherstellen der Originaldaten aus dem Hash-Wert) nicht durchf√ºhrbar. Dies liegt daran, dass der Berechnungsprozess von Hash-Funktionen eine Reihe von irreversiblen Operationen (wie die Unumkehrbarkeit von Modulo-Operationen) umfasst, die sicherstellen, dass es selbst mit dem Hash-Wert unm√∂glich ist, die Originaldaten umzukehren.</li>
                    <li><strong>Zuf√§llige Zuordnung:</strong> Eine ideale Hash-Funktion sollte als "zuf√§lliger Mapper" fungieren, was bedeutet, dass jede m√∂gliche Eingabe gleich wahrscheinlich auf jeden Punkt im Ausgaberaum abgebildet wird. Diese Eigenschaft stellt sicher, dass es keine praktikable M√∂glichkeit gibt, vorherzusagen, auf welchen Ausgang eine bestimmte Eingabe abgebildet wird, was die Unumkehrbarkeit der Hash-Funktion erh√∂ht.</li>
                    <li><strong>Mathematische Grundlage:</strong> Mathematisch l√§sst sich die Unumkehrbarkeit von Hash-Funktionen durch ihre Abh√§ngigkeit von "diskreten Logarithmusproblemen," "gro√üen Integerfaktorisierungsproblemen" oder anderen zahlentheoretischen Problemen verstehen, die mit den aktuellen mathematischen und rechnerischen M√∂glichkeiten schwer zu l√∂sen sind. Die Gestaltung einiger Hash-Algorithmen kann beispielsweise indirekt von der Berechnungsschwierigkeit dieser Probleme abh√§ngen, wodurch ihre Unumkehrbarkeit sichergestellt wird.</li>
                </ul>
                <figure>
                    <img src="./images/Irreversibility.jpg" alt="Irreversibilit√§t von Hash-Funktionen" />
                    <figcaption class="Irreversibility">Irreversibilit√§t von Hash-Funktionen</figcaption>
                </figure>
            </div>            

            <div>
                <h3>Eingabesensitivit√§t und der Lawineneffekt</h3>
                <p>
                    Bei der Gestaltung von Hash-Funktionen werden komplexe mathematische und logische Operationen (wie bitweise Operationen, Modulo-Operationen usw.) verwendet, um sicherzustellen, dass die Ausgabe sehr empfindlich auf die Eingabe reagiert. 
                    Selbst geringf√ºgige √Ñnderungen an der Eingabe (zum Beispiel das √Ñndern eines einzelnen Bits) f√ºhren zu signifikanten und unvorhersehbaren Ver√§nderungen in der Ausgabe (dem Hash-Wert), ein Ph√§nomen, das als "Lawineneffekt" bekannt ist.
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent2">[Erfahren Sie mehr]</a>
                </p>
            </div>
            
            <div id="moreContent2" class="moreContent" style="display:none;">
                <p>Der <a href="https://en.wikipedia.org/wiki/Avalanche_effect" target="_blank" rel="noopener noreferrer" style="color: #007bff; font-size: 1.0em;">Lawineneffekt</a> kann in verschiedenen Bereichen unterschiedlich interpretiert werden:</p>
                <ul>
                    <li><strong>In der Kryptographie:</strong> Der Lawineneffekt ist eine erw√ºnschte Eigenschaft von Verschl√ºsselungsalgorithmen (insbesondere Blockchiffren und kryptographischen Hash-Funktionen). Er tritt auf, wenn die geringste √Ñnderung an der Eingabe (zum Beispiel das Umkippen eines bin√§ren Bits) zu nicht zu unterscheidenden √Ñnderungen an der Ausgabe f√ºhrt (mit einer Wahrscheinlichkeit von 50%, dass jedes bin√§re Bit in der Ausgabe umkippt). Dieses Attribut tr√§gt dazu bei, die Sicherheit der Verschl√ºsselung zu erh√∂hen, da auch bei nur geringf√ºgigen √Ñnderungen an der Eingabe signifikante Ver√§nderungen in der Ausgabe auftreten k√∂nnen, was das Knacken der Verschl√ºsselung durch Analyse der Beziehung zwischen Eingabe und Ausgabe erschwert.</li>
                    <li><strong>In Wirtschaft und Technologie:</strong> Der Lawineneffekt bezieht sich auf das Ph√§nomen, bei dem durch geeignetes Abbauen und Neuordnen der Struktur und des Systems, die in Wirtschaft und Technologie inh√§rent sind, erhebliche Energie freigesetzt werden kann. Diese Energie kann alte industrielle Systeme wie eine Lawine zerst√∂ren oder sogar eine ganze Branche verschwinden lassen. Unter dem immensen Druck der Lawine wird die inh√§rente Verbindung zwischen Wirtschaft und Technologie vollst√§ndig unterbrochen, was die Akzeptanz neuer Transformationen und Integrationen erfordert. Dieser Effekt l√∂st letztendlich eine Reihe von revolution√§ren Innovationen aus.</li>
                    <li><strong>In der Mikroservice-Architektur:</strong> Der Lawineneffekt beschreibt das Szenario, in dem aufgrund von Abh√§ngigkeiten zwischen Diensten ein Ausfall oder eine Nichtverf√ºgbarkeit in einem Dienst durch die Aufrufkette hindurchgehen kann, was zur L√§hmung des gesamten Systems f√ºhrt. Ursachen f√ºr den Lawineneffekt k√∂nnen Hardwareausf√§lle, Verkehrsspitzen, Cache-Penetration, Programmfehler und JVM-Blockaden usw. sein.</li>
                    <li><strong>In der Natur:</strong> Der Lawineneffekt bezieht sich auf das Ph√§nomen, bei dem ein kleiner Stein, der einen schneebedeckten Berg hinunterrollt, eine Lawine ausl√∂sen kann. Dies liegt daran, dass der Aufprall des kleinen Steins dazu f√ºhrt, dass die umliegenden Schneeschichten locker werden und rutschen, was zu einer Lawine im gr√∂√üeren Ma√üstab f√ºhrt. Dieses Ph√§nomen kann auch metaphorisch beschreiben, wie geringf√ºgige Ereignisse oder Faktoren massive Kettenreaktionen ausl√∂sen k√∂nnen.</li>
                </ul>
            </div>
            
            <div>
                <h3>Kollisionsresistenz in der Kryptographie</h3>
                <p>
                    Die Kollisionsresistenz einer Hash-Funktion ist ein entscheidendes Konzept in der Kryptographie und zeigt das Sicherheitsniveau einer Hash-Funktion gegen Kollisionsangriffe an. Diese Eigenschaft bedeutet, dass es f√ºr jede Hash-Funktion <strong>H</strong> praktisch unm√∂glich ist, zwei verschiedene Eingaben <strong>x</strong> und <strong>y</strong> (<strong>x ‚â† y</strong>) zu finden, f√ºr die <strong>H(x) = H(y)</strong> gilt. Eine Hash-Funktion mit robuster Kollisionsresistenz macht es √§u√üerst schwierig, zwei verschiedene Eingaben zu finden, die denselben Ausgabewert erzeugen.
                </p>
                <figure>
                    <img src="./images/Collision Resistance.jpg" alt="Illustration der Kollisionsresistenz">
                    <figcaption class="Resistance">Illustration der Kollisionsresistenz</figcaption>
                </figure>
                <p>
                    Die Kollisionsresistenz spielt eine entscheidende Rolle bei der Aufrechterhaltung der Datenintegrit√§t und -√ºberpr√ºfung. Durch die Umwandlung von Eingabeinformationen in eine Ausgabe fester Gr√∂√üe (oder einen Digest) stellen Hash-Funktionen sicher, dass keine zwei verschiedenen Eingaben dieselbe Ausgabe erzeugen. Diese einzigartige Eigenschaft erm√∂glicht es, den Hash-Wert genau dem urspr√ºnglichen Wert zuzuordnen.
                </p>
                <p>
                    W√§hrend der Datenerstellung oder -speicherung wird ein Hash-Wert (oder Digest) mithilfe einer Hash-Funktion generiert. Dieser Wert wird neben den urspr√ºnglichen Daten gespeichert oder √ºbertragen. Beispielsweise zeigen Software-Downloadseiten h√§ufig Datei-Hash-Werte zur Integrit√§ts√ºberpr√ºfung an. Empf√§nger k√∂nnen unabh√§ngig den empfangenen Datenwert neu berechnen, um dessen Integrit√§t zu best√§tigen. Stimmen die urspr√ºnglichen und neu berechneten Hash-Werte √ºberein, ist die Integrit√§t der Daten best√§tigt. Andernfalls wurden die Daten m√∂glicherweise w√§hrend der √úbertragung oder Speicherung manipuliert oder besch√§digt.
                </p>
                <p>
                    Der Vergleich von Hash-Werten bietet auch den Vorteil, die Datenintegrit√§t ohne erheblichen Speicherplatzbedarf zu √ºberpr√ºfen. Diese Methode erm√∂glicht es Empf√§ngern, die Echtheit von Daten zu best√§tigen, indem sie einfach die Hash-Werte vor und nach der √úbertragung vergleichen.
                </p>
                <figure>
                    <img src="./images/Compare Hash.jpg" alt="Prozess des Vergleichens von Hash-Werten">
                    <figcaption class="Compare">Prozess des Vergleichens von Hash-Werten</figcaption>
                </figure>
            </div>
            
            <div>
                <h2>K√∂nnen Hash-Kollisionen gefunden werden?</h2>
                <p>
                    Durch die oben genannten Eigenschaften der Hash-Funktionen haben wir die Kollisionsresistenz verstanden. Aber ist es m√∂glich, dass Hash-Kollisionen existieren, das hei√üt, dass zwei verschiedene Eingaben denselben Ausgang erzeugen? 
                    Die Antwort ist ja, Kollisionen existieren tats√§chlich. Gem√§√ü dem <a href="https://de.wikipedia.org/wiki/Schubfachprinzip" target="_blank" style="color: #007bff; font-size: 1.0em;">Schubfachprinzip</a> gibt es bei ausreichend gro√üem Eingaberaum die M√∂glichkeit von Hash-Kollisionen. 
                    Dies liegt daran, dass der Ausgaberaum von Hash-Funktionen in der Regel viel kleiner ist als der Eingaberaum, was zwangsl√§ufig dazu f√ºhrt, dass mehrere verschiedene Eingaben auf denselben Ausgang abgebildet werden.
                </p>
                
                <p>
                    Das Schubfachprinzip ist ein einfaches und intuitives Prinzip der kombinatorischen Mathematik, das besagt, dass, wenn mehr als n Objekte in n Beh√§lter gelegt werden, dann mindestens ein Beh√§lter zwei oder mehr Objekte enth√§lt. 
                    Dieses Prinzip kann auch verwendet werden, um Probleme wie das Geburtstagsparadoxon zu erkl√§ren.
                </p>
                <p>
                    Die Anwendung des Schubfachprinzips ist sehr breit gef√§chert und hat wichtige Anwendungen in Bereichen wie Kryptographie, Informatik und Mathematik. Zum Beispiel wird in der Informatik das Schubfachprinzip verwendet, um die Korrektheit bestimmter Algorithmen zu beweisen oder die Zeitkomplexit√§t von Algorithmen zu analysieren. 
                    In der Kryptographie wird das Schubfachprinzip ebenfalls verwendet, um bestimmte kryptographische Angriffsmethoden zu entwerfen, wie etwa den Geburtstagsangriff.
                </p>
                <p>
                    Das Geburtstagsparadoxon ist eine klassische Anwendung des Schubfachprinzips. Angenommen, es gibt n Personen in einem Raum. 
                    Wenn wir m√∂chten, dass die Wahrscheinlichkeit, dass mindestens zwei Personen denselben Geburtstag haben, gr√∂√üer als 50 % ist, wie viele Personen werden ben√∂tigt? Gem√§√ü dem Schubfachprinzip, 
                    wenn 367 Personen (unter der Annahme, dass es 366 Tage im Jahr gibt, plus einen zus√§tzlichen Tag f√ºr den 29. Februar in einem Schaltjahr) in 366 "Schubf√§cher" (d. h. Geburtstage) gelegt werden, wird mindestens ein "Schubfach" zwei Personen enthalten, was bedeutet, dass mindestens zwei Personen denselben Geburtstag haben. Dies verdeutlicht das Geburtstagsparadoxon.
                </p>
                <p>
                    Es ist wichtig zu beachten, dass, obwohl das Schubfachprinzip einfach und intuitiv ist, dessen Anwendung den spezifischen Kontext ber√ºcksichtigen muss. 
                    Beispielsweise ist es bei der Anwendung des Schubfachprinzips notwendig sicherzustellen, dass die beteiligten Zufallsvariablen voneinander unabh√§ngig sind; andernfalls kann dies zu falschen Schlussfolgerungen f√ºhren. Dar√ºber hinaus ist es in einigen F√§llen auch notwendig, Faktoren wie die Gr√∂√üe und Form der Schubf√§cher zu ber√ºcksichtigen.
                </p>
            </div>
            
            <div>
                <p>
                    Allerdings ist es m√∂glicherweise nicht praktisch, Hash-Kollisionen einfach durch das Durchlaufen des Eingaberaums zu finden, haupts√§chlich aus zwei Gr√ºnden:
                </p>
                <ul>
                    <li><strong>Berechnungskomplexit√§t: </strong> F√ºr die meisten Hash-Funktionen ist der Eingaberaum enorm gro√ü. Nehmen wir SHA-256 als Beispiel; sein Ausgang ist ein 256-Bit-Hash-Wert, was bedeutet, dass es 2^256 m√∂gliche Ausg√§nge gibt. Da eines der Entwurfsziele von Hash-Funktionen darin besteht, Kollisionen so weit wie m√∂glich zu minimieren, w√§re es theoretisch notwendig, etwa 2^(256/2) = 2^128 Eingaben zu durchlaufen, um eine Kollision f√ºr SHA-256 zu finden, gem√§√ü dem Geburtstagsparadoxon, was die ungef√§hre erwartete Anzahl von Eingaben ist, um eine Kollision zu finden. Selbst mit den leistungsf√§higsten Supercomputern, die derzeit verf√ºgbar sind, w√ºrde es weit √ºber ein menschliches Leben dauern, eine solche Aufgabe zu erledigen, sodass es als unm√∂glich gilt, eine SHA-256-Hash-Kollision durch einfaches Durchlaufen zu finden.</li>
                    <li><strong>Entwurf von Hash-Funktionen: </strong> Hash-Funktionen sind typischerweise so konzipiert, dass das Auffinden von Kollisionen rechnerisch unm√∂glich ist. Dies bedeutet, dass, obwohl Kollisionen theoretisch existieren, sie in der Praxis praktisch unm√∂glich zu finden sind. Dies ist eine wichtige Eigenschaft kryptographischer Hash-Funktionen (wie SHA-256), die weit verbreitet in Bereichen wie digitalen Signaturen, Passwortspeicherung und mehr verwendet werden.</li>
                </ul>
                <p>
                    Nat√ºrlich k√∂nnen wir auch spezifische Algorithmen verwenden, um Hash-Kollisionen zu finden. Diese Algorithmen nutzen oft bekannte Eigenschaften oder Schw√§chen von Hash-Funktionen aus, um Kollisionen zu finden. Hier sind einige g√§ngige Techniken und Methoden zum Auffinden von Hash-Kollisionen:
                </p>
                <ul>
                    <li><strong>Geburtstagsangriff: </strong> Dies ist eine wahrscheinlichkeitsbasierte einfache Methode, die verwendet wird, um die Zeit abzusch√§tzen, die zum Finden einer Kollision ben√∂tigt wird, wenn Eingaben zuf√§llig ausgew√§hlt werden. Das Prinzip des Geburtstagsangriffs besagt, dass bei vielen Menschen in einem Raum die Wahrscheinlichkeit, dass zwei Personen denselben Geburtstag haben, mit der Anzahl der Personen zunimmt. √Ñhnlich wie bei Hash-Funktionen, wenn eine ausreichende Anzahl von Eingaben zuf√§llig ausgew√§hlt wird, ist es wahrscheinlich, dass zwei Eingaben letztendlich denselben Hash-Wert erzeugen.</li>
                    <li><strong>Brute-Force-Angriff: </strong> Dies ist die einfachste Methode, die darin besteht, alle m√∂glichen Eingaben zu durchlaufen, um eine Kollision zu finden. Diese Methode ist jedoch f√ºr Hash-Funktionen mit gro√üen Eingaber√§umen aufgrund des enormen Bedarfs an Rechenressourcen und Zeit nicht praktikabel.</li>
                    <li><strong>Regenbogentabellen:</strong> Diese Technik wird verwendet, um eine gro√üe Anzahl von Hash-Werten und ihren entsprechenden Eingaben vorab zu berechnen und zu speichern. Regenbogentabellen sind besonders n√ºtzlich zum Knacken von Passw√∂rtern, die keine zuf√§llige Datenverschleierung verwendet haben oder eine bekannte Hash-Funktion haben. Durch das Nachschlagen in der Regenbogentabelle kann ein Angreifer schnell eine Eingabe finden, die mit einem bestimmten Hash-Wert √ºbereinstimmt.</li>
                    <li><strong>Hash-Verl√§ngerungsangriffe: </strong> Bestimmte Hash-Funktionen erm√∂glichen es Angreifern, zus√§tzliche Daten mit einem bekannten Hash-Wert zu kombinieren, ohne die urspr√ºngliche Eingabe zu kennen, und damit einen neuen Hash-Wert zu generieren. Dieser Angriff kann verwendet werden, um Kollisionen zu konstruieren oder andere Arten von Angriffen durchzuf√ºhren.</li>
                    <li><strong>Speziell konstruierte Eingaben: </strong> Manchmal k√∂nnen Angreifer spezifische Schw√§chen oder nichtlineare Verhaltensweisen in Hash-Funktionen ausnutzen, um spezielle Eingaben zu konstruieren, die wahrscheinlicher sind, Kollisionen in der Hash-Funktion zu erzeugen.</li>
                </ul>
            </div>
            
            <div>
                <h2>Welche Hash-Funktionen werden h√§ufig verwendet?</h2>
                <h3>MD5 (Message Digest Algorithm 5)</h3>
                <p>
                    MD5 ist eine weit verbreitete kryptographische Hash-Funktion, die von Ronald Rivest in den 1990er Jahren entwickelt wurde, um den √§lteren MD4-Algorithmus zu ersetzen. Sie kann eine Nachricht beliebiger L√§nge in einen Hash-Wert fester L√§nge (128 Bit oder 16 Bytes) umwandeln. 
                    Das Entwurfsziel von MD5 war es, einen schnellen und relativ sicheren Weg zur Generierung eines digitalen Fingerabdrucks von Daten bereitzustellen. Es wurden jedoch Kollisionsmethoden f√ºr <a href="https://de.wikipedia.org/wiki/MD5" target="_blank" style="color: #007bff; font-size: 1.0em;"> MD5 </a> entdeckt, was den Algorithmus unsicher macht, aber er wird immer noch weit verbreitet eingesetzt, wenn Sicherheit keine prim√§re Rolle spielt.
                <br>
                <br>Der Berechnungsprozess von MD5 umfasst folgende Schritte:
                </p>
                <ul>
                    <li><strong>Padding: </strong> Zun√§chst wird die originale Daten mit Nullen aufgef√ºllt, sodass ihre Bytel√§nge ein Vielfaches von 512 ist. Das Padding beginnt mit einer 1, gefolgt von Nullen, bis die L√§ngenanforderung erf√ºllt ist.</li>
                    <li><strong>L√§nge hinzuf√ºgen: </strong> Ein 64-Bit-L√§ngenwert, der die bin√§re Darstellung der urspr√ºnglichen Nachrichtenl√§nge ist, wird zur gepaddeten Nachricht hinzugef√ºgt, sodass die endg√ºltige Nachrichtenl√§nge ein Vielfaches von 512 Bit ist.</li>
                    <li><strong>Initialisierung des MD-Puffers: </strong> Vier 32-Bit-Register (A, B, C, D) werden initialisiert, um die Zwischen- und Endhash-Werte zu speichern.</li> 
                    <li><strong>Verarbeitung von Nachrichtenbl√∂cken: </strong> Die gepaddete und l√§ngenverarbeitete Nachricht wird in 512-Bit-Bl√∂cke unterteilt, und jeder Block wird durch vier Runden von Operationen verarbeitet. Jede Runde umfasst 16 √§hnliche Operationen basierend auf nichtlinearen Funktionen (F, G, H, I), linken zyklischen Schiebeoperationen und Addition modulo 32.</li> 
                    <li><strong>Ergebnis: </strong> Der endg√ºltige Hash-Wert ist der Inhalt des letzten Zustands der vier Register A, B, C, D, die zusammengef√ºgt werden (jedes Register ist 32 Bit lang), um einen 128-Bit-Hash-Wert zu bilden.</li> 
                </ul>
                
                <h3>SHA-1 (Secure Hash Algorithm 1)</h3>
                <p>
                    SHA-1 wurde von der US-amerikanischen National Security Agency (NSA) entworfen und 1995 als Federal Information Processing Standard (FIPS PUB 180-1) vom National Institute of Standards and Technology (NIST) ver√∂ffentlicht. 
                    SHA-1 ist f√ºr den Einsatz in digitalen Signaturen und anderen kryptografischen Anwendungen gedacht und erzeugt einen 160-Bit (20-Byte) Hash-Wert, der als Nachrichten-Pr√ºfsumme bekannt ist. Obwohl bekannt ist, dass <a href="https://de.wikipedia.org/wiki/SHA-1" target="_blank" style="color: #007bff; font-size: 1.0em;"> SHA-1 </a> Sicherheitsanf√§lligkeiten aufweist und durch sicherere Algorithmen wie SHA-256 und SHA-3 ersetzt wurde, 
                    hat das Verst√§ndnis seines Arbeitsprinzips immer noch einen Bildungs- und historischen Wert.
                <br>
                <br>Der Entwurfszweck von SHA-1 besteht darin, eine Nachricht beliebiger L√§nge zu nehmen und eine 160-Bit-Nachrichten-Pr√ºfsumme zu erzeugen, um die Integrit√§t der Daten zu √ºberpr√ºfen. Sein Berechnungsprozess kann in folgende Schritte unterteilt werden:
                </p>
                <ul>
                    <li><strong>Padding: </strong> Zun√§chst wird die urspr√ºngliche Nachricht mit Nullen aufgef√ºllt, sodass ihre L√§nge (in Bits) modulo 512 gleich 448 ist. Das Padding beginnt immer mit einem "1"-Bit, gefolgt von mehreren "0"-Bits, bis die obige L√§ngenbedingung erf√ºllt ist.</li>
                    <li><strong>L√§nge hinzuf√ºgen: </strong> Ein 64-Bit-Block wird zur gepaddeten Nachricht hinzugef√ºgt, der die L√§nge der urspr√ºnglichen Nachricht (in Bits) darstellt, sodass die endg√ºltige Nachrichtenl√§nge ein Vielfaches von 512 Bit ist.</li>
                    <li><strong>Initialisierung des Buffers: </strong> Der SHA-1-Algorithmus verwendet einen 160-Bit-Puffer, der in f√ºnf 32-Bit-Register (A, B, C, D, E) unterteilt ist, um die Zwischen- und Endhash-Werte zu speichern. Diese Register werden zu Beginn des Algorithmus auf bestimmte Konstantenwerte initialisiert.</li>
                    <li><strong>Verarbeitung von Nachrichtenbl√∂cken: </strong> Die vorverarbeitete Nachricht wird in 512-Bit-Bl√∂cke unterteilt. F√ºr jeden Block f√ºhrt der Algorithmus eine Hauptschleife mit 80 √§hnlichen Schritten aus. Diese 80 Schritte sind in vier Runden unterteilt, jede mit 20 Schritten. Jeder Schritt verwendet eine andere nichtlineare Funktion (F, G, H, I) und eine Konstante (K). Diese Funktionen sind so konzipiert, dass sie die Komplexit√§t und Sicherheit der Operationen erh√∂hen. In diesen Schritten verwendet der Algorithmus bitweise Operationen (wie UND, ODER, XOR, NICHT) und Addition modulo 32 sowie links zirkul√§re Verschiebungen.</li>
                    <li><strong>Ergebnis: </strong> Nach der Verarbeitung aller Bl√∂cke werden die akkumulierten Werte in den f√ºnf Registern zu einem endg√ºltigen 160-Bit-Hash-Wert zusammengef√ºgt.</li>
                </ul>
                
                <h3>SHA-2 (Secure Hash Algorithm 2)</h3>
                <p>
                    SHA-2 ist eine Familie kryptographischer Hash-Funktionen, die mehrere verschiedene Versionen umfasst und haupts√§chlich aus sechs Varianten besteht: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 und SHA-512/256. 
                    SHA-2 wurde von der National Security Agency (NSA) der Vereinigten Staaten entworfen und vom National Institute of Standards and Technology (NIST) als Federal Information Processing Standard (FIPS) ver√∂ffentlicht. Im Vergleich zu seinem Vorg√§nger, SHA-1, bietet SHA-2 erh√∂hte Sicherheit, die sich haupts√§chlich in l√§ngeren Hash-Werten und einer st√§rkeren Resistenz gegen Kollisionsangriffe zeigt.
                <br>
                <br>Der Betrieb der <a href="https://en.wikipedia.org/wiki/SHA-2" rel="noopener noreferrer" target="_blank" style="color: #007bff; font-size: 1.0em;">SHA-2</a>-Familie √§hnelt in vielen Aspekten SHA-1, bietet jedoch durch die Verwendung l√§ngerer Hash-Werte und eines komplexeren Verarbeitungsverfahrens eine h√∂here Sicherheit. Hier sind die Hauptschritte des SHA-2-Algorithmus:
                </p>
                <ul>
                    <li><strong>Padding: </strong> Die Eingabebotschaft wird zun√§chst aufgef√ºllt, um ihre L√§nge abz√ºglich 64 Bits auf der Basis eines Modulo-512 (f√ºr SHA-224 und SHA-256) oder Modulo-1024 (f√ºr SHA-384 und SHA-512) gleich 448 oder 896 zu machen. Die Polsterungsmethode ist dieselbe wie bei SHA-1, bei der am Ende der Nachricht eine "1" hinzugef√ºgt wird, gefolgt von mehreren "0", und schlie√ülich eine 64-Bit (f√ºr SHA-224 und SHA-256) oder 128-Bit (f√ºr SHA-384 und SHA-512) Bin√§rdarstellung der urspr√ºnglichen Nachrichtenl√§nge in Bits.</li>
                    <li><strong>Initialisierung des Buffers: </strong> Der SHA-2-Algorithmus verwendet eine Reihe initialisierter Hash-Werte als Ausgangsbuffer, abh√§ngig von der gew√§hlten SHA-2-Variante. Beispielsweise verwendet SHA-256 acht 32-Bit-Register, w√§hrend SHA-512 acht 64-Bit-Register verwendet. Diese Register werden auf bestimmte Konstantenwerte initialisiert.</li>
                    <li><strong>Verarbeitung von Nachrichtenbl√∂cken: </strong> Die aufgef√ºllte Nachricht wird in 512-Bit- oder 1024-Bit-Bl√∂cke unterteilt, und jeder Block durchl√§uft mehrere Runden kryptografischer Operationen. SHA-256 und SHA-224 f√ºhren 64 Runden von Operationen aus, w√§hrend SHA-512, SHA-384, SHA-512/224 und SHA-512/256 80 Runden durchf√ºhren.Jede Runde der Operation enth√§lt eine Reihe komplexer bitweiser Operationen, einschlie√ülich logischer, modularer Addition und bedingter Operationen, die auf unterschiedlichen nichtlinearen Funktionen und vordefinierten Konstanten beruhen. Diese Operationen erh√∂hen die Komplexit√§t und Sicherheit des Algorithmus.</li>
                    <li><strong>Ausgabe: </strong> Schlie√ülich werden nach Verarbeitung aller Bl√∂cke die Werte im Buffer kombiniert, um den endg√ºltigen Hash-Wert zu bilden. Abh√§ngig von der SHA-2-Variante kann dieser Hash-Wert 224, 256, 384 oder 512 Bits lang sein.</li>
                </ul>
                <P>
                    Sie fragen sich vielleicht, warum die Eingabe einer Hash-Funktion beliebiger L√§nge sein kann, aber die Ausgabe festgelegt ist. Der Grund daf√ºr ist, dass die SHA-2-Familie die Merkle-Damg√•rd-Transformation verwendet, die die Konstruktion von Hash-Funktionen erm√∂glicht, die Nachrichten beliebiger L√§nge aus einer Kompressionsfunktion fester L√§nge verarbeiten k√∂nnen. Die Merkle-Damg√•rd-Transformation wird in vielen traditionellen Hash-Funktionen, einschlie√ülich MD5 und SHA-1, verwendet.
                </P>
                <p>
                    Die Kernidee der Merkle-Damg√•rd-Transformation besteht darin, die Eingabemeldung in Bl√∂cke fester Gr√∂√üe zu unterteilen und diese Bl√∂cke nacheinander zu verarbeiten, wobei jeder Verarbeitungsschritt vom Ergebnis des vorherigen abh√§ngt und schlie√ülich einen Hash-Wert fester Gr√∂√üe produziert. Der Polsterschritt von SHA-256 verk√∂rpert die grundlegenden Prinzipien der Merkle-Damg√•rd-Transformation, n√§mlich, durch geeignetes Polstern, um Nachrichten beliebiger L√§nge zu verarbeiten, und Sicherstellen, dass die endg√ºltige verarbeitete Nachrichtenl√§nge bestimmte Bedingungen erf√ºllt (wie ein Vielfaches einer festen L√§nge). Daher kann gesagt werden, dass der Polsterschritt von SHA-256 dem Verfahren der Merkle-Damg√•rd-Transformation folgt.
                </p>
                <figure>
                    <img src="./images/Merkle-Damg√•rd Padding.jpg" alt="Padding-Prinzip von Merkle-Damg√•rd">
                    <figcaption class="Merkle-Damg√•rd">Padding-Prinzip von Merkle-Damg√•rd</figcaption>
                </figure>
                <p>
                    Jedoch ist SHA-256 nicht nur eine direkte Implementierung der Merkle-Damg√•rd-Transformation. Er umfasst auch eine Reihe komplexer Berechnungsschritte (wie Nachrichtenerweiterung, mehrere Runden von Kompressionsfunktionen usw.), die einzigartige Designs von SHA-256 sind, die darauf abzielen, seine Sicherheit zu erh√∂hen. Daher verbessert SHA-256 trotz der Befolgung der Prinzipien der Merkle-Damg√•rd-Transformation in seinem Polsterschritt die Gesamtsicherheit, indem er andere Sicherheitsmechanismen einf√ºhrt, die ihn nicht nur auf das grundlegende Rahmenwerk der Merkle-Damg√•rd-Transformation beschr√§nken.
                </p>
                
                <h3>SHA-3 (Secure Hash Algorithm 3) </h3>
                <p>
                    SHA-3 ist der neueste sichere Hash-Standard, der offiziell vom National Institute of Standards and Technology (NIST) im Jahr 2015 als Federal Information Processing Standard (FIPS 202) genehmigt wurde. SHA-3 soll nicht die vorherigen SHA-1 oder SHA-2 ersetzen (da SHA-2 immer noch als sicher betrachtet wird), sondern vielmehr die SHA-Familie erg√§nzen und eine alternative Option bieten, die einen anderen kryptografischen Hash-Algorithmus bereitstellt. SHA-3 basiert auf dem Keccak-Algorithmus, der von Guido Bertoni und anderen entwickelt wurde und war der Gewinner des SHA-3-Wettbewerbs, den das NIST im Jahr 2012 abhielt.
                <br>
                <br>Das Arbeitsprinzip von SHA-3 unterscheidet sich erheblich von SHA-2, haupts√§chlich weil es eine Methode namens "<strong>Schwammkonstruktion</strong>" verwendet, um Daten zu absorbieren und auszudr√ºcken und den endg√ºltigen Hash-Wert zu erzeugen. Diese Methode erm√∂glicht es SHA-3, flexibel Hash-Werte verschiedener L√§ngen auszugeben und damit eine breitere Palette von Anwendungen als SHA-2 anzubieten. Die Hauptschritte von SHA-3 sind wie folgt:
                </p>
                <figure>
                    <img src="./images/sponge construction.jpg" alt="Schematische Darstellung der Schwammkonstruktion">
                    <figcaption class="sponge">Schematische Darstellung der Schwammkonstruktion</figcaption>
                </figure>
                
                <h4>Absorbierende Phase: </h4>
                <p>
                    In der Absorptionsphase teilt die Schwammstruktur zun√§chst die Eingabedaten in Bl√∂cke fester Gr√∂√üe auf. Diese Datenbl√∂cke werden nacheinander in den internen Zustand des Schwamms "aufgenommen", der in der Regel gr√∂√üer als ein einzelner Datenblock ist, um sicherzustellen, dass eine gro√üe Menge an Daten verarbeitet werden kann, ohne √ºberzulaufen. 
                    Spezifisch wird jeder Datenblock in irgendeiner Weise mit einem Teil des internen Zustands verschmolzen (zum Beispiel durch eine XOR-Operation), gefolgt von der Anwendung einer festen Permutationsfunktion (in SHA-3 ist dies <a href="https://en.wikipedia.org/wiki/SHA-3" target="_blank" style="color: #007bff; font-size: 1.0em;">Keccak-f</a>), um den gesamten Zustand zu transformieren und somit St√∂rungen zwischen verschiedenen Eingabedatenbl√∂cken zu verhindern. Dieser Vorgang wird wiederholt, bis alle Eingabedatenbl√∂cke verarbeitet wurden.
                </p>
                <p>
                    Keccak-f ist die Kernpermutationsfunktion, die im kryptografischen Hash-Algorithmus SHA-3 verwendet wird. Es ist eine zentrale Komponente der Keccak-Algorithmusfamilie. SHA-3 basiert auf dem Keccak-Algorithmus, der den kryptografischen Hash-Algorithmuswettbewerb des NIST gewonnen und wurde als Standard f√ºr SHA-3 ausgew√§hlt. Die Keccak-f-Funktion hat mehrere Varianten, 
                    wobei die am h√§ufigsten verwendete Keccak-f[1600] ist, wobei die Zahl die Bitbreite angibt, auf der sie arbeitet.
                </p>
                <p>
                    Keccak-f besteht aus mehreren Runden derselben Operation (Runden genannt). F√ºr Keccak-f[1600] gibt es insgesamt 24 Runden von Operationen. Jede Runde umfasst f√ºnf grundlegende Schritte: <em>Œ∏ (Theta), œÅ (Rho), œÄ (Pi), œá (Chi) und Œπ (Iota)</em>. Diese Schritte wirken zusammen auf das Zustandsarray und transformieren allm√§hlich seinen Inhalt, 
                    um Verwirrung und Diffusion zu erh√∂hen und die Sicherheit zu verbessern. Im Folgenden finden Sie eine kurze Beschreibung dieser Schritte:
                </p>
                <ul>
                    <li><strong>Œ∏ (Theta) Schritt: </strong> F√ºhrt XOR-Operationen auf allen Bits jeder Spalte durch und f√ºhrt dann das Ergebnis auf benachbarte Spalten aus, wodurch eine Diffusion zwischen den Spalten entsteht.</li>
                    <li><strong>œÅ (Rho) Schritt: </strong> Bitweise Rotationsoperation, bei der jedes Bit gem√§√ü vorbestimmter Regeln um eine andere Anzahl von Bits rotiert wird, wodurch die Komplexit√§t der Daten erh√∂ht wird.</li>
                    <li><strong>œÄ (Pi) Schritt: </strong> Ordnet die Bits im Zustandsarray neu an und √§ndert die Position der Bits, um eine Diffusion √ºber Zeilen und Spalten zu erreichen.</li>
                    <li><strong>œá (Chi) Schritt: </strong> Ein nichtlinearer Schritt, der XOR-Operationen auf jedem Bit jeder Zeile durchf√ºhrt, einschlie√ülich sich selbst, seines unmittelbaren Nachbarn und des Komplements des Nachbarn. Dies ist eine lokale Operation, die die nichtlinearen Merkmale des kryptografischen Algorithmus erh√∂ht.</li>
                    <li><strong>Œπ (Iota) Schritt: </strong> F√ºhrt dem Zustandsarray einen Rundenkonstanten hinzu, wobei die Konstante in jeder Runde unterschiedlich ist, um zu vermeiden, dass alle Runden identisch funktionieren, was Unvorhersehbarkeit einf√ºhrt.</li>
                </ul>
                <p>
                    Keccak-f bietet ein hohes Ma√ü an Sicherheit durch diese Schritte. Sein Design stellt sicher, dass selbst geringf√ºgige √Ñnderungen an der Eingabe zu weit verbreiteten und unvorhersehbaren √Ñnderungen im Zustandsarray f√ºhren, die durch die Prinzipien der Verwirrung (erschweren es Angreifern, die Eingabe aus der Ausgabe abzuleiten) und Diffusion (wo geringf√ºgige √Ñnderungen an der Eingabe mehrere Teile der Ausgabe beeinflussen) erreicht werden.
                </p>
                <p>
                    Das Design von Keccak-f erm√∂glicht die Anpassung von Parametern (wie Zustandsgr√∂√üe und Anzahl der Runden) √ºber verschiedene Sicherheitsstufen und Anwendungsszenarien hinweg und bietet damit eine hohe Flexibilit√§t. Keccak-f[1600] ist bekannt f√ºr seine effiziente Implementierung und erreicht hohe Verarbeitungsgeschwindigkeiten sowohl in Hardware als auch in Software, insbesondere bei der Verarbeitung gro√üer Datenmengen.
                </p>
                

                <h4>Quetschphase: </h4>
                <p>
                    Sobald alle Eingabedatenbl√∂cke in den internen Zustand aufgenommen wurden, tritt die Schwammstruktur in die Ausquetschphase ein. In diesem Stadium werden Teile des internen Zustands progressiv als Ergebnis der Hash-Funktion ausgegeben. Wenn die ben√∂tigte Ausgabel√§nge die Menge √ºberschreitet, die auf einmal ausgedr√ºckt werden kann, wendet die Schwammstruktur die Permutationsfunktion an, um den internen Zustand erneut zu transformieren, und f√§hrt dann fort, weitere Daten auszugeben. Dieser Prozess wird fortgesetzt, bis die gew√ºnschte Ausgabel√§nge erreicht ist.
                </p>
                
                <p>
                    Das Ziel von SHA-3's Design ist es, eine h√∂here Sicherheit als SHA-2 und eine bessere Widerstandsf√§higkeit gegen Quantencomputing-Angriffe zu bieten. Dank seiner einzigartigen Schwammstruktur ist SHA-3 theoretisch in der Lage, alle derzeit bekannten kryptografischen Angriffsmethoden zu widerstehen, einschlie√ülich Kollisionsangriffen, Preimage-Angriffen und Zweit-Preimage-Angriffen.
                </p>
                
                <h3>RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest)</h3>
                <p>
                    RIPEMD-160 ist eine kryptografische Hash-Funktion, die entwickelt wurde, um einen sicheren Hash-Algorithmus bereitzustellen. Es wurde 1996 von Hans Dobbertin und anderen entwickelt und ist Mitglied der RIPEMD (RACE Integrity Primitives Evaluation Message Digest)-Familie.
                </p>
                <p>
                    RIPEMD-160 erzeugt einen 160-Bit (20-Byte) Hash-Wert, der der Ursprung der "160" in seinem Namen ist. Es basiert auf dem Design von MD4 und ist von anderen Hash-Algorithmen wie MD5 und SHA-1 beeinflusst. RIPEMD-160 umfasst zwei parallele, √§hnliche Operationen, die die Eingabedaten separat verarbeiten und dann die Ergebnisse dieser beiden Prozesse kombinieren, um den endg√ºltigen Hash-Wert zu generieren. Dieses Design zielt darauf ab, die Sicherheit zu erh√∂hen.
                <br>
                <br>Der Berechnungsprozess von <a href="https://en.wikipedia.org/wiki/RIPEMD" target="_blank" style="color: #007bff; font-size: 1.0em;"> RIPEMD-160 </a> umfasst mehrere grundlegende Schritte: Padding, Blockverarbeitung und Kompression:
                </p>
                <ul>
                    <li><strong>Padding: </strong> Die Eingabemitteilung wird zuerst gepaddet, um sicherzustellen, dass ihre L√§nge modulo 512 Bits 448 Bits entspricht. Das Padding beginnt immer mit einem einzigen Bit von 1, gefolgt von einer Reihe von 0-Bits und endet mit einer 64-Bit-Repr√§sentation der urspr√ºnglichen Nachrichtenl√§nge.</li>
                    <li><strong>Blockverarbeitung: </strong> Die gepaddete Nachricht wird in 512-Bit-Bl√∂cke aufgeteilt.</li>
                    <li><strong>Initialisierung: </strong> Es verwendet f√ºnf 32-Bit-Register (A, B, C, D, E), die auf bestimmte spezifische Werte initialisiert sind.</li>
                    <li><strong>Kompressionsfunktion: </strong> Jeder Block wird nacheinander verarbeitet, wobei die Werte dieser f√ºnf Register durch eine Reihe komplexer Operationen aktualisiert werden. Dieser Prozess umfasst bitweise Operationen (wie Addition, UND, ODER, NICHT, zirkul√§re Linksverschiebungen) und die Verwendung eines Satzes fester Konstanten.</li>
                    <li><strong>Ausgabe: </strong> Nachdem alle Bl√∂cke verarbeitet wurden, werden die Werte dieser f√ºnf Register verkettet, um den endg√ºltigen 160-Bit-Hash-Wert zu bilden.</li>
                </ul>                
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="social-links">
            <a href="https://twitter.com/xinli_111219" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-twitter"></i>
            </a>
            <a href="https://www.youtube.com/@xinli-vj3js" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-youtube"></i>
            </a> 
        </div>
    
        <div class="info">
            <p>¬© 2024 chatcipher Tools. Alle Rechte vorbehalten.</p>
            <p>
                <a href="https://chatcipherai.com/de/Privacy_Policy.html" title="Privacy Policy">Datenschutzrichtlinie</a>
                |
                <a href="https://chatcipherai.com/de/Terms_of_Use.html" title="Terms of Use">Nutzungsbedingungen</a>
                |
                <a href="https://chatcipherai.com/de/About_Us.html" title="About Us">√úber uns</a>
                |
                <a href="https://chatcipherai.com/de/Disclaimer.html" title="Disclaimer">Haftungsausschluss</a>
            </p> 
            <button id="backToTop" onclick="scrollToTop()">Zur√ºck nach oben(<span class="highlight-key">B</span>)</button>
        </div> 
    </footer>

    <script>
        let shortcutsEnabled = true;

        function manageShortcuts(enable) {
            shortcutsEnabled = enable;
        }

        function handleKeyPress(event) {
            if (!shortcutsEnabled) {
                console.log('Shortcuts are disabled');
                return;
            }

            switch (event.key.toUpperCase()) {
                case 'A':
                    clearAll();
                    console.log('Clear All triggered');
                    break;
                case 'L':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('light-mode');
                        console.log('Light style activated');
                    }
                    break;
                case 'N':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('dark-mode');
                        console.log('Dark style activated');
                    }
                    break;
                case 'B':
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                    console.log('Scrolled to top');
                    break;
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Ensure all handlers are set up once the DOM is fully loaded
            document.addEventListener('keydown', handleKeyPress);

            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
            
            setupEventListeners(); // Setup other event listeners
            adjustButton();
        });

        let generatedTextHash = '';
        let generatedFileHash = '';

        async function generateHash() {
            const text = document.getElementById('textInput').value;
            document.getElementById('processOutput').textContent = text.length ? "Hashwert wird berechnet..." : '';
            const msgUint8 = new TextEncoder().encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('hashOutput').textContent = `Hashwert (SHA-256): ${hashHex}`;
            generatedTextHash = hashHex;
            document.getElementById('processOutput').textContent = "";
        }

        async function generateFileHash() {
            const fileInput = document.getElementById('fileInput');
            if (!fileInput.files.length) {
                alert("Bitte w√§hlen Sie eine Datei aus.");
                return;
            }
            document.getElementById('fileHashOutput').textContent = "Datei-Hash-Wert wird berechnet...";
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('fileHashOutput').textContent = `Hashwert (SHA-256): ${hashHex}`;
                generatedFileHash = hashHex;
            };
            reader.onerror = function () {
                alert("Fehler beim Lesen der Datei.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareTextHash() {
            const compareHash = document.getElementById('hashCompareInput').value;
            if (!generatedTextHash) {
                alert('Bitte generieren Sie zun√§chst einen Hash des Textes.');
                return;
            }
            const resultText = generatedTextHash === compareHash ? "<strong>Schlussfolgerung: </strong>Die Hashes stimmen √ºberein und die Daten wurden nicht manipuliert." : "<strong>Schlussfolgerung: </strong>Die Hashes stimmen nicht √ºberein, und die Daten wurden m√∂glicherweise w√§hrend der √úbertragung manipuliert oder es ist ein Fehler beim Speichern aufgetreten.";
            document.getElementById('textCompareResult').innerHTML = resultText;
            document.getElementById('textCompareResult').style.color = generatedTextHash === compareHash ? "black" : "red";
        }

        async function compareFileHash() {
            const fileInput = document.getElementById('compareFileInput');
            if (!fileInput.files.length) {
                alert("Bitte w√§hlen Sie eine Datei zum Vergleichen aus.");
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                document.getElementById('fileCompareResult').textContent = `Hashwert (SHA-256): ${hashHex}`;

                if (generatedFileHash === hashHex) {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Schlussfolgerung: </strong>Die Hashes stimmen √ºberein und die Daten wurden nicht manipuliert.";
                    document.getElementById('fileCompareResult').style.color = "black";
                } else {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Schlussfolgerung: </strong>Die Hashes stimmen nicht √ºberein, und die Daten k√∂nnten w√§hrend der √úbertragung manipuliert worden sein oder es ist ein Fehler w√§hrend der Speicherung aufgetreten.";
                    document.getElementById('fileCompareResult').style.color = "red";
                }
            };
            reader.onerror = function () {
                alert("Fehler beim Lesen der Datei.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareHashValues() {
            var hashValue1 = document.getElementById('hashInput1').value.trim();
            var hashValue2 = document.getElementById('hashInput2').value.trim();

            var resultDisplay = document.getElementById('hashComparisonResult');

            resultDisplay.style.fontWeight = 'bold';

            if (hashValue1 === "" || hashValue2 === "") {
                resultDisplay.textContent = 'Es m√ºssen beide Hashwerte eingegeben werden.';
                resultDisplay.style.color = 'black';
            } else if (hashValue1 === hashValue2) {
                resultDisplay.textContent = 'Die Hashwerte stimmen √ºberein!';
                resultDisplay.style.color = 'black';
            } else {
                resultDisplay.textContent = 'Die Hashwerte stimmen nicht √ºberein.';
                resultDisplay.style.color = 'red';
            }
        }

        function copyTextHash() {
            const hashValue = document.getElementById('hashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("Text-Hash konnte nicht kopiert werden.");
                });
            }
        }

        function copyFileHash() {
            const hashValue = document.getElementById('fileHashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("Datei-Hash konnte nicht kopiert werden.");
                });
            }
        }

        function clearAll() {
            document.getElementById('textInput').value = '';
            document.getElementById('hashOutput').textContent = '';
            document.getElementById('hashCompareInput').value = '';
            document.getElementById('textCompareResult').textContent = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('fileHashOutput').textContent = '';
            document.getElementById('compareFileInput').value = '';
            document.getElementById('fileCompareResult').textContent = '';
            document.getElementById('hashInput1').value = '';
            document.getElementById('hashInput2').value = '';
            document.getElementById('hashComparisonResult').textContent = '';
        }

        document.getElementById('menuIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .menuUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });
        document.getElementById('languageIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .langUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });

        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var menunavbarUl = document.querySelector('.navbar .menuUl');

            var languageIcon = document.getElementById('languageIcon');
            var langnavbarUl = document.querySelector('.navbar .langUl');

            if (!menuIcon.contains(event.target) && !menunavbarUl.contains(event.target)) {
                menunavbarUl.style.display = 'none';
            }
            if (!languageIcon.contains(event.target) && !langnavbarUl.contains(event.target)) {
                langnavbarUl.style.display = 'none';
            }
        });
        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var navbarUl = document.querySelector('.navbar ul');

            if (!menuIcon.contains(event.target) && !navbarUl.contains(event.target)) {
                navbarUl.style.display = 'none';
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
        });

        document.getElementById('lightStyle').addEventListener('click', function () {
            setStyle('light-mode');
        });

        document.getElementById('darkStyle').addEventListener('click', function () {
            setStyle('dark-mode');
        });

        function setStyle(style) {
            document.body.className = style;
            localStorage.setItem('style', style);
            updateButtonStyles();
            updateNavbarStyles(style);
        }

        function updateNavbarStyles(style) {
            var navbar = document.querySelector('.navbar');
            var ul = navbar.querySelector('ul');
            navbar.style.backgroundColor = style === 'dark-mode' ? '#0A0F24' : '#FFFFFF';
            ul.style.backgroundColor = style === 'dark-mode' ? 'rgba(119, 136, 153, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            ul.style.color = style === 'dark-mode' ? '#FFFFFF' : '#0A0F24';
        }

        document.querySelectorAll('.learnMore').forEach(function (link) {
            link.addEventListener('click', function () {
                var targetId = this.getAttribute('data-target');
                var moreContent = document.getElementById(targetId);
                if (moreContent.style.display === "none" || moreContent.style.display === "") {
                    moreContent.style.display = "block";
                    this.textContent = "[Schlie√üung]";
                } else {
                    moreContent.style.display = "none";
                    this.textContent = "[Erfahren Sie mehr]";
                }
            });
        });

        window.onscroll = function () { scrollFunction(); };
        function scrollFunction() {
            if (document.body.scrollTop > 10 || document.documentElement.scrollTop > 20) {
                document.getElementById("backToTop").style.display = "block";
            } else {
                document.getElementById("backToTop").style.display = "none";
            }
        }
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        document.addEventListener('DOMContentLoaded', function () {
            var navbar = document.querySelector('.navbar');
            window.onscroll = function () {
                if (window.scrollY > 50) {
                    navbar.classList.add('solid');
                } else {
                    navbar.classList.remove('solid');
                }
            };
        });

        function adjustButton() {
            var button = document.getElementById('backToTop');
            if (window.innerWidth < 768) {
                button.innerHTML = '‚ñ≤';
            } else {
                button.innerHTML = 'Zur√ºck nach oben(<span class="highlight-key">B</span>)';
            }
        }

        window.onload = adjustButton;
        window.onresize = adjustButton;

    </script>
    <div style="display: none;">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-LZTEEH0M4K"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
    
            gtag('config', 'G-LZTEEH0M4K');
        </script>
    </div>
</body>
</html>