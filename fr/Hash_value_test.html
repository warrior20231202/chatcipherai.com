<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorateur Hash SHA-256 : Le sculpteur irr√©versible du monde num√©rique.</title>
    <meta name="description"
          content="Forgeant l'empreinte unique de l'information avec un cryptage de 256 bits, prot√©geant l'int√©grit√© et l'authenticit√© des donn√©es.">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="icon" type="image/jpg" href="./images/cipher.jpg">
    <style>    
        html {
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100vh;
            align-items: center;
            margin: 0;
            padding: 0 20px 20px 20px;
            background-color: #0A0F24;
            color: #FFFFFF;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(10, 15, 36, 0.0);
            transition: background-color 0.5s ease;
            z-index: 1000;
            height: 40px;
        }

        .navbar.solid {
            background-color: rgba(10, 15, 36, 1);
        }

        #menuIcon {
            cursor: pointer;
            transition: color 0.3s ease;
        }

        #menuIcon:hover {
            color: #a3a2a2;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            position: relative;
            left: -10px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        .navbar .langUl {
            left: 87px;
            width: 100px;
        }

        .navbar.active ul {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 35px;
            left: 10px;
            width: 15%;
            background-color: rgba(119, 136, 153, 0.8);
            padding: 10px 0;
        }

        .navbar.active ul li {
            margin-bottom: 1px;
        }

        .navbar.active ul li:last-child {
            margin-bottom: 0;
        }

        .navbar ul {
            display: none;
            flex-direction: column;
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: transparent;
            padding: 10px 0;
            list-style: none;
            margin: 0;
            width: 13%;
        }

        .navbar.active ul {
            display: flex;
        }

        .section.interactive-tool {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #bbbaba;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 1000px;
            margin-top: 30px;
            margin-bottom: 150px;
        }

        .sections-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 120px;
            margin-right: -10px;
        }

        .sections-container h2,
        .sections-container p {
            text-align: left;
            width: 80%;
        }

        p {
            margin-bottom: 30px;
            text-align: left;
            font-size: 1.2em;
            line-height: 1.6;
            margin-bottom: 15px;
            text-align: center; 
        }

        h2 {
            margin-bottom: 10px;
            font-size: 28px;
            margin-top: 50px;
        }

        h3 {
            margin-top: 50px;
            font-size: 22px;
        }

        h4 {
            font-size: 20px;
        }

        .sections-container h2:hover {
            color: #4bcfcf;
            transition: color 0.3s ease;
        }

        .navbar li a {
            color: white;
            padding: 5px;
            text-decoration: none;
            font-size: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            display: block;
            border-radius: 5px;
        }

        .navbar ul li {
            margin-bottom: 1px;
        }

        .navbar ul li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .navbar h1 {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 35px;
            margin-right: 0;
            font-size: 30px;
        }

        .navbar-dark {
            background-color: #0A0F24;
        }

        .morse-code-container {
            display: flex;
            align-items: center;
        }

        .morse-code-container .copy-button {
            margin-right: 5px;
            margin-left: 0;
        }

        button {
            cursor: pointer;
            margin: 10px;
            padding: 8px 15px;
            margin-left: 5px;
            background-color: #c0c0c0;
            border: none;
            border-radius: 5px;
            color: #FFFFFF;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #a8a8a8;
        }

        .style-selector {
            position: absolute;
            top: 0px;
            right: 50px;
            margin-top: 10px;
        }

        .style-selector button {
            background-color: #0a0f24;
            padding: 5px 10px;
            margin-right: 1px;
            color: #F5F5F5;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .style-selector button:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .dark-mode {
            background-color: #0A0F24;
            color: white;
        }

        .light-mode {
            background-color: white;
            color: #0A0F24;
        }

        .light-mode .navbar,
        .light-mode .container {
            background-color: #FFFFFF;
            color: #0A0F24;
        }

        .light-mode .navbar ul {
            background-color: transparent;
            color: #0A0F24;
        }

        .dark-mode .navbar ul li a:hover {
            color: #30eded;
        }

        .light-mode .navbar ul li:hover {
            color: #0A0F24;
            background-color: rgba(255, 255, 255, 1);
            border-radius: 5px;
        }

        .navbar {
            justify-content: flex-start;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            margin-left: 30px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        #languageSelect {
            padding: 5px 10px;
            margin-left: 10px;
            border-radius: 5px;
            border: none;
            background-color: #5f9ea0;
            color: white;
            cursor: pointer;
        }

        #languageSelect:hover {
            background-color: #2F4F4F;
        }

        .language-dropdown {
            width: 6%;
            display: none;
            list-style: none;
            padding: 10px 0;
            margin: 0;
            position: absolute;
            top: 40px;
            left: 100px;
            background-color: rgba(119, 136, 153, 0.8);
        }

        .language-dropdown li a {
            color: #FFFFFF;
            padding: 5px;
            margin: 1px;
            text-decoration: none;
            display: block;
            border-radius: 8px;
        }

        .language-dropdown li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .table-container {
            display: none;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .table-container.active {
            display: block;
        }

        .button-container {
            display: flex;
            justify-content: center;
            margin-right: 20px
        }

        .button-container button {
            margin-right: 30px;
        }

        .footer {
            position: relative;
            width: 100%;
            background-color: #0A0F24;
            color: #FFFFFF;
            text-align: center;
            padding: 10px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            margin-bottom: -20px;
        }

        .footer a {
            color: #F5F5F5;
            text-decoration: none;
            margin: 0 12px;
            transition: color 0.3s ease;
        }

        .footer a:hover {
            color: #a3a2a2;
        }

        .footer p {
            margin: 0;
            font-size: 16px;
        }

        .learnMore {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .moreContent {
            width: 80%;
            margin: auto;
            text-align: left;
            padding: 10px;
            display: none;
            margin-left: 0px;
        }

        .moreContent p {
            margin-bottom: 16px;
            font-size: 1.2em;
            line-height: 1.6;
            padding-bottom: 5px;
        }

        #moreContent1 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent1 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        #moreContent2 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent2 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        .clear-all-button {
            background-color: #47d7ff;
        }

        .clear-all-button:hover {
            background-color: #57f7ff;
        }

        figure {
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            text-align: center;
            width: 100%;
            margin: 0 auto;
        }

        img {
            max-width: 75%;
            height: auto;
            margin-left: -290px;
            margin-top: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        figcaption.workflow,
        figcaption.Irreversibility,
        figcaption.Resistance,
        figcaption.Merkle-Damg√•rd,
        figcaption.Compare,
        figcaption.sponge {
            width: 100%;
            margin-left: -300px;
            color: #007bff;
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 10px;
        }

        .navbar li {
            position: relative;
        }

        .navbar li>a {
            display: block;
        }

        .navbar .submenu {
            display: none;
            position: absolute;
            left: 101%;
            top: 0;
            background-color: transparent;
            border-radius: 5px;
            padding: 0;
            min-width: 150px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .navbar .submenu li {
            display: block;
            border-bottom: none;
            width: 85%;
        }

        .navbar .submenu li:last-child {
            border-bottom: none;
        }

        .navbar li:hover>.submenu {
            display: block;
        }

        .navbar .submenu a {
            color: #ffffff;
            padding: 5px;
            text-decoration: none;
            display: block;
            transition: background-color 0.3s ease;
        }

        .navbar .submenu a:hover {
            background-color: rgba(255, 255, 255, 0.206);
        }

        .input-group {
            display: flex;
            width: 83%;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 40px;
        }

        .input-group>div {
            flex: 1;
            margin-right: 20px;
        }

        .input-group>div:last-child {
            margin-right: 0;
        }

        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 10px 15px 10px 5px;
            border: 1px solid #eae6e6;
            border-radius: 5px;
            box-sizing: border-box;
        }

        button,
        input[type="submit"],
        input[type="file"]::file-selector-button {
            background-color: #0a0f24;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s;
        }

        button:hover,
        input[type="submit"]:hover,
        input[type="file"]::file-selector-button:hover {
            background-color: #c0c0c0;
            color: #0A0F24;
        }

        .compare-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        input[type="file"] {
            display: block;
        }

        .outPut {
            width: 100%;
            white-space: normal;
            word-break: break-all;
        }

        #backToTop {
            position: absolute;
            bottom: 5px;
            right: 30px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #0a0f24;
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
            display: block;
        }

        #backToTop:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .section {
            padding-left: 220px;
        }

        section li {
            font-size: 17px;
            line-height: 1.5;
            word-wrap: break-word;
            width: 80%;
            padding-bottom: 10px; 
        }

        .language-list{
            float: right;
        }
        .language-list a{
            margin-left: 20px;
            color: white;
        }

        .language-list a:hover{
            color: #4bcfcf;
        }

        .language-list a {
            text-decoration: none;
        }

        .attention {
            margin-top: 20px;
            font-size: 0.8em;
        }

        .highlight-key { 
            font-weight: 800;
        }

        @media screen and (max-width: 768px) {
            .navbar h1 {
                font-size: 18px;
                position: absolute;
                top: -25px;
            }

            .sections-container {
                margin-left: auto;
                margin-right: auto;
                align-items: center;
                width: 93%;
            }

            .section {
                width: 100%;
                padding: 10px;
            }

            .section h2 {
                font-size: 1.2em; 
            }

            h3 {
                font-size: 0.9em; 
            }

            h4 {
                font-size: 0.8em; 
            }

            .section p {
                font-size: 0.9em; 
            }

            section li {
                font-size: 14px;
                margin-left: -20px;
            }

            figure {
                display: flex;
                flex-direction: column;
                align-items: center; 
                justify-content: center; 
                text-align: center;
                width: 100%;
                margin: 0 auto;
            }

            img {
                max-width: 80%;
                height: auto;
                margin-left: -90px;
                margin-top: 20px;
            }

            figcaption.workflow,
            figcaption.Irreversibility,
            figcaption.Resistance,
            figcaption.Merkle-Damg√•rd,
            figcaption.Compare,
            figcaption.sponge {
                width: 100%;
                margin-left: -100px;
                color: #007bff;
                font-size: 0.8em;
                font-weight: bold;
                margin-top: 10px;
            }

            .footer p {
                margin: 0;
                font-size: 10px;
            }

            pre {
                display: none;
            }

            #backToTop {
                content: '‚ñ≤';
                padding: 4px 5px;
                font-size: 14px;
                right: 10px;
                bottom: 0px;
            }
   
            .input-group {
                flex-direction: column;
            }

            .section.interactive-tool {
                width: 320px;
            }
            .navbar ul {
                width: 30%;
            }

            .navbar ul li {
                padding: 0 5px 0 0;
            }

            .navbar li a {
                padding: 5px;
            }

            .navbar li a {
                font-size: 10px;
                width: 100%;
                padding: 5px 0px 5px 5px;
            }

            .navbar .submenu {
                left: 100%;
            }

            .navbar .submenu li {
                display: block;
                border-bottom: none;
                width: 55%;
                padding: 0 5px 0 0;
            }

            .navbar .submenu li a {
                padding: 5px 0px 5px 5px;
            }

            #menuIcon {
                font-size: 0; /* Hide text */
            }

            #menuIcon::before {
                content: '\2630'; /* Unicode character for ‚ò∞ */
                font-size: 16px; /* Or any other size you prefer */
            }

            #languageIcon {
                font-size: 0; 
            }

            #languageIcon::before {
                content: '\2637';
                font-size: 16px; /* Or any other size you prefer */
            }

            .navbar .langUl {
                left: 42px;
                width: 65px;
            }

            #darkStyle {
                font-size: 0;
                margin-left: 10px;
                padding: 5px 8px;
            }

            #lightStyle {
                font-size: 0;
                margin-right: -10px;
            }

            #darkStyle::before {
                font-size: 9px;
            }

            #lightStyle::before {
                font-size: 10px;
            }

            #darkStyle::before {
                content: "üåô";
            }

            #lightStyle::before {
                content: "‚òÄ";
            }

            .social-links i {
                font-size: 12px;
            }

            .attention {
                margin-top: 10px;
                font-size: 0.5em;
            }
        }
    </style>
</head>

<body class="dark-mode">
    <header>
        <nav class="navbar">
            <div id="menuIcon">&#9776; menu</div>
            <div id="menuItems"></div>
            <ul class="menuUl">
                <li>
                    <a href="https://chatcipherai.com/fr/chatcipherai.html">Monde des Cryptosyst√®mes</a>
                    <ul class="submenu">
                        <li><a href="https://chatcipherai.com/fr/Caesar_Cipher.html">Chiffre de C√©sar</a></li>
                        <li><a href="https://chatcipherai.com/fr/Playfair_Cipher.html">Chiffre de Playfair</a></li>
                        <li><a href="https://chatcipherai.com/fr/Hill_Cipher.html">Chiffre de Hill</a></li>  
                    </ul>
                </li>
                <li><a href="https://chatcipherai.com/fr/Hash_value_test.html">Test de Valeur de Hachage</a></li>
                <li><a href="https://chatcipherai.com/fr/Morsecode_main.html">Traducteur de Code Morse</a></li>
                <li><a href="https://chatcipherai.com/fr/Shortcut_Key_Description.html">Description des raccourcis clavier</a></li>
            </ul>

            <div id="languageIcon">&#x2637; lang</div>
            <div id="languageItems">
                <ul class="langUl">
                    <li><a href="https://chatcipherai.com/en/Hash_value_test.html" title="English">English</a></li>
                    <li><a href="https://chatcipherai.com/fr/Hash_value_test.html" title="Fran√ßais">Fran√ßais</a></li>
                    <li><a href="https://chatcipherai.com/es/Hash_value_test.html" title="Espa√±ol">Espa√±ol</a></li>
                    <li><a href="https://chatcipherai.com/zh-CN/Hash_value_test.html" title="‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ">‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ</a></li>
                    <li><a href="https://chatcipherai.com/zh-TW/Hash_value_test.html" title="‰∏≠ÊñáÔºàÁπÅ‰ΩìÔºâ">‰∏≠ÊñáÔºàÁπÅ‰ΩìÔºâ</a></li>
                    <li><a href="https://chatcipherai.com/ar/Hash_value_test.html" title="ÿßŸÑÿπÿ±ÿ®Ÿäÿ©">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</a></li>
                    <li><a href="https://chatcipherai.com/ru/Hash_value_test.html" title="–†—É—Å—Å–∫–∏–π">–†—É—Å—Å–∫–∏–π</a></li>
                    <li><a href="https://chatcipherai.com/pt/Hash_value_test.html" title="Portugu√™s">Portugu√™s</a></li>
                    <li><a href="https://chatcipherai.com/de/Hash_value_test.html" title="Deutsch">Deutsch</a></li>
                    <li><a href="https://chatcipherai.com/hi/Hash_value_test.html" title="‡§π‡§ø‡§®‡•ç‡§¶‡•Ä">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</a></li>
                    <li><a href="https://chatcipherai.com/nl/Hash_value_test.html" title="Nederlands">Nederlands</a></li>
                </ul> 
            </div>

            <h1>Explorateur de Hash SHA-256</h1>

            <div class="style-selector">
                <button id="darkStyle">üåô Style Sombre(<span class="highlight-key">N</span>)</button>
                <button id="lightStyle">‚òÄ Style Lumineux(<span class="highlight-key">L</span>)</button>
            </div>            
        </nav>
    </header>

    <main class="sections-container">
        <section class="section interactive-tool">
            <h2>Test de Valeur de Hachage</h2>
            <p>Entrez du texte pour voir le processus de conversion en une valeur de hachage en temps r√©el,
                <br>
                ou s√©lectionnez un fichier pour calculer la valeur de hachage du fichier.
            </p>

            <div class="input-group">
                <div>
                    <p>G√©n√©rer la Valeur de Hachage du Texte</p>
                    <input type="text" class="input_value" id="textInput" placeholder="Entrez du texte" oninput="generateHash()" />
                    <button onclick="copyTextHash()">Copier la valeur de hachage du texte</button>
                    <div id="processOutput"></div>
                    <div id="hashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Comparer la Valeur de Hachage du Texte</p>
                    <input type="text" class="input_value" id="hashCompareInput"
                        placeholder="Entrez la valeur de hachage pour comparaison" />
                    <button onclick="compareTextHash()">Comparer</button>
                    <div id="textCompareResult"></div>
                </div>
            </div>

            <div class="input-group">
                <div>
                    <p>G√©n√©rer la Valeur de Hachage du Fichier</p>
                    <input type="file" id="fileInput" onchange="generateFileHash()" />
                    <button onclick="copyFileHash()">Copier la valeur de hachage du fichier</button>
                    <div id="fileHashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Comparer la Valeur de Hachage du Fichier</p>
                    <input type="file" id="compareFileInput" onchange="compareFileHash()" />
                    <div id="fileCompareResult" class="outPut"></div>
                </div>
            </div>

            <div class="input-group">
                <div>
                    <p>Saisissez la valeur de hachage 1</p>
                    <input type="text" class="input_value" id="hashInput1" placeholder="Entrez la valeur de hachage 1" />
                </div>
                <div>
                    <p>Saisissez la valeur de hachage 2</p>
                    <input type="text" class="input_value" id="hashInput2" placeholder="Entrez la valeur de hachage 2" />
                    <button onclick="compareHashValues()">Comparer</button>
                    <div id="hashComparisonResult" class="outPut"></div>
                </div>
            </div>
        
            <button id="clearAllButton" class="clear-all-button" onclick="clearAll()">Tout effacer(<span class="highlight-key">A</span>)</button>
            <div class="attention">
                Rappel aimable : Avant de saisir des donn√©es, veuillez v√©rifier soigneusement l'exactitude et la sensibilit√© des informations. Nous vous conseillons d'uploader vos donn√©es importantes avec prudence, ce qui contribuera √† renforcer la protection de votre confidentialit√© et de votre s√©curit√©.
            </div>
        </section>

        <article class="section">
            <p><strong><em>"Dans l'√®re num√©rique actuelle, la s√©curit√© des donn√©es n'est pas seulement la pierre angulaire de la protection de la vie priv√©e personnelle et des secrets d'entreprise, mais aussi la cl√© pour maintenir la confiance sociale et la stabilit√© √©conomique."</em></strong></p>
            <section>
                <h2>Qu'est-ce qu'une Valeur de Hachage ?</h2>
                <p>
                    Une valeur de hachage est une cha√Æne ou un nombre de taille fixe g√©n√©r√© √† partir de toute taille de donn√©es d'entr√©e par une fonction de hachage.
                    Ces fonctions acceptent des entr√©es diverses comme du texte, des images et des vid√©os, produisant une valeur de hachage irr√©versible de longueur fixe.
                    Les valeurs de hachage sont d√©terministes, ce qui signifie que des entr√©es identiques produisent toujours le m√™me r√©sultat. Elles pr√©sentent √©galement une r√©sistance aux collisions,
                    rendant difficile la recherche d'entr√©es distinctes qui produisent le m√™me r√©sultat.
                </p>
            </section>

            <section>
                <h2>Fonctions de la Valeur de Hachage</h2>
                <p>
                    Les valeurs de hachage jouent des r√¥les essentiels dans l'informatique et les TI, offrant un r√©sum√© de longueur fixe des donn√©es, quelle que soit leur taille. Ces fonctions facilitent diverses applications :
                </p>
                <ul>
                    <li><strong>V√©rification de l'int√©grit√© des donn√©es :</strong> Utilis√©e pour v√©rifier si les donn√©es restent inchang√©es lors de la transmission, garantissant l'int√©grit√© des fichiers t√©l√©charg√©s.</li>
                    <li><strong>Stockage des mots de passe :</strong> Les mots de passe sont stock√©s sous forme de valeurs de hachage pour la s√©curit√©, rendant difficile la r√©cup√©ration des mots de passe originaux √† partir des bases de donn√©es compromises.</li>
                    <li><strong>R√©cup√©ration rapide des donn√©es :</strong> Les valeurs de hachage agissent comme des indices dans les tables de hachage, permettant des op√©rations de donn√©es efficaces.</li>
                    <li><strong>D√©duplication des donn√©es :</strong> Aide √† identifier et √† supprimer les √©l√©ments de donn√©es en double en comparant les valeurs de hachage.</li>
                    <li><strong>Signature num√©rique et v√©rification :</strong> Assure l'int√©grit√© des donn√©es et leur origine gr√¢ce √† la cryptographie √† cl√© publique et aux fonctions de hachage.</li>
                    <li><strong>Technologie Blockchain :</strong> Utilise les valeurs de hachage pour s√©curiser les enregistrements de transactions et garantir l'immuabilit√© des donn√©es.</li>
                    <li><strong>Horodatage infalsifiable :</strong> Fournit un horodatage irr√©versible pour les donn√©es, utile dans la protection l√©gale et des droits d'auteur.</li>
                </ul>
                <p>
                    Les valeurs de hachage sont efficaces dans ces domaines en raison de leurs caract√©ristiques cl√©s : rapidit√©, d√©terminisme, irr√©versibilit√© et r√©sistance aux collisions. Bien utilis√©es, les fonctions de hachage peuvent fournir un soutien robuste dans la s√©curisation des donn√©es, 
                    l'am√©lioration de l'efficacit√© et la v√©rification de l'authenticit√© des informations.
                </p>
            </section>
            
            <section>
                <h2>Qu'est-ce qu'une fonction de hachage ?</h2>
                <p>Une fonction de hachage est une construction math√©matique qui associe des donn√©es d'entr√©e (ou "message") √† une cha√Æne de taille fixe, g√©n√©ralement une valeur num√©rique, comme illustr√© dans le diagramme ci-dessous. Largement utilis√©e dans la gestion des donn√©es et la s√©curit√© de l'information, 
                    une fonction de hachage se caract√©rise par sa performance de calcul efficace, sa longueur de sortie constante, son irr√©versibilit√©, sa sensibilit√© aux variations d'entr√©e et sa r√©sistance aux collisions.
                </p>
                <figure>
                    <img src="./images/Hash input output.jpg" alt="Diagramme de flux de travail de la fonction de hachage" />
                    <figcaption class="workflow">Diagramme de flux de travail de la fonction de hachage</figcaption>
                </figure>
            </section>
            
            <section>
                <h3>Performance de calcul efficace</h3>
                <p>
                    Les fonctions de hachage peuvent rapidement calculer des valeurs de hachage √† partir de donn√©es de toute forme, quelle que soit la taille des donn√©es. Cette caract√©ristique est cruciale pour les applications n√©cessitant un acc√®s rapide aux donn√©es, telles que les tables de hachage.
                    Cela est d√ª au fait que, lors du stockage des donn√©es dans des tables de hachage, la vitesse de la fonction de hachage d√©termine la vitesse de r√©cup√©ration des donn√©es. Les tables de hachage utilisent des fonctions de hachage pour localiser rapidement l'emplacement de stockage des donn√©es, en s'appuyant sur la capacit√© de calcul rapide des fonctions de hachage.
                </p>
            
                <p>
                    De plus, dans les syst√®mes devant traiter de grandes quantit√©s de donn√©es, l'efficacit√© des fonctions de hachage impacte directement la performance globale du syst√®me. Si une fonction de hachage est lente, elle deviendra un goulot d'√©tranglement dans la performance du syst√®me. Certains syst√®mes en temps r√©el,
                    comme le filtrage de paquets dans les dispositifs r√©seau, n√©cessitent un calcul imm√©diat des valeurs de hachage pour les donn√©es afin de prendre rapidement des d√©cisions. Dans ces cas, l'efficacit√© des fonctions de hachage est tout aussi cruciale.
                </p>
            
                <p>
                    Par exemple, consid√©rez une plateforme de commerce en ligne o√π les utilisateurs peuvent entrer des noms de produits dans la barre de recherche pour trouver des produits. Le syst√®me backend peut utiliser des fonctions de hachage pour localiser rapidement les informations sur les produits stock√©es dans des tables de hachage.
                    Si le processus de calcul de la fonction de hachage est lent, l'exp√©rience utilisateur sera gravement affect√©e, car ils devront attendre plus longtemps pour obtenir les r√©sultats de la recherche. Dans cette situation, la performance de calcul efficace des fonctions de hachage assure des temps de r√©ponse rapides, am√©liorant ainsi l'exp√©rience utilisateur.
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent1">[En savoir plus]</a>
                </p>
            </section>
            
            <div id="moreContent1" class="moreContent" style="display:none;" style="color: #007bff; font-size: 1.0em;">
                <p>Les raisons pour lesquelles les fonctions de hachage peuvent am√©liorer l'efficacit√© du calcul sont principalement dues aux caract√©ristiques de conception suivantes :</p>
                <ul>
                    <li><strong>Op√©rations simples :</strong> Les fonctions de hachage utilisent g√©n√©ralement des op√©rations math√©matiques et bit √† bit simples, qui s'ex√©cutent tr√®s rapidement en raison du support mat√©riel direct du CPU.</li>
                    <li><strong>√âviter les d√©pendances de boucle :</strong> En √©vitant les d√©pendances de boucle, les fonctions de hachage permettent un traitement en pipeline, augmentant ainsi la vitesse.</li>
                    <li><strong>Traitement parall√®le :</strong> Les fonctions de hachage modernes sont con√ßues pour le traitement parall√®le, am√©liorant l'efficacit√© sur les processeurs multic≈ìurs.</li>
                    <li><strong>Taille de sortie fixe :</strong> La sortie de longueur fixe simplifie l'allocation de m√©moire et la comparaison des donn√©es, am√©liorant le mod√®le de programmation et l'efficacit√©.</li>
                    <li><strong>Pr√©traitement et post-traitement :</strong> Les fonctions de hachage peuvent traiter de grandes donn√©es en les divisant en blocs, en calculant s√©par√©ment les valeurs de hachage, puis en les combinant, ce qui am√©liore l'efficacit√©.</li>
                    <li><strong>Chemins d'algorithme optimis√©s :</strong> La r√©duction du branchement lors de l'ex√©cution augmente la pr√©cision de la pr√©diction des instructions sur les CPU, augmentant ainsi la vitesse.</li>
                    <li><strong>Compatible avec le cache :</strong> Concevoir des fonctions de hachage pour minimiser les d√©fauts de cache augmente consid√©rablement la vitesse de traitement.</li>
                    <li><strong>Optimisation mat√©rielle :</strong> Les acc√©l√©rateurs mat√©riels d√©di√©s peuvent augmenter consid√©rablement la vitesse des calculs de hachage, en particulier pour les fonctions de hachage cryptographiques comme la s√©rie SHA.</li>
                    <li><strong>Non √©tatique :</strong> Les fonctions de hachage ne conservent pas d'informations d'√©tat, permettant un traitement l√©ger de chaque nouvelle entr√©e.</li>
                    <li><strong>Universalit√© :</strong> Les fonctions de hachage sont universelles pour tous les types de donn√©es d'entr√©e, √©liminant le besoin d'algorithmes personnalis√©s pour diff√©rents types de donn√©es.</li>
                </ul>
            </div>
            
            <section>
                <h3>Consistance de la longueur de sortie dans les fonctions de hachage</h3>
                <p>
                    Les fonctions de hachage transforment une entr√©e de n'importe quelle longueur en une sortie de longueur fixe √† travers une s√©rie complexe de calculs. Ce processus implique souvent de diviser les donn√©es d'entr√©e en blocs de taille fixe (pour les entr√©es d√©passant la taille de l'unit√© de traitement),
                    d'appliquer une s√©rie d'op√©rations math√©matiques et logiques √† chaque bloc, puis de combiner ou d'accumuler les r√©sultats de ces op√©rations d'une certaine mani√®re pour produire finalement une valeur de hachage de taille fixe.
                </p>
                <p>
                    <strong>Pourquoi est-ce important ?</strong>
                    La consistance de la longueur de sortie aide √† assurer la s√©curit√© des fonctions de hachage. Si la longueur de la sortie du hachage pouvait varier, cela pourrait divulguer des informations sur la taille des donn√©es originales, ce qui pourrait potentiellement √™tre exploit√© pour attaquer le syst√®me dans certains sc√©narios.
                    De plus, une longueur de sortie fixe rend √©galement difficile pour les attaquants de d√©duire les caract√©ristiques des donn√©es d'entr√©e en analysant la longueur de sortie. En m√™me temps, les sorties de longueur fixe simplifient le stockage et la comparaison des valeurs de hachage.
                    Les concepteurs de syst√®mes peuvent savoir √† l'avance combien d'espace chaque valeur de hachage occupera, ce qui est tr√®s important pour des sc√©narios tels que la conception de bases de donn√©es et la transmission r√©seau. En outre, la consistance de la longueur de sortie devient tr√®s efficace pour comparer si les valeurs de hachage sont √©gales car cela n√©cessite uniquement de comparer des donn√©es de longueur fixe.
                    Cela est particuli√®rement important lors de l'utilisation de tables de hachage pour une r√©cup√©ration rapide des donn√©es.
                </p>
                <p>
                    Prenant SHA-256 comme exemple, cette fonction de hachage cryptographique largement utilis√©e produit toujours une valeur de hachage de 256 bits (c'est-√†-dire 32 octets), que les donn√©es d'entr√©e soient un seul octet ou plusieurs millions d'octets. Cette consistance garantit que les valeurs de hachage SHA-256 peuvent √™tre utilis√©es pour diverses applications de s√©curit√©,
                    telles que les signatures num√©riques et les codes d'authentification de message (MAC), tout en simplifiant le flux de travail de traitement et de stockage des donn√©es.
                </p>
            </section>
            
            <section>
                <h3>Irreversibilit√© des fonctions de hachage</h3>
                <p>
                    Les fonctions de hachage sont unidirectionnelles, signifiant qu'il est impossible de d√©duire les donn√©es originales √† partir de la valeur de hachage. Cette caract√©ristique est particuli√®rement importante pour le stockage des mots de passe, car m√™me si la base de donn√©es est compromise, les attaquants ne peuvent pas r√©cup√©rer les mots de passe √† partir des valeurs de hachage.
                    L'irr√©versibilit√© des fonctions de hachage repose principalement sur les principes et caract√©ristiques suivants :
                </p>
                <ul>
                    <li><strong>Compression :</strong> Les fonctions de hachage peuvent mapper des entr√©es de toute longueur (qui peuvent √™tre tr√®s grandes en pratique) vers une sortie de longueur fixe. Cela signifie qu'il y a infiniment beaucoup d'entr√©es possibles mapp√©es vers un nombre fini de sorties. Comme l'espace de sortie (valeurs de hachage) est beaucoup plus petit que l'espace d'entr√©e, diff√©rentes entr√©es produiront in√©vitablement la m√™me sortie, un ph√©nom√®ne connu sous le nom de "collision". En raison de cette compression, il est impossible de d√©terminer l'entr√©e sp√©cifique √† partir d'une sortie donn√©e (valeur de hachage).</li>
                    <li><strong>Haute non-lin√©arit√© et complexit√© :</strong> Les fonctions de hachage sont con√ßues en utilisant des op√©rations math√©matiques et logiques complexes (telles que les op√©rations bit √† bit, les op√©rations modulo, etc.), pour garantir que la sortie est tr√®s sensible √† l'entr√©e. M√™me de petits changements dans l'entr√©e (par exemple, changer un bit) peuvent provoquer des changements importants et impr√©visibles dans la sortie (valeur de hachage). Ce haut degr√© de non-lin√©arit√© et le caract√®re al√©atoire de la sortie rendent extr√™mement difficile de d√©duire l'entr√©e originale √† partir de la valeur de hachage.</li>
                    <li><strong>Unidirectionnalit√© :</strong> La conception des fonctions de hachage garantit que leur fonctionnement est √† sens unique ; c'est-√†-dire que si le calcul de la valeur de hachage est facile, le processus inverse (r√©cup√©rer les donn√©es originales √† partir de la valeur de hachage) n'est pas faisable. Cela est d√ª au fait que le processus de calcul des fonctions de hachage implique une s√©rie d'op√©rations irr√©versibles (telles que l'irr√©versibilit√© des op√©rations modulo), garantissant que m√™me avec la valeur de hachage, il est impossible de r√©tro-concevoir les donn√©es originales.</li>
                    <li><strong>Cartographie al√©atoire :</strong> Une fonction de hachage id√©ale devrait agir comme un "cartographe al√©atoire", signifiant que chaque entr√©e possible est √©galement susceptible d'√™tre mapp√©e √† n'importe quel point dans l'espace de sortie. Cette propri√©t√© garantit qu'il n'y a aucun moyen faisable de pr√©dire √† quel r√©sultat une entr√©e sp√©cifique sera mapp√©e, renfor√ßant l'irr√©versibilit√© de la fonction de hachage.</li>
                    <li><strong>Fondation math√©matique :</strong> Math√©matiquement, l'irr√©versibilit√© des fonctions de hachage peut √™tre comprise gr√¢ce √† leur d√©pendance √† des "probl√®mes de logarithme discret", "probl√®mes de factorisation de grands entiers" ou d'autres probl√®mes de th√©orie des nombres qui sont difficiles √† r√©soudre avec les capacit√©s math√©matiques et informatiques actuelles. Par exemple, la conception de certains algorithmes de hachage peut d√©pendre indirectement de la difficult√© de calcul de ces probl√®mes, garantissant ainsi leur irr√©versibilit√©.</li>
                </ul>
                <figure>
                    <img src="./images/Irreversibility.jpg" alt="Irr√©versibilit√© des fonctions de hachage" />
                    <figcaption class="Irreversibility">Irr√©versibilit√© des fonctions de hachage</figcaption>
                </figure>
            </section>            

            <section>
                <h3>Sensibilit√© aux entr√©es et l'effet avalanche</h3>
                <p>
                    Dans la conception des fonctions de hachage, des op√©rations math√©matiques et logiques complexes (telles que les op√©rations bit √† bit, les op√©rations modulo, etc.) sont utilis√©es pour garantir que la sortie soit hautement sensible √† l'entr√©e.
                    M√™me de petits changements dans l'entr√©e (par exemple, changer un seul bit) entra√Æneront des changements significatifs et impr√©visibles dans la sortie (la valeur de hachage), un ph√©nom√®ne connu sous le nom d'¬´ effet avalanche ¬ª.
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent2">[En savoir plus]</a>
                </p>
            </section>
            
            <div id="moreContent2" class="moreContent" style="display:none;">
                <p>L'<a href="https://en.wikipedia.org/wiki/Avalanche_effect" target="_blank" rel="noopener noreferrer" style="color: #007bff; font-size: 1.0em;">effet avalanche</a> peut avoir diff√©rentes interpr√©tations dans divers domaines :</p>
                <ul>
                    <li><strong>En cryptographie :</strong> L'effet avalanche est une propri√©t√© souhaitable des algorithmes de chiffrement (en particulier les chiffrements par blocs et les fonctions de hachage cryptographiques). Il se produit lorsque le moindre changement dans l'entr√©e (par exemple, inverser un bit binaire) conduit √† des changements indiscernables dans la sortie (avec une probabilit√© de 50 % d'inverser chaque bit binaire dans la sortie). Cette caract√©ristique aide √† renforcer la s√©curit√© du chiffrement car des changements significatifs dans la sortie peuvent se produire m√™me avec seulement de mineurs changements dans l'entr√©e, rendant plus difficile de craquer le chiffrement en analysant la relation entre l'entr√©e et la sortie.</li>
                    <li><strong>En affaires et technologie :</strong> L'effet avalanche fait r√©f√©rence au ph√©nom√®ne o√π une √©nergie significative peut √™tre lib√©r√©e en d√©mantelant et recombinant de mani√®re appropri√©e la structure et le syst√®me inh√©rents aux affaires et √† la technologie. Cette √©nergie peut d√©truire de vieux syst√®mes industriels comme une avalanche, ou m√™me causer la disparition d'une industrie enti√®re. Sous l'immense pression de l'avalanche, la connexion inh√©rente entre les affaires et la technologie est compl√®tement interrompue, n√©cessitant l'acceptation de nouvelles transformations et int√©grations. Cet effet d√©clenche finalement une s√©rie d'innovations r√©volutionnaires.</li>
                    <li><strong>En architecture de microservices :</strong> L'effet avalanche d√©crit le sc√©nario o√π, en raison des d√©pendances entre les services, une d√©faillance ou une indisponibilit√© dans un service peut se propager √† travers la cha√Æne d'appels, entra√Ænant la paralysie de l'ensemble du syst√®me. Les causes de l'effet avalanche peuvent inclure des d√©faillances mat√©rielles, des pics de trafic, la p√©n√©tration du cache, des bogues de programme, et des blocages de la JVM, entre autres.</li>
                    <li><strong>Dans le monde naturel :</strong> L'effet avalanche fait r√©f√©rence au ph√©nom√®ne o√π une petite pierre qui roule sur une montagne enneig√©e peut d√©clencher une avalanche. C'est parce que l'impact de la petite pierre provoque le rel√¢chement et la glissade des couches de neige environnantes, conduisant √† une avalanche √† plus grande √©chelle. Ce ph√©nom√®ne peut √©galement d√©crire de mani√®re m√©taphorique comment des √©v√©nements ou des facteurs mineurs peuvent d√©clencher d'√©normes r√©actions en cha√Æne.</li>
                </ul>
            </div>
            
            <section>
                <h3>R√©sistance aux collisions en cryptographie</h3>
                <p>
                    La r√©sistance aux collisions d'une fonction de hachage est un concept crucial en cryptographie, indiquant le niveau de s√©curit√© d'une fonction de hachage contre les attaques par collisions. Cette propri√©t√© implique que pour toute fonction de hachage <strong>H</strong>, il est pratiquement infaisable de trouver deux entr√©es distinctes <strong>x</strong> et <strong>y</strong> (<strong>x ‚â† y</strong>) telles que <strong>H(x) = H(y)</strong>. Une fonction de hachage avec une solide r√©sistance aux collisions rend extr√™mement difficile de trouver deux entr√©es diff√©rentes menant √† la m√™me valeur de sortie.
                </p>
                <figure>
                    <img src="./images/Collision Resistance.jpg" alt="Diagramme illustrant la r√©sistance aux collisions">
                    <figcaption class="Resistance">Illustration de la r√©sistance aux collisions</figcaption>
                </figure>
                <p>
                    La r√©sistance aux collisions joue un r√¥le vital dans le maintien de l'int√©grit√© des donn√©es et la v√©rification. En transformant les informations d'entr√©e en une sortie de taille fixe (ou empreinte), les fonctions de hachage garantissent qu'aucune deux entr√©es diff√©rentes ne produisent la m√™me sortie. Cette caract√©ristique unique permet √† la valeur de hachage d'identifier pr√©cis√©ment la valeur originale.
                </p>
                <p>
                    Lors de la cr√©ation ou du stockage de donn√©es, une valeur de hachage (ou empreinte) est g√©n√©r√©e en utilisant une fonction de hachage. Cette valeur est stock√©e ou transmise aux c√¥t√©s des donn√©es originales. Par exemple, les sites de t√©l√©chargement de logiciels affichent souvent les valeurs de hachage des fichiers pour la v√©rification de l'int√©grit√©. Les destinataires peuvent recalculer ind√©pendamment la valeur de hachage des donn√©es re√ßues pour confirmer leur int√©grit√©. Si les valeurs de hachage originales et recalcul√©es correspondent, l'int√©grit√© des donn√©es est v√©rifi√©e. Sinon, les donn√©es peuvent avoir √©t√© alt√©r√©es ou corrompues pendant la transmission ou le stockage.
                </p>
                <p>
                    Comparer les valeurs de hachage offre √©galement l'avantage de v√©rifier l'int√©grit√© des donn√©es sans n√©cessiter un espace de stockage important. Cette m√©thode permet aux destinataires de confirmer l'authenticit√© des donn√©es en comparant simplement les valeurs de hachage avant et apr√®s la transmission.
                </p>
                <figure>
                    <img src="./images/Compare Hash.jpg" alt="Processus de comparaison des valeurs de hachage">
                    <figcaption class="Compare">Processus de comparaison des valeurs de hachage</figcaption>
                </figure>
            </section>            
            
            <section>
                <h2>Les collisions de hachage peuvent-elles √™tre trouv√©es ?</h2>
                <p>
                    √Ä travers les caract√©ristiques des fonctions de hachage mentionn√©es ci-dessus, nous avons compris la r√©sistance aux collisions. Mais est-il possible que des collisions de hachage existent, c'est-√†-dire que deux entr√©es diff√©rentes produisent le m√™me r√©sultat ?
                    La r√©ponse est affirmative, les collisions existent bien. Selon le <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank" style="color: #007bff; font-size: 1.0em;">principe des tiroirs</a>, tant que l'espace d'entr√©e est suffisamment grand, il existe une possibilit√© de collisions de hachage.
                    Cela est d√ª au fait que l'espace de sortie des fonctions de hachage est g√©n√©ralement beaucoup plus petit que l'espace d'entr√©e, conduisant in√©vitablement √† plusieurs entr√©es diff√©rentes mapp√©es sur le m√™me r√©sultat.
                </p>
                
                <p>
                    Le principe des tiroirs est un principe simple et intuitif de math√©matiques combinatoires, stipulant que si plus de n objets sont plac√©s dans n conteneurs, alors au moins un conteneur contiendra deux objets ou plus.
                    Ce principe peut √©galement √™tre utilis√© pour expliquer des probl√®mes tels que le paradoxe des anniversaires.
                </p>
                <p>
                    L'application du principe des tiroirs est tr√®s large, avec des utilisations importantes dans des domaines tels que la cryptographie, l'informatique et les math√©matiques. Par exemple, en informatique, le principe des tiroirs est utilis√© pour prouver la correction de certains algorithmes ou pour analyser la complexit√© temporelle des algorithmes.
                    En cryptographie, le principe des tiroirs est √©galement utilis√© pour concevoir certaines m√©thodes d'attaque cryptographique, comme l'attaque par anniversaires.
                </p>
                <p>
                    Le paradoxe des anniversaires est une application classique du principe des tiroirs. Supposons qu'il y ait n personnes dans une pi√®ce.
                    Si nous voulons que la probabilit√© qu'au moins deux personnes partagent le m√™me anniversaire soit sup√©rieure √† 50 %, combien de personnes sont n√©cessaires ? Selon le principe des tiroirs,
                    si 367 personnes (en supposant qu'il y ait 366 jours dans une ann√©e, plus un jour suppl√©mentaire pour le 29 f√©vrier d'une ann√©e bissextile) sont plac√©es dans 366 ¬´ tiroirs ¬ª (c'est-√†-dire les anniversaires), alors au moins un ¬´ tiroir ¬ª contiendra deux personnes, signifiant qu'au moins deux personnes partagent le m√™me anniversaire. Ceci illustre le paradoxe des anniversaires.
                </p>
                <p>
                    Il est important de noter que, bien que le principe des tiroirs soit simple et intuitif, son application doit tenir compte du contexte sp√©cifique.
                    Par exemple, lors de l'application du principe des tiroirs, il est n√©cessaire de s'assurer que les variables al√©atoires impliqu√©es sont ind√©pendantes les unes des autres ; sinon, cela peut conduire √† des conclusions incorrectes. De plus, dans certains cas, il est √©galement n√©cessaire de prendre en compte des facteurs tels que la taille et la forme des tiroirs.
                </p>
            </section>
            
            <section>
                <p>
                    Cependant, tenter de trouver des collisions de hachage en parcourant simplement l'espace d'entr√©e peut ne pas √™tre pratique, principalement pour deux raisons :
                </p>
                <ul>
                    <li><strong>Complexit√© computationnelle :</strong> Pour la plupart des fonctions de hachage, l'espace d'entr√©e est vaste. Prenons SHA-256 comme exemple ; sa sortie est une valeur de hachage de 256 bits, ce qui signifie qu'il a 2^256 sorties possibles. Puisque l'un des objectifs de conception des fonctions de hachage est de minimiser autant que possible les collisions, th√©oriquement,
                            trouver une collision de hachage pour SHA-256 n√©cessiterait de parcourir environ 2^(256/2) = 2^128 entr√©es, selon le paradoxe des anniversaires, qui est le nombre approximatif d'entr√©es attendu pour trouver une collision. M√™me avec les superordinateurs les plus puissants actuellement disponibles, il faudrait bien au-del√† d'une vie humaine pour achever une telle t√¢che.
                            Sp√©cifiquement, le temps pour parcourir 2^128 entr√©es d√©passe de loin l'√¢ge de l'humanit√©, rendant consid√©r√© comme impossible de trouver une collision de hachage SHA-256 par simple parcours.</li>
                    <li><strong>Conception des fonctions de hachage :</strong> Les fonctions de hachage sont g√©n√©ralement con√ßues pour rendre la recherche de collisions computationnellement infaisable. Cela signifie que, bien que les collisions existent th√©oriquement, elles sont pratiquement impossibles √† trouver en pratique. C'est une caract√©ristique importante des fonctions de hachage cryptographiques (telles que SHA-256),
                            qui sont largement utilis√©es dans des domaines tels que les signatures num√©riques, le stockage des mots de passe, et plus encore.</li>
                </ul>
                <p>
                    Bien s√ªr, nous pouvons √©galement utiliser des algorithmes sp√©cifiques pour essayer de trouver des collisions de hachage. Ces algorithmes exploitent souvent certaines propri√©t√©s ou faiblesses connues des fonctions de hachage pour trouver des collisions. Voici quelques techniques et m√©thodes courantes pour trouver des collisions de hachage :
                </p>
                <ul>
                    <li><strong>Attaque par anniversaires :</strong> C'est une m√©thode simple bas√©e sur la probabilit√© utilis√©e pour estimer le temps n√©cessaire pour trouver une collision lorsque les entr√©es sont choisies au hasard. Le principe de l'attaque par anniversaires est que s'il y a beaucoup de personnes dans une pi√®ce, la probabilit√© que deux personnes aient le m√™me anniversaire augmente avec le nombre de personnes.
                            De mani√®re similaire, dans les fonctions de hachage, si un nombre suffisant d'entr√©es sont s√©lectionn√©es au hasard, il est probable que deux entr√©es produiront finalement la m√™me sortie de hachage.</li>
                    <li><strong>Attaque par force brute :</strong> C'est la m√©thode la plus simple, qui implique de parcourir toutes les entr√©es possibles pour trouver une collision. Cependant, cette m√©thode est peu pratique pour les fonctions de hachage avec de grands espaces d'entr√©e en raison des √©normes ressources computationnelles et du temps requis.</li>
                    <li><strong>Tables arc-en-ciel :</strong> Cette technique est utilis√©e pour pr√©calculer et stocker un grand nombre de valeurs de hachage et leurs entr√©es correspondantes. Les tables arc-en-ciel sont particuli√®rement utiles pour craquer les mots de passe qui n'ont pas utilis√© d'obfuscation de donn√©es al√©atoires ou qui ont une fonction de hachage connue. En consultant la table arc-en-ciel, un attaquant peut rapidement trouver une entr√©e qui correspond √† une valeur de hachage sp√©cifique.</li>
                    <li><strong>Attaques par extension de hachage :</strong> Certaines fonctions de hachage permettent aux attaquants de combiner des donn√©es suppl√©mentaires avec une valeur de hachage connue sans conna√Ætre l'entr√©e d'origine, g√©n√©rant ainsi une nouvelle valeur de hachage. Cette attaque peut √™tre utilis√©e pour construire des collisions ou effectuer d'autres types d'attaques.</li>
                    <li><strong>Entr√©es sp√©cialement construites :</strong> Parfois, les attaquants peuvent exploiter des faiblesses sp√©cifiques ou des comportements non lin√©aires dans les fonctions de hachage pour construire des entr√©es sp√©ciales qui sont plus susceptibles de produire des collisions dans la fonction de hachage.</li>
                </ul>
            </section>            

            <section>
                <h2>Quelles sont les fonctions de hachage couramment utilis√©es ?</h2>
                <h3>MD5 (Message Digest Algorithm 5)</h3>
                <p>
                    MD5 est une fonction de hachage cryptographique largement utilis√©e, con√ßue par Ronald Rivest dans les ann√©es 1990 pour remplacer l'ancien algorithme MD4. Elle peut convertir un message de n'importe quelle longueur en une valeur de hachage de longueur fixe (128 bits, soit 16 octets).
                    L'objectif de la conception de MD5 √©tait de fournir un moyen rapide et relativement s√ªr de g√©n√©rer une empreinte num√©rique des donn√©es. Cependant, des m√©thodes de collision pour <a href="https://fr.wikipedia.org/wiki/MD5" target="_blank" style="color: #007bff; font-size: 1.0em;">MD5</a> ont √©t√© d√©couvertes, rendant l'algorithme non s√©curis√©, mais il est toujours largement utilis√© dans des situations o√π la s√©curit√© n'est pas une pr√©occupation principale.
                <br>
                <br>Le processus de calcul de MD5 comprend les √©tapes suivantes :
                </p>
                <ul>
                    <li><strong>Rembourrage :</strong> Initialement, les donn√©es originales sont rembourr√©es pour que leur longueur en octets soit un multiple de 512. Le rembourrage commence par un 1, suivi de 0 jusqu'√† ce que l'exigence de longueur soit satisfaite.</li>
                    <li><strong>Ajout de la longueur :</strong> Une valeur de longueur de 64 bits, qui est la repr√©sentation binaire de la longueur du message original, est ajout√©e au message rembourr√©, rendant la longueur finale du message un multiple de 512 bits.</li>
                    <li><strong>Initialisation du tampon MD :</strong> Quatre registres de 32 bits (A, B, C, D) sont initialis√©s pour stocker les valeurs de hachage interm√©diaires et finales.</li> 
                    <li><strong>Traitement des blocs de messages :</strong> Le message rembourr√© et trait√© en longueur est divis√© en blocs de 512 bits, et chaque bloc est trait√© √† travers quatre tours d'op√©ration. Chaque tour inclut 16 op√©rations similaires bas√©es sur des fonctions non lin√©aires (F, G, H, I), des op√©rations de d√©calage circulaire gauche et une addition modulo 32.</li> 
                    <li><strong>Sortie :</strong> La valeur de hachage finale est le contenu du dernier √©tat des quatre registres A, B, C, D concat√©n√©s ensemble (chaque registre est de 32 bits), formant une valeur de hachage de 128 bits.</li> 
                </ul>
                
                <h3>SHA-1 (Secure Hash Algorithm 1)</h3>
                <p>
                    SHA-1 a √©t√© con√ßu par la National Security Agency (NSA) des √âtats-Unis et publi√© comme Federal Information Processing Standard (FIPS PUB 180-1) par le National Institute of Standards and Technology (NIST) en 1995.
                    SHA-1 est destin√© √† √™tre utilis√© dans les signatures num√©riques et autres applications cryptographiques, g√©n√©rant une valeur de hachage de 160 bits (20 octets) connue sous le nom de message digest. Bien qu'il soit d√©sormais connu que <a href="https://fr.wikipedia.org/wiki/SHA-1" target="_blank" style="color: #007bff; font-size: 1.0em;">SHA-1</a> pr√©sente des vuln√©rabilit√©s de s√©curit√© et a √©t√© remplac√© par des algorithmes plus s√©curis√©s tels que SHA-256 et SHA-3,
                    comprendre son principe de fonctionnement conserve une valeur √©ducative et historique.
                <br>
                <br>Le but de la conception de SHA-1 est de prendre un message de longueur arbitraire et de produire un message digest de 160 bits pour v√©rifier l'int√©grit√© des donn√©es. Son processus de calcul peut √™tre divis√© en les √©tapes suivantes :
                </p>
                <ul>
                    <li><strong>Rembourrage :</strong> Initialement, le message original est rembourr√© pour que sa longueur (en bits) modulo 512 soit √©gale √† 448. Le rembourrage commence toujours par un bit "1", suivi de plusieurs bits "0", jusqu'√† ce que la condition de longueur ci-dessus soit remplie.</li>
                    <li><strong>Ajout de la longueur :</strong> Un bloc de 64 bits est ajout√© au message rembourr√©, repr√©sentant la longueur du message original (en bits), rendant la longueur finale du message un multiple de 512 bits.</li>
                    <li><strong>Initialisation du tampon :</strong> L'algorithme SHA-1 utilise un tampon de 160 bits, divis√© en cinq registres de 32 bits (A, B, C, D, E), pour stocker les valeurs de hachage interm√©diaires et finales. Ces registres sont initialis√©s √† des valeurs constantes sp√©cifiques au d√©but de l'algorithme.</li>
                    <li><strong>Traitement des blocs de messages :</strong> Le message pr√©-trait√© est divis√© en blocs de 512 bits. Pour chaque bloc, l'algorithme ex√©cute une boucle principale contenant 80 √©tapes similaires. Ces 80 √©tapes sont divis√©es en quatre tours, chacun avec 20 √©tapes. Chaque √©tape utilise une fonction non lin√©aire diff√©rente (F, G, H, I) et une constante (K). Ces fonctions sont con√ßues pour augmenter la complexit√© et la s√©curit√© des op√©rations. Dans ces √©tapes, l'algorithme utilise des op√©rations binaires (telles que ET, OU, XOR, NON) et une addition modulo 32, ainsi que des d√©calages circulaires gauche.</li>
                    <li><strong>Sortie :</strong> Apr√®s avoir trait√© tous les blocs, les valeurs accumul√©es dans les cinq registres sont concat√©n√©es pour former la valeur de hachage finale de 160 bits.</li>
                </ul>

                <h3>SHA-2 (Algorithme de Hachage S√©curis√© 2)</h3>
                <p>
                    SHA-2 est une famille de fonctions de hachage cryptographiques, comprenant plusieurs versions diff√©rentes, principalement constitu√©es de six variantes : SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 et SHA-512/256.
                    SHA-2 a √©t√© con√ßu par la National Security Agency (NSA) des √âtats-Unis et publi√© comme un Standard F√©d√©ral de Traitement de l'Information (FIPS) par le National Institute of Standards and Technology (NIST). Compar√© √† son pr√©d√©cesseur, SHA-1, SHA-2 offre une s√©curit√© renforc√©e, principalement refl√©t√©e dans des valeurs de hachage plus longues et une r√©sistance plus forte aux attaques par collision.
                <br>
                <br>Le fonctionnement de la famille <a href="https://fr.wikipedia.org/wiki/SHA-2" rel="noopener noreferrer" target="_blank" style="color: #007bff; font-size: 1.0em;">SHA-2</a> est similaire √† SHA-1 √† bien des √©gards mais offre une s√©curit√© plus √©lev√©e gr√¢ce √† l'utilisation de valeurs de hachage plus longues et une proc√©dure de traitement plus complexe. Voici les principales √©tapes de l'algorithme SHA-2 :
                </p>
                <ul>
                    <li><strong>Rembourrage :</strong> Le message d'entr√©e est d'abord rembourr√© pour rendre sa longueur, moins 64 bits, √©gale √† 448 ou 896 sur une base modulo 512 (pour SHA-224 et SHA-256) ou modulo 1024 (pour SHA-384 et SHA-512). La m√©thode de rembourrage est la m√™me que SHA-1, qui consiste √† ajouter un "1" √† la fin du message, suivi de plusieurs "0", et finalement une repr√©sentation binaire de 64 bits (pour SHA-224 et SHA-256) ou 128 bits (pour SHA-384 et SHA-512) de la longueur du message original en bits.</li>
                    <li><strong>Initialisation du Tampon :</strong> L'algorithme SHA-2 utilise un ensemble de valeurs de hachage initialis√©es comme tampon de d√©part, selon la variante SHA-2 choisie. Par exemple, SHA-256 utilise huit registres de 32 bits, tandis que SHA-512 utilise huit registres de 64 bits. Ces registres sont initialis√©s √† des valeurs constantes sp√©cifiques.</li>
                    <li><strong>Traitement des Blocs de Messages :</strong> Le message rembourr√© est divis√© en blocs de 512 bits ou 1024 bits, et chaque bloc subit plusieurs tours d'op√©rations cryptographiques. SHA-256 et SHA-224 effectuent 64 tours d'op√©rations, tandis que SHA-512, SHA-384, SHA-512/224 et SHA-512/256 effectuent 80 tours. Chaque tour d'op√©ration comprend une s√©rie d'op√©rations complexes en bits, incluant des op√©rations logiques, d'addition modulaire et conditionnelles, en s'appuyant sur diff√©rentes fonctions non lin√©aires et des constantes pr√©d√©finies. Ces op√©rations augmentent la complexit√© et la s√©curit√© de l'algorithme.</li>
                    <li><strong>Sortie :</strong> Finalement, apr√®s avoir trait√© tous les blocs, les valeurs dans le tampon sont combin√©es pour former la valeur de hachage finale. Selon la variante SHA-2, cette valeur de hachage peut √™tre de 224, 256, 384 ou 512 bits de longueur.</li>
                </ul>
                <P>
                    Vous pourriez √™tre curieux de savoir pourquoi l'entr√©e d'une fonction de hachage peut √™tre de longueur arbitraire, mais la sortie est fixe. La raison est que la famille SHA-2 utilise la transformation de Merkle-Damg√•rd, qui permet la construction de fonctions de hachage pouvant traiter des messages de n'importe quelle longueur √† partir d'une fonction de compression de longueur fixe. La transformation de Merkle-Damg√•rd est adopt√©e dans de nombreuses fonctions de hachage traditionnelles, y compris MD5 et SHA-1.
                </P>
                <p>
                    L'id√©e centrale de la transformation de Merkle-Damg√•rd est de diviser le message d'entr√©e en blocs de taille fixe, puis de traiter ces blocs un par un, chaque √©tape de traitement d√©pendant du r√©sultat de la pr√©c√©dente, pour produire finalement une valeur de hachage de taille fixe. L'√©tape de padding de SHA-256 incarne les principes de base de la transformation de Merkle-Damg√•rd, √† savoir en appliquant un padding appropri√© pour traiter des messages de toute longueur et en s'assurant que la longueur finale du message trait√© respecte certaines conditions (comme √™tre un multiple d'une longueur fixe). Ainsi, on peut dire que l'√©tape de padding de SHA-256 suit la m√©thode de transformation de Merkle-Damg√•rd.
                </p>
                <figure>
                    <img src="./images/Merkle-Damg√•rd Padding.jpg" alt="Principe de padding de Merkle-Damg√•rd">
                    <figcaption class="Merkle-Damg√•rd">Principe de padding de Merkle-Damg√•rd</figcaption>
                </figure>
                <p>
                    Cependant, SHA-256 n'est pas simplement une mise en ≈ìuvre directe de la transformation de Merkle-Damg√•rd. Il comprend √©galement une s√©rie d'√©tapes de calcul complexes (telles que l'expansion des messages, de multiples tours de fonctions de compression, etc.), qui sont des conceptions uniques de SHA-256, visant √† renforcer sa s√©curit√©. Par cons√©quent, bien que SHA-256 suive les principes de la transformation de Merkle-Damg√•rd dans son √©tape de padding, il renforce la s√©curit√© globale en introduisant d'autres m√©canismes de s√©curit√©, ce qui fait qu'il ne se limite pas uniquement au cadre de base de la transformation de Merkle-Damg√•rd.
                </p>
                
                <h3>SHA-3 (Secure Hash Algorithm 3)</h3>
                <p>
                    SHA-3 est le dernier standard de hachage s√©curis√©, officiellement approuv√© par le National Institute of Standards and Technology (NIST) en 2015 comme Federal Information Processing Standard (FIPS 202). SHA-3 n'est pas destin√© √† remplacer les pr√©c√©dents SHA-1 ou SHA-2 (car SHA-2 est toujours consid√©r√© comme s√ªr),
                    mais plut√¥t pour compl√©ter et offrir une option alternative au sein de la famille SHA, fournissant un algorithme de hachage cryptographique diff√©rent. SHA-3 est bas√© sur l'algorithme Keccak, con√ßu par Guido Bertoni et d'autres, et a √©t√© le gagnant du concours SHA-3 organis√© par le NIST en 2012.
                <br>
                <br>Le principe de fonctionnement de SHA-3 diff√®re consid√©rablement de celui de SHA-2, principalement parce qu'il utilise une m√©thode connue sous le nom de "construction √©ponge" pour absorber et presser les donn√©es, produisant la valeur de hachage finale. Cette m√©thode permet √† SHA-3 de fournir de mani√®re flexible des valeurs de hachage de diff√©rentes longueurs, offrant ainsi une gamme d'applications plus large que SHA-2. Voici les principales √©tapes de SHA-3 :
                </p>
                <figure>
                    <img src="./images/sponge construction.jpg" alt="Diagramme sch√©matique de la construction √©ponge">
                    <figcaption class="sponge">Diagramme sch√©matique de la construction √©ponge</figcaption>
                </figure>
                <h4>Phase d'absorption :</h4>
                <p>
                    Dans la phase d'absorption, la structure √©ponge divise d'abord les donn√©es d'entr√©e en blocs de taille fixe. Ces blocs de donn√©es sont s√©quentiellement "absorb√©s" dans l'√©tat interne de l'√©ponge, qui est g√©n√©ralement plus grand qu'un seul bloc de donn√©es, pour garantir qu'une grande quantit√© de donn√©es puisse √™tre trait√©e sans d√©bordement.
                    Plus pr√©cis√©ment, chaque bloc de donn√©es est fusionn√© avec une partie de l'√©tat interne d'une mani√®re ou d'une autre (comme par une op√©ration XOR), suivi de l'application d'une fonction de permutation fixe (dans SHA-3, il s'agit de <a href="https://en.wikipedia.org/wiki/SHA-3" target="_blank" style="color: #007bff; font-size: 1.0em;">Keccak-f</a> ) pour transformer l'ensemble de l'√©tat, emp√™chant ainsi l'interf√©rence entre diff√©rents blocs de donn√©es d'entr√©e. Ce processus est r√©p√©t√© jusqu'√† ce que tous les blocs de donn√©es d'entr√©e aient √©t√© trait√©s.
                </p>
                <p>
                    Keccak-f est la fonction de permutation principale utilis√©e dans l'algorithme de hachage cryptographique SHA-3. Il est un composant central de la famille d'algorithmes Keccak. SHA-3 est bas√© sur l'algorithme Keccak, qui a remport√© le concours d'algorithmes de hachage cryptographique organis√© par le NIST et a √©t√© s√©lectionn√© comme standard pour SHA-3. La fonction Keccak-f a plusieurs variantes, la plus couramment utilis√©e √©tant Keccak-f[1600], o√π le nombre indique la largeur de bit sur laquelle elle op√®re. 
                </p>
                <p>
                    Keccak-f est compos√© de plusieurs tours de la m√™me op√©ration (appel√©s rondes). Pour Keccak-f[1600], il y a un total de 24 tours d'op√©rations. Chaque tour comprend cinq √©tapes de base : <em>Œ∏ (Theta), œÅ (Rho), œÄ (Pi), œá (Chi) et Œπ (Iota)</em>. Ces √©tapes agissent ensemble sur le tableau d'√©tat, transformant progressivement son contenu,
                    augmentant la confusion et la diffusion pour renforcer la s√©curit√©. Voici une br√®ve description de ces √©tapes :
                </p>
                <ul>
                    <li><strong>√âtape Œ∏ (Theta) :</strong> Effectue des op√©rations XOR sur tous les bits de chaque colonne, puis XOR le r√©sultat sur les colonnes adjacentes, fournissant une diffusion entre les colonnes.</li>
                    <li><strong>√âtape œÅ (Rho) :</strong> Op√©ration de rotation au niveau des bits, o√π chaque bit est tourn√© d'un nombre diff√©rent de bits selon des r√®gles pr√©d√©termin√©es, augmentant la complexit√© des donn√©es.</li>
                    <li><strong>√âtape œÄ (Pi) :</strong> R√©organise les bits dans le tableau d'√©tat, changeant la position des bits pour atteindre une diffusion √† travers les rang√©es et les colonnes.</li>
                    <li><strong>√âtape œá (Chi) :</strong> Une √©tape non lin√©aire qui effectue des op√©rations XOR sur chaque bit de chaque rang√©e, y compris elle-m√™me, son voisin imm√©diat et le compl√©ment du voisin. C'est une op√©ration locale qui augmente les caract√©ristiques non lin√©aires de l'algorithme cryptographique.</li>
                    <li><strong>√âtape Œπ (Iota) :</strong> Introduit une constante de tour dans une partie du tableau d'√©tat, avec la constante diff√©rant √† chaque tour, pour √©viter que tous les tours ne fonctionnent de mani√®re identique, introduisant de l'impr√©visibilit√©.</li>
                </ul>
                <p>
                    Keccak-f offre un haut niveau de s√©curit√© gr√¢ce √† ces √©tapes. Sa conception garantit que m√™me de l√©gers changements dans l'entr√©e entra√Ænent des changements g√©n√©ralis√©s et impr√©visibles dans le tableau d'√©tat, r√©alis√©s gr√¢ce aux principes de confusion (rendant difficile pour les attaquants de d√©duire l'entr√©e √† partir de la sortie) et de diffusion (o√π de l√©gers changements dans l'entr√©e affectent plusieurs parties de la sortie).
                </p>
                
                <p>
                    La conception de Keccak-f permet d'ajuster les param√®tres (comme la taille de l'√©tat et le nombre de tours) √† diff√©rents niveaux de s√©curit√© et sc√©narios d'application, offrant une grande flexibilit√©. Keccak-f[1600] est r√©put√© pour son impl√©mentation efficace, atteignant des vitesses de traitement √©lev√©es √† la fois en mat√©riel et en logiciel, en particulier lors du traitement de grandes quantit√©s de donn√©es.
                </p>
                
                <h4>Phase de pressage :</h4>
                <p>
                    Une fois que tous les blocs de donn√©es d'entr√©e ont √©t√© absorb√©s dans l'√©tat interne, la structure √©ponge entre dans la phase de pressage. √Ä ce stade, des parties de l'√©tat interne sont progressivement sorties comme le r√©sultat de la fonction de hachage. Si la longueur de sortie requise d√©passe la quantit√© qui peut √™tre extraite √† la fois, la structure √©ponge applique la fonction de permutation pour transformer √† nouveau l'√©tat interne, puis continue √† sortir plus de donn√©es. Ce processus est poursuivi jusqu'√† ce que la longueur de sortie souhait√©e soit atteinte.
                </p>
                
                <p>
                    L'objectif de la conception de SHA-3 est de fournir une s√©curit√© sup√©rieure √† celle de SHA-2 et une meilleure r√©sistance contre les attaques informatiques quantiques. Gr√¢ce √† sa structure √©ponge unique, SHA-3 est th√©oriquement capable de r√©sister √† toutes les m√©thodes d'attaque cryptographiques actuellement connues, y compris les attaques par collision, les attaques par pr√©image et les attaques par seconde pr√©image.
                </p>
                
                <h3>RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest)</h3>
                <p>
                    RIPEMD-160 est une fonction de hachage cryptographique con√ßue pour fournir un algorithme de hachage s√©curis√©. Elle a √©t√© d√©velopp√©e en 1996 par Hans Dobbertin et d'autres, 
                    et elle fait partie de la famille RIPEMD (RACE Integrity Primitives Evaluation Message Digest).
                </p>
                <p>
                    RIPEMD-160 produit une valeur de hachage de 160 bits (20 octets), ce qui est √† l'origine du "160" dans son nom. Il est bas√© sur la conception du MD4 et influenc√© par d'autres algorithmes de hachage tels que MD5 et SHA-1. RIPEMD-160 comprend deux op√©rations parall√®les,
                    similaires qui traitent les donn√©es d'entr√©e s√©par√©ment puis combinent les r√©sultats de ces deux processus pour g√©n√©rer la valeur de hachage finale. Cette conception vise √† renforcer la s√©curit√©.
                <br>
                <br>Le processus de calcul de <a href="https://en.wikipedia.org/wiki/RIPEMD" target="_blank" style="color: #007bff; font-size: 1.0em;">RIPEMD-160</a> inclut plusieurs √©tapes de base : le bourrage, le traitement des blocs et la compression :
                </p>
                <ul>
                    <li><strong>Bourrage :</strong> Le message d'entr√©e est d'abord compl√©t√© pour que sa longueur modulo 512 bits soit √©gale √† 448 bits. Le bourrage commence toujours par un seul bit de 1 suivi d'une s√©rie de bits de 0, se terminant par une repr√©sentation sur 64 bits de la longueur du message original.</li>
                    <li><strong>Traitement des blocs :</strong> Le message compl√©t√© est divis√© en blocs de 512 bits.</li>
                    <li><strong>Initialisation :</strong> Il utilise cinq registres de 32 bits (A, B, C, D, E), qui sont initialis√©s √† certaines valeurs sp√©cifiques.</li>
                    <li><strong>Fonction de compression :</strong> Chaque bloc est trait√© √† son tour, mettant √† jour les valeurs de ces cinq registres par une s√©rie d'op√©rations complexes. Ce processus comprend des op√©rations binaires (telles que l'addition, ET, OU, NON, rotations circulaires √† gauche) et l'utilisation d'un ensemble de constantes fixes.</li>
                    <li><strong>Sortie :</strong> Apr√®s que tous les blocs ont √©t√© trait√©s, les valeurs de ces cinq registres sont concat√©n√©es pour former la valeur de hachage finale de 160 bits.</li>
                </ul>                
            </section>
        </article>
    </main>

    <footer class="footer">
        <div class="social-links">
            <a href="https://twitter.com/xinli_111219" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-twitter"></i>
            </a>
            <a href="https://www.youtube.com/@xinli-vj3js" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-youtube"></i>
            </a> 
        </div>
    
        <div class="info">
            <p>¬© 2024 chatcipher Tools. Tous droits r√©serv√©s.</p>
            <p>
                <a href="https://chatcipherai.com/fr/Privacy_Policy.html" title="Privacy Policy">Politique de confidentialit√©</a>
                |
                <a href="https://chatcipherai.com/fr/Terms_of_Use.html" title="Terms of Use">Conditions d'utilisation</a>
                |
                <a href="https://chatcipherai.com/fr/About_Us.html" title="About Us">√Ä Propos de Nous</a>
                |
                <a href="https://chatcipherai.com/fr/Disclaimer.html" title="Disclaimer">Clause de non-responsabilit√©</a>
            </p> 
            <button id="backToTop" onclick="scrollToTop()">Retour en Haut</button>
        </div>
    </footer>   

    <script>
        let shortcutsEnabled = true;
        function manageShortcuts(enable) {
            shortcutsEnabled = enable;
        }

        function handleKeyPress(event) {
            if (!shortcutsEnabled) {
                console.log('Shortcuts are disabled');
                return;
            }

            switch (event.key.toUpperCase()) {
                case 'A':
                    clearAll();
                    console.log('Clear All triggered');
                    break;
                case 'L':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('light-mode');
                        console.log('Light style activated');
                    }
                    break;
                case 'N':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('dark-mode');
                        console.log('Dark style activated');
                    }
                    break;
                case 'B':
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                    console.log('Scrolled to top');
                    break;
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Ensure all handlers are set up once the DOM is fully loaded
            document.addEventListener('keydown', handleKeyPress);

            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
            
            setupEventListeners(); // Setup other event listeners
            adjustButton();
        });

        let generatedTextHash = '';
        let generatedFileHash = '';

        async function generateHash() {
            const text = document.getElementById('textInput').value;
            document.getElementById('processOutput').textContent = text.length ? "Calcul de la valeur de hachage..." : '';
            const msgUint8 = new TextEncoder().encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('hashOutput').textContent = `Valeur de hachage (SHA-256): ${hashHex}`;
            generatedTextHash = hashHex;
            document.getElementById('processOutput').textContent = "";
        }

        async function generateFileHash() {
            const fileInput = document.getElementById('fileInput');
            if (!fileInput.files.length) {
                alert("Veuillez s√©lectionner un fichier.");
                return;
            }
            document.getElementById('fileHashOutput').textContent = "Calcul de la valeur de hachage du fichier...";
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('fileHashOutput').textContent = `Valeur de hachage (SHA-256): ${hashHex}`;
                generatedFileHash = hashHex;
            };
            reader.onerror = function () {
                alert("Erreur de lecture du fichier.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareTextHash() {
            const compareHash = document.getElementById('hashCompareInput').value;
            if (!generatedTextHash) {
                alert("Veuillez d'abord g√©n√©rer un hachage du texte.");
                return;
            }
            const resultText = generatedTextHash === compareHash ? "<strong>Conclusion¬†: </strong>Les hachages correspondent et les donn√©es n'ont pas √©t√© falsifi√©es." : "<strong>Conclusion¬†: </strong>Les hachages ne correspondent pas et les donn√©es peuvent avoir √©t√© falsifi√©es pendant le transport ou une erreur s'est produite lors du stockage.";
            document.getElementById('textCompareResult').innerHTML = resultText;
            document.getElementById('textCompareResult').style.color = generatedTextHash === compareHash ? "black" : "red";
        }

        async function compareFileHash() {
            const fileInput = document.getElementById('compareFileInput');
            if (!fileInput.files.length) {
                alert("Veuillez s√©lectionner un fichier √† comparer.");
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                document.getElementById('fileCompareResult').textContent = `Valeur de hachage (SHA-256): ${hashHex}`;

                if (generatedFileHash === hashHex) {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Conclusion¬†: </strong>Les hachages correspondent et les donn√©es n'ont pas √©t√© falsifi√©es.";
                    document.getElementById('fileCompareResult').style.color = "black";
                } else {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Conclusion¬†: </strong>Les hachages ne correspondent pas et les donn√©es peuvent avoir √©t√© falsifi√©es pendant le transport ou une erreur s'est produite lors du stockage.";
                    document.getElementById('fileCompareResult').style.color = "red";
                }
            };
            reader.onerror = function () {
                alert("Erreur de lecture du fichier.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareHashValues() {
            var hashValue1 = document.getElementById('hashInput1').value.trim();
            var hashValue2 = document.getElementById('hashInput2').value.trim();

            var resultDisplay = document.getElementById('hashComparisonResult');

            resultDisplay.style.fontWeight = 'bold';

            if (hashValue1 === "" || hashValue2 === "") {
                resultDisplay.textContent = 'Les deux valeurs de hachage doivent √™tre saisies.';
                resultDisplay.style.color = 'black';
            } else if (hashValue1 === hashValue2) {
                resultDisplay.textContent = 'Les valeurs de hachage correspondent !';
                resultDisplay.style.color = 'black';
            } else {
                resultDisplay.textContent = 'Les valeurs de hachage ne correspondent pas.';
                resultDisplay.style.color = 'red';
            }
        }

        function copyTextHash() {
            const hashValue = document.getElementById('hashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("√âchec de la copie du hachage du texte.");
                });
            }
        }

        function copyFileHash() {
            const hashValue = document.getElementById('fileHashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("√âchec de la copie du hachage du fichier.");
                });
            }
        }

        function clearAll() {
            document.getElementById('textInput').value = '';
            document.getElementById('hashOutput').textContent = '';
            document.getElementById('hashCompareInput').value = '';
            document.getElementById('textCompareResult').textContent = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('fileHashOutput').textContent = '';
            document.getElementById('compareFileInput').value = '';
            document.getElementById('fileCompareResult').textContent = '';
            document.getElementById('hashInput1').value = '';
            document.getElementById('hashInput2').value = '';
            document.getElementById('hashComparisonResult').textContent = '';
        }

        document.getElementById('menuIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar ul');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });

        document.getElementById('languageIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .langUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });

        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var menunavbarUl = document.querySelector('.navbar .menuUl');

            var languageIcon = document.getElementById('languageIcon');
            var langnavbarUl = document.querySelector('.navbar .langUl');

            if (!menuIcon.contains(event.target) && !menunavbarUl.contains(event.target)) {
                menunavbarUl.style.display = 'none';
            }
            if (!languageIcon.contains(event.target) && !langnavbarUl.contains(event.target)) {
                langnavbarUl.style.display = 'none';
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
        });

        document.getElementById('lightStyle').addEventListener('click', function () {
            setStyle('light-mode');
        });

        document.getElementById('darkStyle').addEventListener('click', function () {
            setStyle('dark-mode');
        });

        function setStyle(style) {
            document.body.className = style;
            localStorage.setItem('style', style);
            updateButtonStyles();
            updateNavbarStyles(style);
        }

        function updateNavbarStyles(style) {
            var navbar = document.querySelector('.navbar');
            var ul = navbar.querySelector('ul');
            navbar.style.backgroundColor = style === 'dark-mode' ? '#0A0F24' : '#FFFFFF';
            ul.style.backgroundColor = style === 'dark-mode' ? 'rgba(119, 136, 153, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            ul.style.color = style === 'dark-mode' ? '#FFFFFF' : '#0A0F24';
        }

        document.querySelectorAll('.learnMore').forEach(function (link) {
            link.addEventListener('click', function () {
                var targetId = this.getAttribute('data-target');
                var moreContent = document.getElementById(targetId);
                if (moreContent.style.display === "none" || moreContent.style.display === "") {
                    moreContent.style.display = "block";
                    this.textContent = "[Fermeture]";
                } else {
                    moreContent.style.display = "none";
                    this.textContent = "[En savoir plus]";
                }
            });
        });

        window.onscroll = function () { scrollFunction(); };
        function scrollFunction() {
            if (document.body.scrollTop > 10 || document.documentElement.scrollTop > 20) {
                document.getElementById("backToTop").style.display = "block";
            } else {
                document.getElementById("backToTop").style.display = "none";
            }
        }
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        document.addEventListener('DOMContentLoaded', function () {
            var navbar = document.querySelector('.navbar');
            window.onscroll = function () {
                if (window.scrollY > 50) {
                    navbar.classList.add('solid');
                } else {
                    navbar.classList.remove('solid');
                }
            };
        });

        function adjustButton() {
            var button = document.getElementById('backToTop');
            if (window.innerWidth < 768) {
                button.innerHTML = '‚ñ≤';
            } else {
                button.innerHTML = 'Retour en Haut(<span class="highlight-key">B</span>)';
            }
        }

        window.onload = adjustButton;
        window.onresize = adjustButton;

    </script>
</body>

</html>