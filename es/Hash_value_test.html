<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador Hash SHA-256: El escultor irreversible del mundo digital.</title>
    <meta name="keywords" content="cifrado, hash, datos, funciones de hash, valores de hash, funciones"/>
    <meta name="description"
        content="Forjando la huella digital √∫nica de la informaci√≥n con cifrado de 256 bits, protegiendo la integridad y autenticidad de los datos.">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="icon" type="image/jpg" href="./images/cipher.jpg">    
    <style>
        html {
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100vh;
            align-items: center;
            margin: 0;
            padding: 0 20px 20px 20px;
            background-color: #0A0F24;
            color: #FFFFFF;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(10, 15, 36, 0.0);
            transition: background-color 0.5s ease;
            z-index: 1000;
            height: 40px;
        }

        .navbar.solid {
            background-color: rgba(10, 15, 36, 1);
        }

        #menuIcon {
            cursor: pointer;
            transition: color 0.3s ease;
        }

        #menuIcon:hover {
            color: #a3a2a2;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            position: relative;
            left: -10px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        .navbar .langUl {
            left: 87px;
            width: 100px;
        }

        .navbar.active ul {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 35px;
            left: 10px;
            width: 15%;
            background-color: rgba(119, 136, 153, 0.8);
            padding: 10px 0;
        }

        .navbar.active ul li {
            margin-bottom: 1px;
        }

        .navbar.active ul li:last-child {
            margin-bottom: 0;
        }

        .navbar ul {
            display: none;
            flex-direction: column;
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: transparent;
            padding: 10px 0;
            list-style: none;
            margin: 0;
            width: 14%;
        }

        .navbar.active ul {
            display: flex;
        }

        .section.interactive-tool {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #bbbaba;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 1000px;
            margin-top: 30px;
            margin-bottom: 150px;
        }

        .sections-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 120px;
            margin-right: -10px;
        }

        .sections-container h2,
        .sections-container p {
            text-align: left;
            width: 80%;
        }

        p {
            margin-bottom: 30px;
            text-align: left;
            font-size: 1.2em;
            line-height: 1.6;
            margin-bottom: 15px;
            text-align: center; 
        }

        h2 {
            margin-bottom: 10px;
            font-size: 28px;
            margin-top: 50px;
        }

        h3 {
            margin-top: 50px;
            font-size: 22px;
        }

        h4 {
            font-size: 20px;
        }

        .sections-container h2:hover {
            color: #4bcfcf;
            transition: color 0.3s ease;
        }

        .navbar li a {
            color: white;
            padding: 5px;
            text-decoration: none;
            font-size: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            display: block;
            border-radius: 5px;
        }

        .navbar ul li {
            margin-bottom: 1px;
        }

        .navbar ul li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .navbar h1 {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 35px;
            margin-right: 0;
            font-size: 30px;
        }

        .navbar-dark {
            background-color: #0A0F24;
        }

        .morse-code-container {
            display: flex;
            align-items: center;
        }

        .morse-code-container .copy-button {
            margin-right: 5px;
            margin-left: 0;
        }

        button {
            cursor: pointer;
            margin: 10px;
            padding: 8px 15px;
            margin-left: 5px;
            background-color: #c0c0c0;
            border: none;
            border-radius: 5px;
            color: #FFFFFF;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #a8a8a8;
        }

        .style-selector {
            position: absolute;
            top: 0px;
            right: 50px;
            margin-top: 10px;
        }

        .style-selector button {
            background-color: #0a0f24;
            padding: 5px 10px;
            margin-right: 1px;
            color: #F5F5F5;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .style-selector button:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .dark-mode {
            background-color: #0A0F24;
            color: white;
        }

        .light-mode {
            background-color: white;
            color: #0A0F24;
        }

        .light-mode .navbar,
        .light-mode .container {
            background-color: #FFFFFF;
            color: #0A0F24;
        }

        .light-mode .navbar ul {
            background-color: transparent;
            color: #0A0F24;
        }

        .dark-mode .navbar ul li a:hover {
            color: #30eded;
        }

        .light-mode .navbar ul li:hover {
            color: #0A0F24;
            background-color: rgba(255, 255, 255, 1);
            border-radius: 5px;
        }

        .navbar {
            justify-content: flex-start;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            margin-left: 30px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        #languageSelect {
            padding: 5px 10px;
            margin-left: 10px;
            border-radius: 5px;
            border: none;
            background-color: #5f9ea0;
            color: white;
            cursor: pointer;
        }

        #languageSelect:hover {
            background-color: #2F4F4F;
        }

        .language-dropdown {
            width: 6%;
            display: none;
            list-style: none;
            padding: 10px 0;
            margin: 0;
            position: absolute;
            top: 40px;
            left: 100px;
            background-color: rgba(119, 136, 153, 0.8);
        }

        .language-dropdown li a {
            color: #FFFFFF;
            padding: 5px;
            margin: 1px;
            text-decoration: none;
            display: block;
            border-radius: 8px;
        }

        .language-dropdown li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .table-container {
            display: none;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .table-container.active {
            display: block;
        }

        .button-container {
            display: flex;
            justify-content: center;
            margin-right: 20px
        }

        .button-container button {
            margin-right: 30px;
        }

        .footer {
            position: relative;
            width: 100%;
            background-color: #0A0F24;
            color: #FFFFFF;
            text-align: center;
            padding: 10px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            margin-bottom: -20px;
        }

        .footer a {
            color: #F5F5F5;
            text-decoration: none;
            margin: 0 12px;
            transition: color 0.3s ease;
        }

        .footer a:hover {
            color: #a3a2a2;
        }

        .footer p {
            margin: 0;
            font-size: 16px;
        }

        .learnMore {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .moreContent {
            width: 80%;
            margin: auto;
            text-align: left;
            padding: 10px;
            display: none;
            margin-left: 0px;
        }

        .moreContent p {
            margin-bottom: 16px;
            font-size: 1.2em;
            line-height: 1.6;
            padding-bottom: 5px;
        }

        #moreContent1 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent1 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        #moreContent2 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent2 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        .clear-all-button {
            background-color: #47d7ff;
        }

        .clear-all-button:hover {
            background-color: #57f7ff;
        }

        figure {
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            text-align: center;
            width: 100%;
            margin: 0 auto;
        }

        img {
            max-width: 75%;
            height: auto;
            margin-left: -290px;
            margin-top: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
        }

        figcaption.workflow,
        figcaption.Irreversibility,
        figcaption.Resistance,
        figcaption.Merkle-Damg√•rd,
        figcaption.Compare,
        figcaption.sponge {
            width: 100%;
            margin-left: -300px;
            color: #007bff;
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 10px;
        }

        .navbar li {
            position: relative;
        }

        .navbar li>a {
            display: block;
        }

        .navbar .submenu {
            display: none;
            position: absolute;
            left: 101%;
            top: 0;
            background-color: transparent;
            border-radius: 5px;
            padding: 0;
            min-width: 150px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .navbar .submenu li {
            display: block;
            border-bottom: none;
            width: 110%;
        }

        .navbar .submenu li:last-child {
            border-bottom: none;
        }

        .navbar li:hover>.submenu {
            display: block;
        }

        .navbar .submenu a {
            color: #ffffff;
            padding: 5px;
            text-decoration: none;
            display: block;
            transition: background-color 0.3s ease;
        }

        .navbar .submenu a:hover {
            background-color: rgba(255, 255, 255, 0.206);
        }

        .input-group {
            display: flex;
            width: 80%;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 40px;
        }

        .input-group>div {
            flex: 1;
            margin-right: 20px;
        }

        .input-group>div:last-child {
            margin-right: 0;
        }

        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 10px 15px 10px 5px;
            border: 1px solid #eae6e6;
            border-radius: 5px;
            box-sizing: border-box;
        }

        button,
        input[type="submit"],
        input[type="file"]::file-selector-button {
            background-color: #0a0f24;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s;
        }

        button:hover,
        input[type="submit"]:hover,
        input[type="file"]::file-selector-button:hover {
            background-color: #c0c0c0;
            color: #0A0F24;
        }

        .compare-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        input[type="file"] {
            display: block;
        }

        .outPut {
            width: 100%;
            white-space: normal;
            word-break: break-all;
        }

        #backToTop {
            position: absolute;
            bottom: 5px;
            right: 30px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #0a0f24;
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
            display: block;
        }

        #backToTop:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .introduce {
            margin-left: 220px;
        }

        .introduce li {
            font-size: 17px;
            line-height: 1.5;
            word-wrap: break-word;
            width: 80%;
            padding-bottom: 10px; 
        }

        .language-list{
            float: right;
        }
        .language-list a{
            margin-left: 20px;
            color: white;
        }

        .language-list a:hover{
            color: #4bcfcf;
        }

        .language-list a {
            text-decoration: none;
        }

        .attention {
            margin-top: 20px;
            font-size: 0.8em;
        }

        .highlight-key { 
            font-weight: 800;
        }

        .support-links {
            flex: 1;
            text-align: left;
            margin-left: 50px;
            margin-bottom: -50px;
            margin-top: -32px;
        }

        .support-links h3 {
            font-size: 18px;
            color: white;
        }

        .support-links ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .support-links li {
            margin-bottom: 5px;
        }

        .support-links a {
            color: white;
            text-decoration: none;
        }

        .support-links a:hover {
            text-decoration: underline;
        }

        @media screen and (max-width: 768px) {
            .navbar h1 {
                font-size: 18px;
                position: absolute;
                top: -25px;
            }

            .sections-container {
                margin-left: auto;
                margin-right: auto;
                align-items: center;
                width: 100%;
            }

            .sections-container h2 {
                font-size: 1.2em;
            }

            .sections-container p {
                font-size: 0.9em;
            }
            
            .introduce {
                width: 100%;
                padding: 10px;
                margin-left: 90px;
            }

            .introduce h2 {
                font-size: 1.2em; 
            }

            h3 {
                font-size: 0.9em; 
            }

            h4 {
                font-size: 0.8em; 
            }

            .introduce p {
                font-size: 0.9em; 
            }

            .introduce li {
                font-size: 14px;
                margin-left: -20px;
            }

            figure {
                display: flex;
                flex-direction: column;
                align-items: center; 
                justify-content: center; 
                text-align: center;
                width: 100%;
                margin: 0 auto;
            }

            img {
                max-width: 80%;
                height: auto;
                margin-left: -90px;
                margin-top: 20px;
            }

            figcaption.workflow,
            figcaption.Irreversibility,
            figcaption.Resistance,
            figcaption.Merkle-Damg√•rd,
            figcaption.Compare,
            figcaption.sponge {
                width: 100%;
                margin-left: -100px;
                color: #007bff;
                font-size: 0.8em;
                font-weight: bold;
                margin-top: 10px;
            }

            .footer p {
                margin: 0;
                font-size: 10px;
            }

            pre {
                display: none;
            }

            #backToTop {
                content: '‚ñ≤';
                padding: 4px 5px;
                font-size: 14px;
                right: 10px;
                bottom: 0px;
            }
   
            .input-group {
                flex-direction: column;
                
            }

            .section.interactive-tool {
                width: 320px;
            }
            .navbar ul {
                width: 30%;
            }

            .navbar ul li {
                padding: 0 5px 0 0;
            }

            .navbar li a {
                padding: 5px;
            }

            .navbar li a {
                font-size: 10px;
                width: 100%;
                padding: 5px 0px 5px 5px;
            }

            .navbar .submenu {
                left: 100%;
            }

            .navbar .submenu li {
                display: block;
                border-bottom: none;
                width: 55%;
                padding: 0 5px 0 0;
            }

            .navbar .submenu li a {
                padding: 5px 0px 5px 5px;
            }

            #menuIcon {
                font-size: 0; /* Hide text */
            }
            #menuIcon::before {
                content: '\2630'; /* Unicode character for ‚ò∞ */
                font-size: 16px; /* Or any other size you prefer */
            }

            #languageIcon {
                font-size: 0;
            }

            #languageIcon::before {
                content: '\2637'; /* Unicode character for ‚ò∞ */
                font-size: 16px; /* Or any other size you prefer */
            }

            .navbar .langUl {
                left: 42px;
                width: 65px;
            }

            #darkStyle {
                font-size: 0;
                margin-left: 10px;
                padding: 5px 8px;
            }

            #lightStyle {
                font-size: 0;
                margin-right: -10px;
            }

            #darkStyle::before {
                font-size: 9px;
            }

            #lightStyle::before {
                font-size: 10px;
            }

            #darkStyle::before {
                content: "üåô";
            }

            #lightStyle::before {
                content: "‚òÄ";
            }

            #hashCompareInput {
                width: 240px;
            }

            .social-links i {
                font-size: 12px;
            }

            .attention {
                margin-top: 10px;
                font-size: 0.5em;
            }

            .support-links {
                flex: 1;
                text-align: left;
                margin-left: 0;
                margin-bottom: -50px;
                font-size: 10px;
            }

            .support-links h3 {
                font-size: 10px;
            }
        }
    </style>
</head>

<body class="dark-mode">
    <header>
        <nav class="navbar">
            <div id="menuIcon">&#9776; men√∫</div>
            <div id="menuItems"></div>
            <ul class="menuUl">
                <li>
                    <a href="https://chatcipherai.com/es/chatcipherai.html"><strong>Mundo de Criptosistemas</strong></a>
                    <ul class="submenu">
                        <li><a href="https://chatcipherai.com/es/Caesar_Cipher.html"><strong>Cifrado C√©sar</strong></a></li>
                        <li><a href="https://chatcipherai.com/es/Playfair_Cipher.html"><strong>Cifrado Playfair</strong></a></li>
                        <li><a href="https://chatcipherai.com/es/Four_Square_Cipher.html"><strong>El Cifrado Cuadrado</strong></a></li>
                        <li><a href="https://chatcipherai.com/es/Hill_Cipher.html"><strong>Cifrado Hill</strong></a></li>  
                    </ul>
                </li>
                <li><a href="https://chatcipherai.com/es/Hash_value_test.html"><strong>Prueba de Valor de Hash</strong></a></li>
                <li><a href="https://chatcipherai.com/es/Morsecode_main.html"><strong>Traductor de C√≥digo Morse</strong></a></li>
                <li><a href="https://chatcipherai.com/es/Shortcut_Key_Description.html"><strong>Descripci√≥n de Teclas de Acceso Directo</strong></a></li>
            </ul>

            <div id="languageIcon">&#x2637; idioma</div>
            <div id="languageItems">
                <ul class="langUl">
                    <li><a href="https://chatcipherai.com/en/Hash_value_test.html" title="English">English</a></li>
                    <li><a href="https://chatcipherai.com/fr/Hash_value_test.html" title="Fran√ßais">Fran√ßais</a></li>
                    <li><a href="https://chatcipherai.com/es/Hash_value_test.html" title="Espa√±ol">Espa√±ol</a></li>
                    <li><a href="https://chatcipherai.com/zh-CN/Hash_value_test.html" title="‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ">‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ</a></li>
                    <li><a href="https://chatcipherai.com/zh-TW/Hash_value_test.html" title="‰∏≠ÊñáÔºàÁπÅ‰ΩìÔºâ">‰∏≠ÊñáÔºàÁπÅ‰ΩìÔºâ</a></li>
                    <li><a href="https://chatcipherai.com/ar/Hash_value_test.html" title="ÿßŸÑÿπÿ±ÿ®Ÿäÿ©">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</a></li>
                    <li><a href="https://chatcipherai.com/ru/Hash_value_test.html" title="–†—É—Å—Å–∫–∏–π">–†—É—Å—Å–∫–∏–π</a></li>
                    <li><a href="https://chatcipherai.com/pt/Hash_value_test.html" title="Portugu√™s">Portugu√™s</a></li>
                    <li><a href="https://chatcipherai.com/de/Hash_value_test.html" title="Deutsch">Deutsch</a></li>
                    <li><a href="https://chatcipherai.com/hi/Hash_value_test.html" title="‡§π‡§ø‡§®‡•ç‡§¶‡•Ä">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</a></li>
                    <li><a href="https://chatcipherai.com/nl/Hash_value_test.html" title="Nederlands">Nederlands</a></li>
                </ul> 
            </div>

            <h1>Explorador Hash SHA-256</h1>
            <div class="style-selector">  
                <button id="darkStyle">üåô Estilo Oscuro(<span class="highlight-key">N</span>)</button> 
                <button id="lightStyle">‚òÄ Estilo Claro(<span class="highlight-key">L</span>)</button> 
            </div>
        </nav>
    </header>

    <main class="sections-container">
        <section class="section interactive-tool">
            <h2>Prueba de Valor Hash</h2>
            <p>Introduce texto para ver el proceso de conversi√≥n a un valor hash en tiempo real,
                <br>
                o selecciona un archivo para calcular el valor hash del archivo.
            </p>
        
            <div class="input-group">
                <div>
                    <p>Generar Valor Hash de Texto</p>
                    <input type="text" class="input_value" id="textInput" placeholder="Introduce texto" oninput="generateHash()" />
                    <button onclick="copyTextHash()">Copiar hash de texto</button>
                    <div id="processOutput"></div>
                    <div id="hashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Comparar Valor Hash de Texto</p>
                    <input type="text" class="input_value" id="hashCompareInput"
                        placeholder="Introduce el valor hash para comparar" />
                    <button onclick="compareTextHash()">Comparar</button>
                    <div id="textCompareResult"></div>
                </div>
            </div>
        
            <div class="input-group">
                <div>
                    <p>Generar Valor Hash de Archivo</p>
                    <input type="file" id="fileInput" onchange="generateFileHash()" />
                    <button onclick="copyFileHash()">Copiar hash de archivo</button>
                    <div id="fileHashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Comparar Valor Hash de Archivo</p>
                    <input type="file" id="compareFileInput" onchange="compareFileHash()" />
                    <div id="fileCompareResult" class="outPut"></div>
                </div>
            </div>

            <div class="input-group">
                <div>
                    <p>Ingrese el valor hash 1</p>
                    <input type="text" class="input_value" id="hashInput1" placeholder="Introduzca el valor hash 1" />
                </div>
                <div>
                    <p>Ingrese el valor hash 2</p>
                    <input type="text" class="input_value" id="hashInput2" placeholder="Introduzca el valor hash 2" />
                    <button onclick="compareHashValues()">Comparar</button>
                    <div id="hashComparisonResult" class="outPut"></div>
                </div>
            </div>
            
            <button id="clearAllButton" class="clear-all-button" onclick="clearAll()">Limpiar Todo(<span class="highlight-key">A</span>)</button>
            <div class="attention">
                Recordatorio amable: Antes de introducir dato, por favor verifique cuidadosamente la exactitud y sensibilidad de la informaci√≥n. Recomendamos que suba con precauci√≥n los datos importantes, ya que esto ayuda a proteger mejor su privacidad y seguridad.
            </div>
        </section>
        
        <section class="introduce">
            <p><strong><em>"En la era digital de hoy, la seguridad de los datos no solo es la piedra angular para proteger la privacidad personal y los secretos corporativos, sino tambi√©n la clave para mantener la confianza social y la estabilidad econ√≥mica."</em></strong></p>
            <div>
                <h2>¬øQu√© es un Valor Hash?</h2>
                <p>
                    Un valor hash es una cadena o n√∫mero de tama√±o fijo generado a partir de cualquier tama√±o de datos de entrada mediante una funci√≥n hash. 
                    Estas funciones aceptan entradas diversas como texto, im√°genes y videos, produciendo un valor hash fijo e irreversible. 
                    Los valores hash son deterministas, lo que significa que entradas id√©nticas siempre resultan en la misma salida. Tambi√©n presentan resistencia a colisiones, 
                    lo que dificulta encontrar entradas distintas que produzcan la misma salida.
                </p>
            </div>
            
            <div>
                <h2>Funciones del Valor Hash</h2>
                <p>
                    Los valores hash desempe√±an roles esenciales en inform√°tica y TI, ofreciendo un resumen de longitud fija de los datos independientemente de su tama√±o. Estas funciones facilitan diversas aplicaciones:
                </p>
                <ul>
                    <li><strong>Verificaci√≥n de Integridad de Datos:</strong> Se utiliza para verificar si los datos permanecen sin modificaciones durante la transmisi√≥n, asegurando la integridad de los archivos descargados.</li>
                    <li><strong>Almacenamiento de Contrase√±as:</strong> Las contrase√±as se almacenan como valores hash por seguridad, lo que dificulta recuperar las contrase√±as originales de bases de datos comprometidas.</li>
                    <li><strong>Recuperaci√≥n R√°pida de Datos:</strong> Los valores hash act√∫an como √≠ndices en tablas hash, permitiendo operaciones de datos eficientes.</li>
                    <li><strong>Deduplicaci√≥n de Datos:</strong> Ayuda a identificar y eliminar elementos de datos duplicados comparando valores hash.</li>
                    <li><strong>Firma Digital y Verificaci√≥n:</strong> Asegura la integridad de los datos y el origen mediante criptograf√≠a de clave p√∫blica y funciones hash.</li>
                    <li><strong>Tecnolog√≠a Blockchain:</strong> Utiliza valores hash para asegurar los registros de transacciones y garantizar la inmutabilidad de los datos.</li>
                    <li><strong>Marcas de Tiempo a Prueba de Manipulaciones:</strong> Proporciona una marca de tiempo irreversible para los datos, √∫til en protecciones legales y de derechos de autor.</li>
                </ul>
                <p>
                    La raz√≥n por la que los valores hash son efectivos en estas √°reas se debe a sus caracter√≠sticas clave de rapidez, determinismo, irreversibilidad y resistencia a colisiones. Utilizadas correctamente, las funciones hash pueden proporcionar un soporte robusto en la seguridad de los datos, 
                    mejorar la eficiencia y verificar la autenticidad de la informaci√≥n.
                </p>
            </div>
            
            <div>
                <h2>¬øQu√© es una Funci√≥n Hash?</h2>
                <p>Una funci√≥n hash es una construcci√≥n matem√°tica que mapea datos de entrada (o "mensaje") a una cadena de tama√±o fijo, t√≠picamente un valor num√©rico, como se ilustra en el diagrama a continuaci√≥n. Ampliamente utilizada en la gesti√≥n de datos y la seguridad de la informaci√≥n, 
                    una funci√≥n hash se caracteriza por su eficiente rendimiento computacional, longitud de salida consistente, irreversibilidad, sensibilidad a las variaciones de entrada y resistencia a colisiones.
                </p>
                <figure>
                    <img src="./images/Hash input output.jpg" alt="Diagrama de flujo de trabajo de la funci√≥n hash" />
                    <figcaption class="workflow">Diagrama de flujo de trabajo de la funci√≥n hash</figcaption>
                </figure>
            </div>            

            <div>
                <h3>Rendimiento Computacional Eficiente</h3>
                <p>
                    Las funciones hash pueden calcular r√°pidamente valores hash a partir de datos de cualquier forma, independientemente del tama√±o de los datos. Esta caracter√≠stica es crucial para aplicaciones que requieren acceso r√°pido a datos, como las tablas hash. 
                    Esto se debe a que, al almacenar datos en tablas hash, la velocidad de la funci√≥n hash determina la velocidad de recuperaci√≥n de datos. Las tablas hash utilizan funciones hash para localizar r√°pidamente el lugar de almacenamiento de los datos, confiando en la r√°pida capacidad computacional de las funciones hash.
                </p>
                <p>
                    Adem√°s, en sistemas que necesitan procesar grandes cantidades de datos, la eficiencia de las funciones hash impacta directamente en el rendimiento general del sistema. Si una funci√≥n hash funciona lentamente, se convertir√° en un cuello de botella en el rendimiento del sistema. Algunos sistemas en tiempo real, 
                    como el filtrado de paquetes en dispositivos de red, requieren el c√°lculo inmediato de valores hash para los datos para tomar decisiones r√°pidas. En estos casos, la eficiencia de las funciones hash es igualmente crucial.
                </p>
                <p>
                    Por ejemplo, considere una plataforma de comercio electr√≥nico en l√≠nea donde los usuarios pueden ingresar nombres de productos en la barra de b√∫squeda para encontrar productos. El sistema backend puede usar funciones hash para localizar r√°pidamente la informaci√≥n del producto almacenada en tablas hash. 
                    Si el proceso de c√°lculo de la funci√≥n hash es lento, la experiencia del usuario se ver√° gravemente afectada, ya que tendr√°n que esperar m√°s tiempo para obtener resultados de b√∫squeda. En esta situaci√≥n, el rendimiento computacional eficiente de las funciones hash garantiza tiempos de respuesta r√°pidos, mejorando as√≠ la experiencia del usuario.
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent1">[Aprender M√°s]</a>
                </p>
            </div>
            
            <div id="moreContent1" class="moreContent" style="display:none;" style="color: #007bff; font-size: 1.0em;">
                <p>Las razones por las cuales las funciones hash pueden mejorar la eficiencia computacional se deben principalmente a las siguientes caracter√≠sticas de dise√±o:</p>
                <ul>
                    <li><strong>Operaciones Simples:</strong> Las funciones hash t√≠picamente usan operaciones matem√°ticas y de bits simples, que se ejecutan muy r√°pidamente debido al soporte directo del hardware de la CPU.</li>
                    <li><strong>Evitar Dependencias de Bucles:</strong> Al evitar dependencias de bucles, las funciones hash permiten un procesamiento en cadena, aumentando as√≠ la velocidad.</li>
                    <li><strong>Procesamiento Paralelo:</strong> Las funciones hash modernas est√°n dise√±adas para el procesamiento paralelo, mejorando la eficiencia en procesadores multin√∫cleo.</li>
                    <li><strong>Tama√±o de Salida Fijo:</strong> La salida de longitud fija simplifica la asignaci√≥n de memoria y la comparaci√≥n de datos, mejorando el modelo de programaci√≥n y la eficiencia.</li>
                    <li><strong>Pre-procesamiento y Post-procesamiento:</strong> Las funciones hash pueden manejar grandes datos dividi√©ndolos en bloques, calculando valores hash por separado y luego combin√°ndolos, lo que mejora la eficiencia.</li>
                    <li><strong>Optimizaci√≥n de Rutas Algor√≠tmicas:</strong> Reducir las bifurcaciones durante la ejecuci√≥n aumenta la precisi√≥n de la predicci√≥n de instrucciones en las CPU, aumentando as√≠ la velocidad.</li>
                    <li><strong>Afinidad con la Cach√©:</strong> Dise√±ar funciones hash para minimizar fallos de cach√© aumenta significativamente la velocidad de procesamiento.</li>
                    <li><strong>Optimizaci√≥n de Hardware:</strong> Los aceleradores de hardware dedicados pueden aumentar significativamente la velocidad de los c√°lculos hash, especialmente para funciones hash criptogr√°ficas como la serie SHA.</li>
                    <li><strong>Ausencia de Estado:</strong> Las funciones hash no retienen informaci√≥n de estado, permitiendo un procesamiento ligero de cada nueva entrada.</li>
                    <li><strong>Universalidad:</strong> Las funciones hash son universales para todo tipo de datos de entrada, eliminando la necesidad de algoritmos personalizados para diferentes tipos de datos.</li>
                </ul>
            </div>
            
            <div>
                <h3>Consistencia en la Longitud de Salida en Funciones Hash</h3>
                <p>
                    Las funciones hash convierten la entrada de cualquier longitud en una salida de longitud fija a trav√©s de una serie compleja de c√°lculos. Este proceso a menudo implica dividir los datos de entrada en bloques de tama√±o fijo (para aquellas entradas que exceden el tama√±o de la unidad de procesamiento),
                    aplicando una serie de operaciones matem√°ticas y l√≥gicas a cada bloque, y luego combinando o acumulando los resultados de estas operaciones de alguna manera para producir finalmente un valor hash de tama√±o fijo.
                </p>
                <p>
                    <strong>¬øPor qu√© es importante?</strong>
                    La consistencia de la longitud de salida ayuda a garantizar la seguridad de las funciones hash. Si la longitud de la salida del hash pudiera variar, podr√≠a filtrar informaci√≥n sobre el tama√±o de los datos originales, lo cual podr√≠a ser explotado potencialmente para atacar el sistema en algunos escenarios.
                    Adem√°s, una longitud de salida fija tambi√©n dificulta que los atacantes infieran caracter√≠sticas de los datos de entrada al analizar la longitud de la salida. Al mismo tiempo, las salidas de longitud fija simplifican el almacenamiento y la comparaci√≥n de valores hash.
                    Los dise√±adores de sistemas pueden saber de antemano cu√°nto espacio ocupar√° cada valor hash, lo cual es muy importante para escenarios como el dise√±o de bases de datos y la transmisi√≥n de red. Adem√°s, la consistencia de la longitud de salida se vuelve muy eficiente para comparar si los valores hash son iguales porque solo requiere comparar datos de una longitud fija.
                    Esto es particularmente importante cuando se utilizan tablas hash para la r√°pida recuperaci√≥n de datos.
                </p>
                <p>
                    Tomando SHA-256 como ejemplo, esta funci√≥n hash criptogr√°fica ampliamente utilizada siempre produce un valor hash de 256 bits (es decir, 32 bytes), independientemente de si los datos de entrada son un solo byte o varios millones de bytes. Esta consistencia asegura que los valores hash SHA-256 se puedan utilizar para diversas aplicaciones de seguridad,
                    como firmas digitales y C√≥digos de Autenticaci√≥n de Mensajes (MAC), mientras simplifica el flujo de trabajo de procesamiento y almacenamiento de datos.
                </p>
            </div>            

            <div>
                <h3>Irreversibilidad de las Funciones Hash</h3>
                <p>
                    Las funciones hash son unidireccionales, lo que significa que es imposible inferir los datos originales a partir del valor hash. Esta caracter√≠stica es particularmente importante al almacenar contrase√±as, ya que incluso si la base de datos se ve comprometida, los atacantes no pueden recuperar las contrase√±as a partir de los valores hash.
                    La irreversibilidad de las funciones hash se basa principalmente en los siguientes principios y caracter√≠sticas:
                </p>
                <ul>
                    <li><strong>Compresi√≥n:</strong> Las funciones hash pueden mapear entradas de cualquier longitud (que pueden ser muy grandes en uso pr√°ctico) a una salida de longitud fija. Esto significa que hay infinitamente muchas entradas posibles mapeadas a un n√∫mero finito de salidas. Dado que el espacio de salida (valores hash) es mucho menor que el espacio de entrada, diferentes entradas producir√°n inevitablemente la misma salida, un fen√≥meno conocido como "colisi√≥n". Debido a esta compresi√≥n, es imposible determinar la entrada espec√≠fica a partir de una salida dada (valor hash).</li>
                    <li><strong>Alta no linealidad y complejidad:</strong> Las funciones hash est√°n dise√±adas utilizando operaciones matem√°ticas y l√≥gicas complejas (como operaciones a nivel de bits, operaciones de m√≥dulo, etc.) para asegurar que la salida sea altamente sensible a la entrada. Incluso cambios menores en la entrada (por ejemplo, cambiar un bit) pueden provocar cambios significativos e impredecibles en la salida (valor hash). Este alto grado de no linealidad y la aleatoriedad de la salida hacen extremadamente dif√≠cil deducir la entrada original a partir del valor hash.</li>
                    <li><strong>Unidireccionalidad:</strong> El dise√±o de las funciones hash asegura que su operaci√≥n sea unidireccional; es decir, mientras que calcular el valor hash es f√°cil, el proceso inverso (recuperar los datos originales a partir del valor hash) no es factible. Esto se debe a que el proceso de c√°lculo de las funciones hash implica una serie de operaciones irreversibles (como la irreversibilidad de las operaciones de m√≥dulo), asegurando que incluso con el valor hash, es imposible reconstruir los datos originales.</li>
                    <li><strong>Mapeo aleatorio:</strong> Una funci√≥n hash ideal deber√≠a actuar como un "mapeador aleatorio", lo que significa que cada entrada posible tiene la misma probabilidad de ser mapeada a cualquier punto en el espacio de salida. Esta propiedad asegura que no hay una manera factible de predecir a qu√© salida se mapear√° una entrada espec√≠fica, mejorando la irreversibilidad de la funci√≥n hash.</li>
                    <li><strong>Base matem√°tica:</strong> Matem√°ticamente, la irreversibilidad de las funciones hash se puede entender a trav√©s de su dependencia en "problemas de logaritmo discreto", "problemas de factorizaci√≥n de enteros grandes" u otros problemas de teor√≠a de n√∫meros que son dif√≠ciles de resolver con las capacidades matem√°ticas y computacionales actuales. Por ejemplo, el dise√±o de algunos algoritmos hash puede depender indirectamente de la dificultad computacional de estos problemas, asegurando as√≠ su irreversibilidad.</li>
                </ul>
                <figure>
                    <img src="./images/Irreversibility.jpg" alt="Irreversibilidad de las funciones hash" />
                    <figcaption class="Irreversibility">Irreversibilidad de las funciones hash</figcaption>
                </figure>
            </div>

            <div>
                <h3>Sensibilidad de Entrada y el Efecto Avalancha</h3>
                <p>
                    En el dise√±o de las funciones hash, se utilizan operaciones matem√°ticas y l√≥gicas complejas (como operaciones a nivel de bits, operaciones m√≥dulo, etc.) para asegurar que la salida sea altamente sensible a la entrada.
                    Incluso cambios menores en la entrada (por ejemplo, cambiar un solo bit) resultar√°n en cambios significativos e impredecibles en la salida (el valor hash), un fen√≥meno conocido como el "efecto avalancha".
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent2">[Aprender M√°s]</a>
                </p>
            </div>

            <div id="moreContent2" class="moreContent" style="display:none;">
                <p>El <a href="https://en.wikipedia.org/wiki/Avalanche_effect" target="_blank" rel="noopener noreferrer" style="color: #007bff; font-size: 1.0em;">efecto avalancha</a> puede tener diferentes interpretaciones en varios campos:</p>
                <ul>
                    <li><strong>En criptograf√≠a:</strong> El efecto avalancha es una propiedad deseable de los algoritmos de cifrado (especialmente cifrados de bloque y funciones hash criptogr√°ficas). Ocurre cuando el cambio m√°s leve en la entrada (por ejemplo, cambiar un bit binario) conduce a cambios indistinguibles en la salida (con una probabilidad del 50% de cambiar cada bit binario en la salida). Este atributo ayuda a mejorar la seguridad del cifrado porque cambios significativos en la salida pueden ocurrir incluso con solo cambios menores en la entrada, haciendo m√°s dif√≠cil descifrar el cifrado analizando la relaci√≥n entre entrada y salida.</li>
                    <li><strong>En negocios y tecnolog√≠a:</strong> El efecto avalancha se refiere al fen√≥meno donde se puede liberar energ√≠a significativa al desmantelar y recombinar adecuadamente la estructura y el sistema inherentes en negocios y tecnolog√≠a. Esta energ√≠a puede destruir sistemas industriales antiguos como una avalancha, o incluso hacer desaparecer una industria entera. Bajo la inmensa presi√≥n de la avalancha, la conexi√≥n inherente entre negocios y tecnolog√≠a se interrumpe completamente, lo que requiere la aceptaci√≥n de nuevas transformaciones e integraciones. Este efecto finalmente desencadena una serie de innovaciones revolucionarias.</li>
                    <li><strong>En arquitectura de microservicios:</strong> El efecto avalancha describe el escenario donde, debido a las dependencias entre servicios, un fallo o indisponibilidad en un servicio puede propagarse a trav√©s de la cadena de llamadas, llevando a la par√°lisis del sistema entero. Las causas del efecto avalancha pueden incluir fallos de hardware, aumentos de tr√°fico, penetraci√≥n de cach√©, errores de programa, y paradas de JVM, entre otros.</li>
                    <li><strong>En el mundo natural:</strong> El efecto avalancha se refiere al fen√≥meno donde una peque√±a piedra que rueda por una monta√±a nevada puede desencadenar una avalancha. Esto se debe a que el impacto de la peque√±a piedra hace que las capas de nieve circundantes se aflojen y deslicen, llevando a una avalancha de mayor escala. Este fen√≥meno tambi√©n puede describir metaf√≥ricamente c√≥mo eventos o factores menores pueden desencadenar reacciones en cadena masivas.</li>
                </ul>
            </div>

            <div>
                <h3>Resistencia a Colisiones en Criptograf√≠a</h3>
                <p>
                    La resistencia a colisiones de una funci√≥n hash es un concepto crucial en criptograf√≠a, indicando el nivel de seguridad de una funci√≥n hash contra ataques de colisi√≥n. Esta propiedad implica que para cualquier funci√≥n hash <strong>H</strong>, encontrar dos entradas distintas <strong>x</strong> y <strong>y</strong> (<strong>x ‚â† y</strong>) tales que <strong>H(x) = H(y)</strong> es computacionalmente inviable. Una funci√≥n hash con una resistencia a colisiones robusta hace que sea extremadamente desafiante encontrar dos entradas diferentes que conduzcan al mismo valor de salida.
                </p>
                <figure>
                    <img src="./images/Collision Resistance.jpg" alt="Ilustraci√≥n de la resistencia a colisiones">
                    <figcaption class="Resistance">Ilustraci√≥n de la resistencia a colisiones</figcaption>
                </figure>
                <p>
                    La resistencia a colisiones juega un papel vital en el mantenimiento de la integridad de los datos y la verificaci√≥n. Al transformar la informaci√≥n de entrada en una salida de tama√±o fijo (o resumen), las funciones hash aseguran que no dos entradas diferentes produzcan la misma salida. Esta caracter√≠stica √∫nica permite que el valor hash identifique con precisi√≥n el valor original.
                </p>
                <p>
                    Durante la creaci√≥n o almacenamiento de datos, se genera un valor hash (o resumen) utilizando una funci√≥n hash. Este valor se almacena o transmite junto con los datos originales. Por ejemplo, los sitios de descarga de software a menudo muestran valores hash de archivos para la verificaci√≥n de integridad. Los destinatarios pueden recalcular de forma independiente el valor hash de los datos recibidos para confirmar su integridad. Si los valores hash originales y recalculados coinciden, se verifica la integridad de los datos. Si no, los datos pueden haber sido manipulados o corrompidos durante la transmisi√≥n o almacenamiento.
                </p>
                <p>
                    Comparar los valores hash tambi√©n ofrece la ventaja de verificar la integridad de los datos sin requerir un espacio de almacenamiento significativo. Este m√©todo permite a los destinatarios confirmar la autenticidad de los datos simplemente comparando los valores hash antes y despu√©s de la transmisi√≥n.
                </p>
                <figure>
                    <img src="./images/Compare Hash.jpg" alt="Proceso de comparaci√≥n de valores hash">
                    <figcaption class="Compare">Proceso de comparaci√≥n de valores hash</figcaption>
                </figure>
            </div>

            <div>
                <h2>¬øSe pueden encontrar colisiones de hash?</h2>
                <p>
                    A trav√©s de las caracter√≠sticas de las funciones hash mencionadas anteriormente, hemos comprendido la resistencia a colisiones. Pero, ¬øes posible que existan colisiones de hash, es decir, que dos entradas diferentes produzcan la misma salida? 
                    La respuesta es afirmativa, las colisiones existen de hecho. Seg√∫n el <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank" style="color: #007bff; font-size: 1.0em;">principio del palomar</a>, siempre que el espacio de entrada sea lo suficientemente grande, existe la posibilidad de colisiones de hash.
                    Esto se debe a que el espacio de salida de las funciones hash suele ser mucho m√°s peque√±o que el espacio de entrada, lo que inevitablemente lleva a que m√∫ltiples entradas diferentes se asignen a la misma salida.
                </p>
                
                <p>
                    El principio del palomar es un principio simple e intuitivo de la matem√°tica combinatoria, que establece que si se colocan m√°s de n objetos en n contenedores, entonces al menos un contenedor contendr√° dos o m√°s objetos. 
                    Este principio tambi√©n se puede usar para explicar problemas como la paradoja del cumplea√±os.
                </p>
                <p>
                    La aplicaci√≥n del principio del palomar es muy amplia, con usos importantes en campos como la criptograf√≠a, la inform√°tica y las matem√°ticas. Por ejemplo, en inform√°tica, el principio del palomar se utiliza para demostrar la correcci√≥n de ciertos algoritmos o para analizar la complejidad temporal de los algoritmos.
                    En criptograf√≠a, el principio del palomar tambi√©n se utiliza para dise√±ar ciertos m√©todos de ataque criptogr√°fico, como el ataque de cumplea√±os.
                </p>
                <p>
                    La paradoja del cumplea√±os es una aplicaci√≥n cl√°sica del principio del palomar. Supongamos que hay n personas en una sala. 
                    Si queremos que la probabilidad de que al menos dos personas compartan el mismo cumplea√±os sea mayor al 50%, ¬øcu√°ntas personas se necesitan? Seg√∫n el principio del palomar,
                    si 367 personas (asumiendo que hay 366 d√≠as en un a√±o, m√°s un d√≠a adicional para el 29 de febrero en un a√±o bisiesto) se colocan en 366 "palomares" (es decir, cumplea√±os), entonces al menos un "palomar" contendr√° a dos personas, lo que significa que al menos dos personas comparten el mismo cumplea√±os. Esto ilustra la paradoja del cumplea√±os.
                </p>
                <p>
                    Es importante se√±alar que, aunque el principio del palomar es simple e intuitivo, su aplicaci√≥n debe considerar el contexto espec√≠fico. 
                    Por ejemplo, al aplicar el principio del palomar, es necesario asegurar que las variables aleatorias involucradas sean independientes entre s√≠; de lo contrario, puede llevar a conclusiones incorrectas. Adem√°s, en algunos casos, tambi√©n es necesario considerar factores como el tama√±o y la forma de los palomares.
                </p>
            </div>
            
            <div>
                <p>
                    Sin embargo, intentar encontrar colisiones de hash simplemente recorriendo el espacio de entrada puede no ser pr√°ctico, principalmente por dos razones:
                </p>
                <ul>
                    <li><strong>Complejidad computacional:</strong> Para la mayor√≠a de las funciones hash, el espacio de entrada es vasto. Tomando SHA-256 como ejemplo; su salida es un valor hash de 256 bits, lo que significa que tiene 2^256 posibles salidas. Dado que uno de los objetivos de dise√±o de las funciones hash es minimizar las colisiones tanto como sea posible, te√≥ricamente,
                            encontrar una colisi√≥n de hash para SHA-256 requerir√≠a recorrer aproximadamente 2^(256/2) = 2^128 entradas, seg√∫n la paradoja del cumplea√±os, que es el n√∫mero aproximado de entradas esperadas para encontrar una colisi√≥n. Incluso con los supercomputadores m√°s potentes actualmente disponibles, llevar√≠a mucho m√°s all√° de una vida humana completar tal tarea,
                            consider√°ndose imposible encontrar una colisi√≥n de hash SHA-256 mediante un simple recorrido.</li>
                    <li><strong>Dise√±o de funciones hash:</strong> Las funciones hash est√°n dise√±adas t√≠picamente para que encontrar colisiones sea computacionalmente inviable. Esto significa que, aunque te√≥ricamente existen colisiones, en la pr√°ctica es pr√°cticamente imposible encontrarlas. Esta es una caracter√≠stica importante de las funciones hash criptogr√°ficas (como SHA-256),
                            que se utilizan ampliamente en √°reas como firmas digitales, almacenamiento de contrase√±as y m√°s.</li>
                </ul>
                <p>
                    Por supuesto, tambi√©n podemos usar algoritmos espec√≠ficos para intentar encontrar colisiones de hash. Estos algoritmos a menudo explotan algunas propiedades o debilidades conocidas de las funciones de hash para encontrar colisiones. Aqu√≠ hay algunas t√©cnicas y m√©todos comunes para encontrar colisiones de hash:
                </p>
                <ul>
                    <li><strong>Ataque de Cumplea√±os:</strong> Este es un m√©todo simple basado en la probabilidad utilizado para estimar el tiempo requerido para encontrar una colisi√≥n cuando las entradas se eligen al azar. El principio del ataque de cumplea√±os es que si hay muchas personas en una habitaci√≥n, la probabilidad de que dos personas tengan el mismo cumplea√±os aumenta con el n√∫mero de personas. De manera similar, en las funciones de hash, si se selecciona un n√∫mero suficiente de entradas de manera aleatoria, es probable que dos entradas eventualmente produzcan el mismo resultado de hash.</li>
                    <li><strong>Ataque de Fuerza Bruta:</strong> Este es el m√©todo m√°s directo, que implica recorrer todas las posibles entradas para encontrar una colisi√≥n. Sin embargo, este m√©todo es impracticable para funciones de hash con grandes espacios de entrada debido a los enormes recursos computacionales y tiempo requerido.</li>
                    <li><strong>Tablas Arco√≠ris:</strong> Esta t√©cnica se utiliza para precalcular y almacenar un gran n√∫mero de valores hash y sus entradas correspondientes. Las tablas arco√≠ris son especialmente √∫tiles para descifrar contrase√±as que no han utilizado ofuscaci√≥n de datos aleatorios o tienen una funci√≥n de hash conocida. Al buscar en la tabla arco√≠ris, un atacante puede encontrar r√°pidamente una entrada que coincida con un valor de hash espec√≠fico.</li>
                    <li><strong>Ataques de Extensi√≥n de Hash:</strong> Ciertas funciones de hash permiten a los atacantes combinar datos adicionales con un valor de hash conocido sin conocer la entrada original, generando as√≠ un nuevo valor de hash. Este ataque puede usarse para construir colisiones o realizar otros tipos de ataques.</li>
                    <li><strong>Entradas Construidas Especialmente:</strong> A veces, los atacantes pueden explotar debilidades espec√≠ficas o comportamientos no lineales en las funciones de hash para construir entradas especiales que tienen m√°s probabilidades de producir colisiones en la funci√≥n de hash.</li>
                </ul>                
            </div>


            

            <div>
                <h2>¬øCu√°les son las funciones hash m√°s utilizadas?</h2>
                <h3>MD5 (Algoritmo de Resumen de Mensaje 5)</h3>
                <p>
                    MD5 es una funci√≥n hash criptogr√°fica ampliamente utilizada, dise√±ada por Ronald Rivest en la d√©cada de 1990 para reemplazar el antiguo algoritmo MD4. Puede convertir un mensaje de cualquier longitud en un valor hash de longitud fija (128 bits o 16 bytes).
                    El objetivo de dise√±o de MD5 era proporcionar una forma r√°pida y relativamente segura de generar una huella digital de los datos. Sin embargo, se han descubierto m√©todos de colisi√≥n para <a href="https://es.wikipedia.org/wiki/MD5" target="_blank" style="color: #007bff; font-size: 1.0em;">MD5</a>, lo que ha hecho que el algoritmo sea inseguro, pero a√∫n se utiliza ampliamente en situaciones donde la seguridad no es una preocupaci√≥n primordial.
                <br><br>El proceso de c√°lculo de MD5 implica los siguientes pasos:
                </p>
                <ul>
                    <li><strong>Relleno:</strong> Inicialmente, los datos originales se rellenan para que su longitud en bytes sea un m√∫ltiplo de 512. El relleno comienza con un 1, seguido de 0s hasta que se cumple el requisito de longitud.</li>
                    <li><strong>Agregando Longitud:</strong> Un valor de longitud de 64 bits, que es la representaci√≥n binaria de la longitud del mensaje original, se a√±ade al mensaje rellenado, haciendo que la longitud final del mensaje sea un m√∫ltiplo de 512 bits.</li>
                    <li><strong>Inicializando el Buffer MD:</strong> Cuatro registros de 32 bits (A, B, C, D) se inicializan para almacenar los valores hash intermedios y finales.</li>
                    <li><strong>Procesando Bloques de Mensajes:</strong> El mensaje rellenado y procesado por longitud se divide en bloques de 512 bits, y cada bloque se procesa a trav√©s de cuatro rondas de operaci√≥n. Cada ronda incluye 16 operaciones similares basadas en funciones no lineales (F, G, H, I), operaciones de desplazamiento circular izquierdo y adici√≥n m√≥dulo 32.</li>
                    <li><strong>Salida:</strong> El valor hash final es el contenido del √∫ltimo estado de los cuatro registros A, B, C, D concatenados (cada registro es de 32 bits), formando un valor hash de 128 bits.</li>
                </ul>
                
                <h3>SHA-1 (Algoritmo Hash Seguro 1)</h3>
                <p>
                    SHA-1 fue dise√±ado por la Agencia de Seguridad Nacional de EE. UU. (NSA) y publicado como un Est√°ndar de Procesamiento de Informaci√≥n Federal (FIPS PUB 180-1) por el Instituto Nacional de Est√°ndares y Tecnolog√≠a (NIST) en 1995.
                    SHA-1 est√° destinado para su uso en firmas digitales y otras aplicaciones criptogr√°ficas, generando un valor hash de 160 bits (20 bytes) conocido como un resumen de mensaje. Aunque ahora se sabe que <a href="https://es.wikipedia.org/wiki/SHA-1" target="_blank" style="color: #007bff; font-size: 1.0em;">SHA-1</a> tiene vulnerabilidades de seguridad y ha sido reemplazado por algoritmos m√°s seguros como SHA-256 y SHA-3,
                    entender su principio de funcionamiento a√∫n tiene valor educativo e hist√≥rico.
                <br><br>El prop√≥sito de dise√±o de SHA-1 es tomar un mensaje de longitud arbitraria y producir un resumen de mensaje de 160 bits para verificar la integridad de los datos. Su proceso de c√°lculo se puede dividir en los siguientes pasos:
                </p>
                <ul>
                    <li><strong>Relleno:</strong> Inicialmente, el mensaje original se rellena para que su longitud (en bits) m√≥dulo 512 sea igual a 448. El relleno siempre comienza con un bit "1", seguido de varios bits "0", hasta que se cumple la condici√≥n de longitud anterior.</li>
                    <li><strong>Agregando Longitud:</strong> Un bloque de 64 bits se a√±ade al mensaje rellenado, representando la longitud del mensaje original (en bits), haciendo que la longitud final del mensaje sea un m√∫ltiplo de 512 bits.</li>
                    <li><strong>Inicializando el Buffer:</strong> El algoritmo SHA-1 utiliza un buffer de 160 bits, dividido en cinco registros de 32 bits (A, B, C, D, E), para almacenar los valores hash intermedios y finales. Estos registros se inicializan con valores constantes espec√≠ficos al comienzo del algoritmo.</li>
                    <li><strong>Procesando Bloques de Mensajes:</strong> El mensaje preprocesado se divide en bloques de 512 bits. Para cada bloque, el algoritmo ejecuta un bucle principal que contiene 80 pasos similares. Estos 80 pasos se dividen en cuatro rondas, cada una con 20 pasos. Cada paso utiliza una funci√≥n no lineal diferente (F, G, H, I) y una constante (K). Estas funciones est√°n dise√±adas para aumentar la complejidad y la seguridad de las operaciones. En estos pasos, el algoritmo utiliza operaciones a nivel de bits (como AND, OR, XOR, NOT) y adici√≥n m√≥dulo 32, as√≠ como desplazamientos circulares izquierdos.</li>
                    <li><strong>Salida:</strong> Despu√©s de procesar todos los bloques, los valores acumulados en los cinco registros se concatenan para formar el valor hash final de 160 bits.</li>
                </ul>
                
                <h3>SHA-2 (Algoritmo Hash Seguro 2)</h3>
                <p>
                    SHA-2 es una familia de funciones hash criptogr√°ficas, que incluye varias versiones diferentes, consistiendo principalmente en seis variantes: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 y SHA-512/256. 
                    SHA-2 fue dise√±ado por la Agencia de Seguridad Nacional de Estados Unidos (NSA) y publicado como un Est√°ndar de Procesamiento de Informaci√≥n Federal (FIPS) por el Instituto Nacional de Est√°ndares y Tecnolog√≠a (NIST). En comparaci√≥n con su predecesor, SHA-1, SHA-2 ofrece una seguridad mejorada, reflejada principalmente en valores hash m√°s largos y una resistencia m√°s fuerte a ataques de colisi√≥n.
                <br><br>La operaci√≥n de la familia <a href="https://es.wikipedia.org/wiki/SHA-2" rel="noopener noreferrer" target="_blank" style="color: #007bff; font-size: 1.0em;">SHA-2</a> es similar a SHA-1 en muchos aspectos pero proporciona mayor seguridad mediante el uso de valores hash m√°s largos y un procedimiento de procesamiento m√°s complejo. Aqu√≠ est√°n los pasos principales del algoritmo SHA-2:
                </p>
                <ul>
                    <li><strong>Relleno:</strong> El mensaje de entrada se rellena primero para hacer que su longitud, menos 64 bits, sea igual a 448 o 896 en una base m√≥dulo 512 (para SHA-224 y SHA-256) o m√≥dulo 1024 (para SHA-384 y SHA-512). El m√©todo de relleno es el mismo que SHA-1, que implica agregar un "1" al final del mensaje, seguido de varios "0"s, y finalmente una representaci√≥n binaria de 64 bits (para SHA-224 y SHA-256) o 128 bits (para SHA-384 y SHA-512) de la longitud original del mensaje en bits.</li>
                    <li><strong>Inicializaci√≥n del Buffer:</strong> El algoritmo SHA-2 utiliza un conjunto de valores hash inicializados como el buffer de inicio, dependiendo de la variante de SHA-2 elegida. Por ejemplo, SHA-256 utiliza ocho registros de 32 bits, mientras que SHA-512 utiliza ocho registros de 64 bits. Estos registros se inicializan a valores constantes espec√≠ficos.</li>
                    <li><strong>Procesamiento de Bloques de Mensajes:</strong> El mensaje rellenado se divide en bloques de 512 bits o 1024 bits, y cada bloque se somete a m√∫ltiples rondas de operaciones criptogr√°ficas. SHA-256 y SHA-224 realizan 64 rondas de operaciones, mientras que SHA-512, SHA-384, SHA-512/224 y SHA-512/256 realizan 80 rondas. Cada ronda de operaci√≥n incluye una serie de operaciones complejas a nivel de bits, incluyendo operaciones l√≥gicas, adici√≥n modular y operaciones condicionales, bas√°ndose en diferentes funciones no lineales y constantes predefinidas. Estas operaciones aumentan la complejidad y seguridad del algoritmo.</li>
                    <li><strong>Salida:</strong> Finalmente, despu√©s de procesar todos los bloques, los valores en el buffer se combinan para formar el valor hash final. Dependiendo de la variante de SHA-2, este valor hash puede ser de 224, 256, 384 o 512 bits de longitud.</li>
                </ul>
                <p>
                    Podr√≠as preguntarte por qu√© la entrada a una funci√≥n hash puede ser de longitud arbitraria, pero la salida es fija. La raz√≥n es que la familia SHA-2 utiliza la transformaci√≥n de Merkle-Damg√•rd, que permite la construcci√≥n de funciones hash que pueden procesar mensajes de cualquier longitud a partir de una funci√≥n de compresi√≥n de longitud fija. La transformaci√≥n de Merkle-Damg√•rd se adopta en muchas funciones hash tradicionales, incluyendo MD5 y SHA-1.
                </p>
                <p>
                    La idea central de la transformaci√≥n de Merkle-Damg√•rd es dividir el mensaje de entrada en bloques de tama√±o fijo y luego procesar estos bloques uno por uno, donde cada paso de procesamiento depende del resultado del anterior, produciendo finalmente un valor hash de tama√±o fijo. El paso de relleno de SHA-256 encarna los principios b√°sicos de la transformaci√≥n de Merkle-Damg√•rd, es decir, mediante el relleno adecuado para procesar mensajes de cualquier longitud y asegurando que la longitud final del mensaje procesado cumpla ciertas condiciones (como ser un m√∫ltiplo de una longitud fija). Por lo tanto, se puede decir que el paso de relleno de SHA-256 sigue el m√©todo de transformaci√≥n de Merkle-Damg√•rd.
                </p>
                <figure>
                    <img src="./images/Merkle-Damg√•rd Padding.jpg" alt="Principio de relleno de Merkle-Damg√•rd">
                    <figcaption class="Merkle-Damg√•rd">Principio de relleno de Merkle-Damg√•rd</figcaption>
                </figure>
                <p>
                    Sin embargo, SHA-256 no es simplemente una implementaci√≥n directa de la transformaci√≥n de Merkle-Damg√•rd. Tambi√©n incluye una serie de pasos computacionales complejos (como la expansi√≥n del mensaje, m√∫ltiples rondas de funciones de compresi√≥n, etc.), que son dise√±os √∫nicos de SHA-256, destinados a mejorar su seguridad. Por lo tanto, aunque SHA-256 sigue los principios de la transformaci√≥n de Merkle-Damg√•rd en su paso de relleno, mejora la seguridad general introduciendo otros mecanismos de seguridad, haci√©ndolo no solo limitado al marco b√°sico de la transformaci√≥n de Merkle-Damg√•rd.
                </p>

                <h3>SHA-3 (Algoritmo Hash Seguro 3)</h3>
                <p>
                    SHA-3 es el √∫ltimo est√°ndar de hash seguro, aprobado oficialmente por el Instituto Nacional de Est√°ndares y Tecnolog√≠a (NIST) en 2015 como un Est√°ndar de Procesamiento de Informaci√≥n Federal (FIPS 202). SHA-3 no tiene la intenci√≥n de reemplazar a los anteriores SHA-1 o SHA-2 (ya que SHA-2 todav√≠a se considera seguro),
                    sino m√°s bien complementar y ofrecer una opci√≥n alternativa dentro de la familia SHA, proporcionando un algoritmo de hash criptogr√°fico diferente. SHA-3 se basa en el algoritmo Keccak, dise√±ado por Guido Bertoni y otros, y fue el ganador de la competencia SHA-3 organizada por el NIST en 2012.
                <br><br>El principio de funcionamiento de SHA-3 difiere significativamente de SHA-2, principalmente porque utiliza un m√©todo conocido como "<strong>construcci√≥n de esponja</strong>" para absorber y exprimir datos, produciendo el valor hash final. Este m√©todo permite que SHA-3 produzca de manera flexible valores hash de diferentes longitudes, ofreciendo as√≠ una gama m√°s amplia de aplicaciones que SHA-2. Los pasos principales de SHA-3 son los siguientes:
                </p>
                <figure>
                    <img src="./images/sponge construction.jpg" alt="Diagrama esquem√°tico de la construcci√≥n esponja">
                    <figcaption class="sponge">Diagrama esquem√°tico de la construcci√≥n esponja</figcaption>
                </figure>
                <h4>Fase de absorci√≥n: </h4>
                <p>
                    En la fase de absorci√≥n, la estructura de esponja primero divide los datos de entrada en bloques de tama√±o fijo. Estos bloques de datos se "absorben" secuencialmente en el estado interno de la esponja, que es t√≠picamente m√°s grande que un solo bloque de datos, para asegurar que se pueda procesar una gran cantidad de datos sin desbordamiento.
                    Espec√≠ficamente, cada bloque de datos se fusiona con una parte del estado interno de alguna manera (como por una operaci√≥n XOR), seguido por la aplicaci√≥n de una funci√≥n de permutaci√≥n fija (en SHA-3, esta es <a href="https://es.wikipedia.org/wiki/SHA-3" target="_blank" style="color: #007bff; font-size: 1.0em;">Keccak-f</a>) para transformar todo el estado, evitando as√≠ la interferencia entre diferentes bloques de datos de entrada. Este proceso se repite hasta que todos los bloques de datos de entrada hayan sido procesados.
                </p>
                <p>
                    Keccak-f es la funci√≥n de permutaci√≥n central utilizada en el algoritmo hash criptogr√°fico SHA-3. Es un componente central de la familia de algoritmos Keccak. SHA-3 se basa en el algoritmo Keccak, que gan√≥ la competencia de algoritmos hash criptogr√°ficos organizada por el NIST y fue seleccionado como el est√°ndar para SHA-3. La funci√≥n Keccak-f tiene varias variantes,
                    siendo la m√°s com√∫nmente utilizada Keccak-f[1600], donde el n√∫mero indica el ancho de bits en el que opera. 
                </p>
                <p>
                    Keccak-f est√° compuesto por m√∫ltiples rondas de la misma operaci√≥n (llamadas rondas). Para Keccak-f[1600], hay un total de 24 rondas de operaciones. Cada ronda incluye cinco pasos b√°sicos:<em> Œ∏ (Theta), œÅ (Rho), œÄ (Pi), œá (Chi) e Œπ (Iota)</em>. Estos pasos act√∫an juntos sobre el arreglo de estado, transformando gradualmente su contenido,
                    aumentando la confusi√≥n y difusi√≥n para mejorar la seguridad. A continuaci√≥n, se proporciona una breve descripci√≥n de estos pasos:
                </p>
                <ul>
                    <li><strong>Œ∏ (Theta) paso:</strong> Realiza operaciones XOR en todos los bits de cada columna, luego XOR el resultado en columnas adyacentes, proporcionando difusi√≥n entre columnas.</li>
                    <li><strong>œÅ (Rho) paso:</strong> Operaci√≥n de rotaci√≥n a nivel de bit, donde cada bit se rota un n√∫mero diferente de bits seg√∫n reglas predeterminadas, aumentando la complejidad de los datos.</li>
                    <li><strong>œÄ (Pi) paso:</strong> Reorganiza los bits en el arreglo de estado, cambiando la posici√≥n de los bits para lograr difusi√≥n a trav√©s de filas y columnas.</li>
                    <li><strong>œá (Chi) paso:</strong> Un paso no lineal que realiza operaciones XOR en cada bit de cada fila, incluyendo a s√≠ mismo, su vecino inmediato y el complemento del vecino. Esta es una operaci√≥n local que aumenta las caracter√≠sticas no lineales del algoritmo criptogr√°fico.</li>
                    <li><strong>Œπ (Iota) paso:</strong> Introduce una constante de ronda en parte del arreglo de estado, con la constante difiriendo en cada ronda, para evitar que todas las rondas operen id√©nticamente, introduciendo imprevisibilidad.</li>
                </ul>
                <p>
                    Keccak-f proporciona un alto nivel de seguridad a trav√©s de estos pasos. Su dise√±o asegura que incluso cambios menores en la entrada lleven a cambios generalizados e impredecibles en el arreglo de estado, logrados a trav√©s de los principios de confusi√≥n (haciendo dif√≠cil para los atacantes inferir la entrada a partir de la salida) y difusi√≥n (donde cambios menores en la entrada afectan m√∫ltiples partes de la salida).
                </p>
            
                <p>
                    El dise√±o de Keccak-f permite la ajustabilidad de par√°metros (como el tama√±o del estado y el n√∫mero de rondas) a trav√©s de diferentes niveles de seguridad y escenarios de aplicaci√≥n, ofreciendo gran flexibilidad. Keccak-f[1600] es conocido por su implementaci√≥n eficiente, logrando altas velocidades de procesamiento tanto en hardware como en software, especialmente al manejar grandes cantidades de datos.
                </p>
            
                <h4>Fase de extracci√≥n:</h4>
                <p>
                    Una vez que todos los bloques de datos de entrada han sido absorbidos en el estado interno, la estructura de esponja entra en la fase de extracci√≥n. En esta etapa, partes del estado interno se van extrayendo progresivamente como resultado de la funci√≥n hash. Si la longitud de salida requerida excede la cantidad que se puede exprimir de una vez, la estructura de esponja aplica la funci√≥n de permutaci√≥n para transformar nuevamente el estado interno, y luego contin√∫a extrayendo m√°s datos. Este proceso se lleva a cabo hasta que se alcanza la longitud de salida deseada.
                </p>
            
                <p>
                    El objetivo del dise√±o de SHA-3 es proporcionar mayor seguridad que SHA-2 y mejor resistencia contra ataques inform√°ticos cu√°nticos. Gracias a su estructura √∫nica de esponja, SHA-3 es te√≥ricamente capaz de resistir todos los m√©todos de ataque criptogr√°fico conocidos actualmente, incluyendo ataques de colisi√≥n, ataques de preimagen y ataques de segunda preimagen.
                </p>

                <h3>RIPEMD-160 (Digesto de Mensaje de Evaluaci√≥n de Primitivas de Integridad RACE)</h3>
                <p>
                    RIPEMD-160 es una funci√≥n hash criptogr√°fica dise√±ada para proporcionar un algoritmo de hashing seguro. Fue desarrollado en 1996 por Hans Dobbertin y otros,
                    y es miembro de la familia RIPEMD (Digesto de Mensaje de Evaluaci√≥n de Primitivas de Integridad RACE).
                </p>
                <p>
                    RIPEMD-160 produce un valor hash de 160 bits (20 bytes), que es el origen del "160" en su nombre. Se basa en el dise√±o de MD4 e influenciado por otros algoritmos de hashing como MD5 y SHA-1. RIPEMD-160 incluye dos operaciones paralelas,
                    similares que procesan los datos de entrada por separado y luego combinan los resultados de estos dos procesos para generar el valor hash final. Este dise√±o tiene como objetivo mejorar la seguridad.
                <br>
                <br>El proceso de c√°lculo de <a href="https://es.wikipedia.org/wiki/RIPEMD" target="_blank" style="color: #007bff; font-size: 1.0em;"> RIPEMD-160 </a> incluye varios pasos b√°sicos: relleno, procesamiento de bloques y compresi√≥n:
                </p>
                <ul>
                    <li><strong>Relleno: </strong> El mensaje de entrada se rellena primero para asegurar que su longitud m√≥dulo 512 bits sea igual a 448 bits. El relleno siempre comienza con un √∫nico bit de 1 seguido de una serie de 0 bits, terminando con una representaci√≥n de 64 bits de la longitud del mensaje original.</li>
                    <li><strong>Procesamiento de Bloques: </strong> El mensaje rellenado se divide en bloques de 512 bits.</li>
                    <li><strong>Inicializaci√≥n: </strong> Utiliza cinco registros de 32 bits (A, B, C, D, E), que se inicializan a ciertos valores espec√≠ficos.</li>
                    <li><strong>Funci√≥n de Compresi√≥n: </strong> Cada bloque se procesa por turno, actualizando los valores de estos cinco registros a trav√©s de una serie de operaciones complejas. Este proceso incluye operaciones a nivel de bits (como adici√≥n, AND, OR, NOT, rotaciones circulares a la izquierda) y el uso de un conjunto de constantes fijas.</li>
                    <li><strong>Salida: </strong> Despu√©s de que todos los bloques han sido procesados, los valores de estos cinco registros se concatenan para formar el valor hash final de 160 bits.</li>
                </ul>                
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="support-links">
            <h3>Apoyo</h3>
            <ul>
                <li><a href="https://tap5ai.com/" target="_blank" rel="noopener noreferrer">Tap5 AI</a></li>
            </ul>
        </div>

        <div class="social-links">
            <a href="https://twitter.com/xinli_111219" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-twitter"></i>
            </a>
            <a href="https://www.youtube.com/@xinli-vj3js" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-youtube"></i>
            </a> 
        </div>
    
        <div class="info">
            <p>¬© 2024 chatcipher Tools. Todos los derechos reservados.</p>
            <p>
                <a href="https://chatcipherai.com/es/Privacy_Policy.html" title="Privacy Policy">Pol√≠tica de Privacidad</a>
                |
                <a href="https://chatcipherai.com/es/Terms_of_Use.html" title="Terms of Use">T√©rminos de Uso</a>
                |
                <a href="https://chatcipherai.com/es/About_Us.html" title="About Us">Sobre nosotros</a>
                |
                <a href="https://chatcipherai.com/es/Disclaimer.html" title="Disclaimer">Descargo de responsabilidad</a>
            </p> 
            <button id="backToTop" onclick="scrollToTop()">Volver al Inicio</button>
        </div> 
    </footer>

    <script>
        let shortcutsEnabled = true;

        function manageShortcuts(enable) {
            shortcutsEnabled = enable;
        }

        function handleKeyPress(event) {
            if (!shortcutsEnabled) {
                console.log('Shortcuts are disabled');
                return;
            }

            switch (event.key.toUpperCase()) {
                case 'A':
                    clearAll();
                    console.log('Clear All triggered');
                    break;
                case 'L':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('light-mode');
                        console.log('Light style activated');
                    }
                    break;
                case 'N':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('dark-mode');
                        console.log('Dark style activated');
                    }
                    break;
                case 'B':
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                    console.log('Scrolled to top');
                    break;
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Ensure all handlers are set up once the DOM is fully loaded
            document.addEventListener('keydown', handleKeyPress);

            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
            
            setupEventListeners(); // Setup other event listeners
            adjustButton();
        });

        let generatedTextHash = '';
        let generatedFileHash = '';

        async function generateHash() {
            const text = document.getElementById('textInput').value;
            document.getElementById('processOutput').textContent = text.length ? "Calculando el valor hash..." : '';
            const msgUint8 = new TextEncoder().encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('hashOutput').textContent = `valor hash (SHA-256): ${hashHex}`;
            generatedTextHash = hashHex;
            document.getElementById('processOutput').textContent = "";
        }

        async function generateFileHash() {
            const fileInput = document.getElementById('fileInput');
            if (!fileInput.files.length) {
                alert("Por favor seleccione un archivo.");
                return;
            }
            document.getElementById('fileHashOutput').textContent = "Calculando el valor hash del archivo...";
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('fileHashOutput').textContent = `valor hash (SHA-256): ${hashHex}`;
                generatedFileHash = hashHex;
            };
            reader.onerror = function () {
                alert("Error de lectura de archivos.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareTextHash() {
            const compareHash = document.getElementById('hashCompareInput').value;
            if (!generatedTextHash) {
                alert('Primero genere un hash del texto.');
                return;
            }
            const resultText = generatedTextHash === compareHash ? "<strong>Conclusi√≥n: </strong>Los hashes coinciden y los datos no han sido alterados." : "<strong>Conclusi√≥n: </strong>Los hashes no coinciden y los datos podr√≠an haber sido alterados durante la transmisi√≥n o se produjo un error durante el almacenamiento.";
            document.getElementById('textCompareResult').innerHTML = resultText;
            document.getElementById('textCompareResult').style.color = generatedTextHash === compareHash ? "black" : "red";
        }

        async function compareFileHash() {
            const fileInput = document.getElementById('compareFileInput');
            if (!fileInput.files.length) {
                alert("Please select a file to compare.");
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                document.getElementById('fileCompareResult').textContent = `valor hash (SHA-256): ${hashHex}`;

                if (generatedFileHash === hashHex) {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Conclusi√≥n: </strong>Los hashes coinciden y los datos no han sido alterados.";
                    document.getElementById('fileCompareResult').style.color = "black";
                } else {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Conclusi√≥n: </strong>Los hashes no coinciden, y los datos podr√≠an haber sido alterados durante la transmisi√≥n o se pudo haber producido un error durante el almacenamiento.";
                    document.getElementById('fileCompareResult').style.color = "red";
                }
            };
            reader.onerror = function () {
                alert("Error de lectura de archivos.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareHashValues() {
            var hashValue1 = document.getElementById('hashInput1').value.trim();
            var hashValue2 = document.getElementById('hashInput2').value.trim();

            var resultDisplay = document.getElementById('hashComparisonResult');

            resultDisplay.style.fontWeight = 'bold';

            if (hashValue1 === "" || hashValue2 === "") {
                resultDisplay.textContent = 'Ambos valores hash deben ser ingresados.';
                resultDisplay.style.color = 'black';
            } else if (hashValue1 === hashValue2) {
                resultDisplay.textContent = '¬°Los valores hash coinciden!';
                resultDisplay.style.color = 'black';
            } else {
                resultDisplay.textContent = 'Los valores hash no coinciden.';
                resultDisplay.style.color = 'red';
            }
        }

        function copyTextHash() {
            const hashValue = document.getElementById('hashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("No se pudo copiar el hash de texto.");
                });
            }
        }

        function copyFileHash() {
            const hashValue = document.getElementById('fileHashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("No se pudo copiar el hash del archivo.");
                });
            }
        }

        function clearAll() {
            document.getElementById('textInput').value = '';
            document.getElementById('hashOutput').textContent = '';
            document.getElementById('hashCompareInput').value = '';
            document.getElementById('textCompareResult').textContent = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('fileHashOutput').textContent = '';
            document.getElementById('compareFileInput').value = '';
            document.getElementById('fileCompareResult').textContent = '';
            document.getElementById('hashInput1').value = '';
            document.getElementById('hashInput2').value = '';
            document.getElementById('hashComparisonResult').textContent = '';
        }

        document.getElementById('menuIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .menuUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });
        document.getElementById('languageIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .langUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });

        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var menunavbarUl = document.querySelector('.navbar .menuUl');

            var languageIcon = document.getElementById('languageIcon');
            var langnavbarUl = document.querySelector('.navbar .langUl');

            if (!menuIcon.contains(event.target) && !menunavbarUl.contains(event.target)) {
                menunavbarUl.style.display = 'none';
            }
            if (!languageIcon.contains(event.target) && !langnavbarUl.contains(event.target)) {
                langnavbarUl.style.display = 'none';
            }
        });
        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var navbarUl = document.querySelector('.navbar ul');

            if (!menuIcon.contains(event.target) && !navbarUl.contains(event.target)) {
                navbarUl.style.display = 'none';
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
        });

        document.getElementById('lightStyle').addEventListener('click', function () {
            setStyle('light-mode');
        });

        document.getElementById('darkStyle').addEventListener('click', function () {
            setStyle('dark-mode');
        });

        function setStyle(style) {
            document.body.className = style;
            localStorage.setItem('style', style);
            updateButtonStyles();
            updateNavbarStyles(style);
        }

        function updateNavbarStyles(style) {
            var navbar = document.querySelector('.navbar');
            var ul = navbar.querySelector('ul');
            navbar.style.backgroundColor = style === 'dark-mode' ? '#0A0F24' : '#FFFFFF';
            ul.style.backgroundColor = style === 'dark-mode' ? 'rgba(119, 136, 153, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            ul.style.color = style === 'dark-mode' ? '#FFFFFF' : '#0A0F24';
        }

        document.querySelectorAll('.learnMore').forEach(function (link) {
            link.addEventListener('click', function () {
                var targetId = this.getAttribute('data-target');
                var moreContent = document.getElementById(targetId);
                if (moreContent.style.display === "none" || moreContent.style.display === "") {
                    moreContent.style.display = "block";
                    this.textContent = "[Cierre]";
                } else {
                    moreContent.style.display = "none";
                    this.textContent = "[Aprende m√°s]";
                }
            });
        });

        window.onscroll = function () { scrollFunction(); };
        function scrollFunction() {
            if (document.body.scrollTop > 10 || document.documentElement.scrollTop > 20) {
                document.getElementById("backToTop").style.display = "block";
            } else {
                document.getElementById("backToTop").style.display = "none";
            }
        }
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        document.addEventListener('DOMContentLoaded', function () {
            var navbar = document.querySelector('.navbar');
            window.onscroll = function () {
                if (window.scrollY > 50) {
                    navbar.classList.add('solid');
                } else {
                    navbar.classList.remove('solid');
                }
            };
        });

        function adjustButton() {
            var button = document.getElementById('backToTop');
            if (window.innerWidth < 768) {
                button.innerHTML = '‚ñ≤';
            } else {
                button.innerHTML = 'Volver al Inicio(<span class="highlight-key">B</span>)';
            }
        }

        window.onload = adjustButton;
        window.onresize = adjustButton;

    </script>
    <div style="display: none;">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-LZTEEH0M4K"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
    
            gtag('config', 'G-LZTEEH0M4K');
        </script>
    </div>
</body>
</html>