<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador de Hash SHA-256: O escultor irrevers√≠vel do mundo digital.</title>
    <meta name="keywords" content="cifra, hash, dados, fun√ß√µes de hash, valores de hash, fun√ß√µes"/>
    <meta name="description" 
        content="Forjando a impress√£o digital √∫nica da informa√ß√£o com criptografia de 256 bits, protegendo a integridade e autenticidade dos dados.">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="icon" type="image/jpg" href="./images/cipher.jpg">
    <style>    
        html {
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100vh;
            align-items: center;
            margin: 0;
            padding: 0 20px 20px 20px;
            background-color: #0A0F24;
            color: #FFFFFF;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(10, 15, 36, 0.0);
            transition: background-color 0.5s ease;
            z-index: 1000;
            height: 40px;
        }

        .navbar.solid {
            background-color: rgba(10, 15, 36, 1);
        }

        #menuIcon {
            cursor: pointer;
            transition: color 0.3s ease;
        }

        #menuIcon:hover {
            color: #a3a2a2;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            position: relative;
            left: -10px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        .navbar .langUl {
            left: 87px;
            width: 100px;
        }

        .navbar.active ul {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 35px;
            left: 10px;
            width: 15%;
            background-color: rgba(119, 136, 153, 0.8);
            padding: 10px 0;
        }

        .navbar.active ul li {
            margin-bottom: 1px;
        }

        .navbar.active ul li:last-child {
            margin-bottom: 0;
        }

        .navbar ul {
            display: none;
            flex-direction: column;
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: transparent;
            padding: 10px 0;
            list-style: none;
            margin: 0;
            width: 13%;
        }

        .navbar.active ul {
            display: flex;
        }

        .section.interactive-tool {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #bbbaba;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 1000px;
            margin-top: 30px;
            margin-bottom: 150px;
        }

        .sections-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 120px;
            margin-right: -10px;
        }

        .sections-container h2,
        .sections-container p {
            text-align: left;
            width: 80%;
        }

        p {
            margin-bottom: 30px;
            text-align: left;
            font-size: 1.2em;
            line-height: 1.6;
            margin-bottom: 15px;
            text-align: center; 
        }

        h2 {
            margin-bottom: 10px;
            font-size: 28px;
            margin-top: 50px;
        }

        h3 {
            margin-top: 50px;
            font-size: 22px;
        }

        h4 {
            font-size: 20px;
        }

        .sections-container h2:hover {
            color: #4bcfcf;
            transition: color 0.3s ease;
        }

        .navbar li a {
            color: white;
            padding: 5px;
            text-decoration: none;
            font-size: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            display: block;
            border-radius: 5px;
        }

        .navbar ul li {
            margin-bottom: 1px;
        }

        .navbar ul li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .navbar h1 {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 35px;
            margin-right: 0;
            font-size: 30px;
        }

        .navbar-dark {
            background-color: #0A0F24;
        }

        .morse-code-container {
            display: flex;
            align-items: center;
        }

        .morse-code-container .copy-button {
            margin-right: 5px;
            margin-left: 0;
        }

        button {
            cursor: pointer;
            margin: 10px;
            padding: 8px 15px;
            margin-left: 5px;
            background-color: #c0c0c0;
            border: none;
            border-radius: 5px;
            color: #FFFFFF;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #a8a8a8;
        }

        .style-selector {
            position: absolute;
            top: 0px;
            right: 50px;
            margin-top: 10px;
        }

        .style-selector button {
            background-color: #0a0f24;
            padding: 5px 10px;
            margin-right: 1px;
            color: #F5F5F5;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .style-selector button:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .dark-mode {
            background-color: #0A0F24;
            color: white;
        }

        .light-mode {
            background-color: white;
            color: #0A0F24;
        }

        .light-mode .navbar,
        .light-mode .container {
            background-color: #FFFFFF;
            color: #0A0F24;
        }

        .light-mode .navbar ul {
            background-color: transparent;
            color: #0A0F24;
        }

        .dark-mode .navbar ul li a:hover {
            color: #30eded;
        }

        .light-mode .navbar ul li:hover {
            color: #0A0F24;
            background-color: rgba(255, 255, 255, 1);
            border-radius: 5px;
        }

        .navbar {
            justify-content: flex-start;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            margin-left: 30px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        #languageSelect {
            padding: 5px 10px;
            margin-left: 10px;
            border-radius: 5px;
            border: none;
            background-color: #5f9ea0;
            color: white;
            cursor: pointer;
        }

        #languageSelect:hover {
            background-color: #2F4F4F;
        }

        .language-dropdown {
            width: 6%;
            display: none;
            list-style: none;
            padding: 10px 0;
            margin: 0;
            position: absolute;
            top: 40px;
            left: 100px;
            background-color: rgba(119, 136, 153, 0.8);
        }

        .language-dropdown li a {
            color: #FFFFFF;
            padding: 5px;
            margin: 1px;
            text-decoration: none;
            display: block;
            border-radius: 8px;
        }

        .language-dropdown li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .table-container {
            display: none;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .table-container.active {
            display: block;
        }

        .button-container {
            display: flex;
            justify-content: center;
            margin-right: 20px
        }

        .button-container button {
            margin-right: 30px;
        }

        .footer {
            position: relative;
            width: 100%;
            background-color: #0A0F24;
            color: #FFFFFF;
            text-align: center;
            padding: 10px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            margin-bottom: -20px;
        }

        .footer a {
            color: #F5F5F5;
            text-decoration: none;
            margin: 0 12px;
            transition: color 0.3s ease;
        }

        .footer a:hover {
            color: #a3a2a2;
        }

        .footer p {
            margin: 0;
            font-size: 16px;
        }

        .learnMore {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .moreContent {
            width: 80%;
            margin: auto;
            text-align: left;
            padding: 10px;
            display: none;
            margin-left: 0px;
        }

        .moreContent p {
            margin-bottom: 16px;
            font-size: 1.2em;
            line-height: 1.6;
            padding-bottom: 5px;
        }

        #moreContent1 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent1 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        #moreContent2 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent2 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        .clear-all-button {
            background-color: #47d7ff;
        }

        .clear-all-button:hover {
            background-color: #57f7ff;
        }

        figure {
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            text-align: center;
            width: 100%;
            margin: 0 auto;
        }

        img {
            max-width: 75%;
            height: auto;
            margin-left: -290px;
            margin-top: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
        }

        figcaption.workflow,
        figcaption.Irreversibility,
        figcaption.Resistance,
        figcaption.Merkle-Damg√•rd,
        figcaption.Compare,
        figcaption.sponge {
            width: 100%;
            margin-left: -300px;
            color: #007bff;
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 10px;
        }

        .navbar li {
            position: relative;
        }

        .navbar li>a {
            display: block;
        }

        .navbar .submenu {
            display: none;
            position: absolute;
            left: 101%;
            top: 0;
            background-color: transparent;
            border-radius: 5px;
            padding: 0;
            min-width: 150px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .navbar .submenu li {
            display: block;
            border-bottom: none;
            width: 140%;
        }

        .navbar .submenu li:last-child {
            border-bottom: none;
        }

        .navbar li:hover>.submenu {
            display: block;
        }

        .navbar .submenu a {
            color: #ffffff;
            padding: 5px;
            text-decoration: none;
            display: block;
            transition: background-color 0.3s ease;
        }

        .navbar .submenu a:hover {
            background-color: rgba(255, 255, 255, 0.206);
        }

        .input-group {
            display: flex;
            width: 83%;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 40px;
        }

        .input-group>div {
            flex: 1;
            margin-right: 20px;
        }

        .input-group>div:last-child {
            margin-right: 0;
        }

        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 10px 15px 10px 5px;
            border: 1px solid #eae6e6;
            border-radius: 5px;
            box-sizing: border-box;
        }

        button,
        input[type="submit"],
        input[type="file"]::file-selector-button {
            background-color: #0a0f24;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s;
        }

        button:hover,
        input[type="submit"]:hover,
        input[type="file"]::file-selector-button:hover {
            background-color: #c0c0c0;
            color: #0A0F24;
        }

        .compare-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        input[type="file"] {
            display: block;
        }

        .outPut {
            width: 100%;
            white-space: normal;
            word-break: break-all;
        }

        #backToTop {
            position: absolute;
            bottom: 5px;
            right: 30px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #0a0f24;
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
            display: block;
        }

        #backToTop:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .introduce {
            margin-left: 220px;
        }

        .introduce li {
            font-size: 17px;
            line-height: 1.5;
            word-wrap: break-word;
            width: 80%;
            padding-bottom: 10px; 
        }

        .language-list{
            float: right;
        }
        .language-list a{
            margin-left: 20px;
            color: white;
        }

        .language-list a:hover{
            color: #4bcfcf;
        }

        .language-list a {
            text-decoration: none;
        }

        .attention {
            margin-top: 20px;
            font-size: 0.8em;
        }

        .highlight-key { 
            font-weight: 800;
        }

        .support-links {
            flex: 1;
            text-align: left;
            margin-left: 50px;
            margin-bottom: -50px;
            margin-top: -32px;
        }

        .support-links h3 {
            font-size: 18px;
            color: white;
        }

        .support-links ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .support-links li {
            margin-bottom: 5px;
        }

        .support-links a {
            color: white;
            text-decoration: none;
        }

        .support-links a:hover {
            text-decoration: underline;
        }

        @media screen and (max-width: 768px) {
            .navbar h1 {
                font-size: 18px;
                position: absolute;
                top: -25px;
            }

            .sections-container {
                margin-left: auto;
                margin-right: auto;
                align-items: center;
                width: 100%;
            }

            .sections-container h2 {
                font-size: 1.2em;
            }

            .sections-container p {
                font-size: 0.9em;
            }
            
            .introduce {
                width: 100%;
                padding: 10px;
                margin-left: 90px;
            }

            .introduce h2 {
                font-size: 1.2em; 
            }

            h3 {
                font-size: 0.9em; 
            }

            h4 {
                font-size: 0.8em; 
            }

            .introduce p {
                font-size: 0.9em; 
            }

            .introduce li {
                font-size: 14px;
                margin-left: -20px;
            }

            figure {
                display: flex;
                flex-direction: column;
                align-items: center; 
                justify-content: center; 
                text-align: center;
                width: 100%;
                margin: 0 auto;
            }

            img {
                max-width: 80%;
                height: auto;
                margin-left: -90px;
                margin-top: 20px;
            }

            figcaption.workflow,
            figcaption.Irreversibility,
            figcaption.Resistance,
            figcaption.Merkle-Damg√•rd,
            figcaption.Compare,
            figcaption.sponge {
                width: 100%;
                margin-left: -100px;
                color: #007bff;
                font-size: 0.8em;
                font-weight: bold;
                margin-top: 10px;
            }

            .footer p {
                margin: 0;
                font-size: 10px;
            }

            pre {
                display: none;
            }

            #backToTop {
                content: '‚ñ≤';
                padding: 4px 5px;
                font-size: 14px;
                right: 10px;
                bottom: 0px;
            }
   
            .input-group {
                flex-direction: column;
            }

            .section.interactive-tool {
                width: 320px;
            }
            .navbar ul {
                width: 27%;
            }

            .navbar ul li {
                padding: 0 5px 0 0;
            }

            .navbar li a {
                padding: 5px;
            }

            .navbar li a {
                font-size: 10px;
                width: 100%;
                padding: 5px 0px 5px 5px;
            }

            .navbar .submenu {
                left: 100%;
            }

            .navbar .submenu li {
                display: block;
                border-bottom: none;
                width: 55%;
                padding: 0 5px 0 0;
            }

            .navbar .submenu li a {
                padding: 5px 0px 5px 5px;
            }

            #menuIcon {
                font-size: 0; /* Hide text */
            }
            #menuIcon::before {
                content: '\2630'; /* Unicode character for ‚ò∞ */
                font-size: 16px; /* Or any other size you prefer */
            }

            #languageIcon {
                font-size: 0;
            }

            #languageIcon::before {
                content: '\2637'; /* Unicode character for ‚ò∞ */
                font-size: 16px; /* Or any other size you prefer */
            }

            .navbar .langUl {
                left: 42px;
                width: 65px;
            }

            #darkStyle {
                font-size: 0;
                margin-left: 10px;
                padding: 5px 8px;
            }

            #lightStyle {
                font-size: 0;
                margin-right: -10px;
            }

            #darkStyle::before {
                font-size: 9px;
            }

            #lightStyle::before {
                font-size: 10px;
            }

            #darkStyle::before {
                content: "üåô";
            }

            #lightStyle::before {
                content: "‚òÄ";
            }

            #hashCompareInput {
                width: 240px;
            }

            .social-links i {
                font-size: 12px;
            }

            .attention {
                margin-top: 10px;
                font-size: 0.5em;
            }

            .support-links {
                flex: 1;
                text-align: left;
                margin-left: 0;
                margin-bottom: -50px;
                font-size: 10px;
            }

            .support-links h3 {
                font-size: 10px;
            }
        }
    </style>
</head>

<body class="dark-mode">
    <header>
        <nav class="navbar">
            <div id="menuIcon">&#9776; menu</div>
            <div id="menuItems"></div>
            <ul class="menuUl">
                <li>
                    <a href="https://chatcipherai.com/pt/chatcipherai.html"><strong>Mundo dos Criptossistemas</strong></a>
                    <ul class="submenu">
                        <li><a href="https://chatcipherai.com/pt/Caesar_Cipher.html"><strong>Cifra de C√©sar</strong></a></li>
                        <li><a href="https://chatcipherai.com/pt/Playfair_Cipher.html"><strong>Cifra de Playfair</strong></a></li>
                        <li><a href="https://chatcipherai.com/pt/Four_Square_Cipher.html"><strong>Cifra de Quatro Quadrados</strong></a></li>
                        <li><a href="https://chatcipherai.com/pt/Hill_Cipher.html"><strong>Cifra de Hill</strong></a></li>  
                    </ul>
                </li>
                <li><a href="https://chatcipherai.com/pt/Hash_value_test.html"><strong>Teste de Valor de Hash</strong></a></li>
                <li><a href="https://chatcipherai.com/pt/Morsecode_main.html"><strong>Tradutor de C√≥digo Morse</strong></a></li>
                <li><a href="https://chatcipherai.com/pt/Shortcut_Key_Description.html"><strong>Descri√ß√£o da Tecla de Atalho</strong></a></li>
            </ul>            

            <div id="languageIcon">&#x2637; idioma</div>
            <div id="languageItems">
                <ul class="langUl">
                    <li><a href="https://chatcipherai.com/en/Hash_value_test.html" title="English">English</a></li>
                    <li><a href="https://chatcipherai.com/fr/Hash_value_test.html" title="Fran√ßais">Fran√ßais</a></li>
                    <li><a href="https://chatcipherai.com/es/Hash_value_test.html" title="Espa√±ol">Espa√±ol</a></li>
                    <li><a href="https://chatcipherai.com/zh-CN/Hash_value_test.html" title="‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ">‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ</a></li>
                    <li><a href="https://chatcipherai.com/zh-TW/Hash_value_test.html" title="‰∏≠ÊñáÔºàÁπÅ‰ΩìÔºâ">‰∏≠ÊñáÔºàÁπÅ‰ΩìÔºâ</a></li>
                    <li><a href="https://chatcipherai.com/ar/Hash_value_test.html" title="ÿßŸÑÿπÿ±ÿ®Ÿäÿ©">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</a></li>
                    <li><a href="https://chatcipherai.com/ru/Hash_value_test.html" title="–†—É—Å—Å–∫–∏–π">–†—É—Å—Å–∫–∏–π</a></li>
                    <li><a href="https://chatcipherai.com/pt/Hash_value_test.html" title="Portugu√™s">Portugu√™s</a></li>
                    <li><a href="https://chatcipherai.com/de/Hash_value_test.html" title="Deutsch">Deutsch</a></li>
                    <li><a href="https://chatcipherai.com/hi/Hash_value_test.html" title="‡§π‡§ø‡§®‡•ç‡§¶‡•Ä">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</a></li>
                    <li><a href="https://chatcipherai.com/nl/Hash_value_test.html" title="Nederlands">Nederlands</a></li>
                </ul> 
            </div>

            <h1>Explorador de Hash SHA-256</h1>
            <div class="style-selector">
                <button id="darkStyle">üåô Estilo Escuro(<span class="highlight-key">N</span>)</button>
                <button id="lightStyle">‚òÄ Estilo Claro(<span class="highlight-key">L</span>)</button>
            </div>
        </nav>
    </header>

    <main class="sections-container">
        <section class="section interactive-tool">
            <h2>Teste de Valor de Hash</h2>
            <p>Insira texto para visualizar o processo de convers√£o em um valor de hash em tempo real,
                <br>
                ou selecione um arquivo para calcular o valor de hash do arquivo.
            </p>
        
            <div class="input-group">
                <div>
                    <p>Gerar Valor de Hash de Texto</p>
                    <input type="text" class="input_value" id="textInput" placeholder="Insira texto" oninput="generateHash()" />
                    <button onclick="copyTextHash()">Copiar valor de hash de texto</button>
                    <div id="processOutput"></div>
                    <div id="hashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Comparar Valor de Hash de Texto</p>
                    <input type="text" class="input_value" id="hashCompareInput"
                        placeholder="Insira o valor de hash a ser usado para compara√ß√£o" />
                    <button onclick="compareTextHash()">Comparar</button>
                    <div id="textCompareResult"></div>
                </div>
            </div>
        
            <div class="input-group">
                <div>
                    <p>Gerar Valor de Hash de Arquivo</p>
                    <input type="file" id="fileInput" onchange="generateFileHash()" />
                    <button onclick="copyFileHash()">Copiar valor de hash de arquivo</button>
                    <div id="fileHashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Comparar Valor de Hash de Arquivo</p>
                    <input type="file" id="compareFileInput" onchange="compareFileHash()" />
                    <div id="fileCompareResult" class="outPut"></div>
                </div>
            </div>
        
            <div class="input-group">
                <div>
                    <p>Insira o Valor de Hash 1</p>
                    <input type="text" class="input_value" id="hashInput1" placeholder="Digite o valor de hash 1" />
                </div>
                <div>
                    <p>Insira o Valor de Hash 2</p>
                    <input type="text" class="input_value" id="hashInput2" placeholder="Digite o valor de hash 2" />
                    <button onclick="compareHashValues()">Comparar</button>
                    <div id="hashComparisonResult" class="outPut"></div>
                </div>
            </div>
        
            <button id="clearAllButton" class="clear-all-button" onclick="clearAll()">Limpar Tudo(<span class="highlight-key">A</span>)</button>
            <div class="attention">
                Lembrete gentil: Antes de inserir dados, por favor, verifique cuidadosamente a precis√£o e a sensibilidade das informa√ß√µes. Recomendamos que voc√™ fa√ßa o upload cauteloso de dados importantes, pois isso ajuda a proteger melhor sua privacidade e seguran√ßa.
            </div>
        </section>
        
        <section class="introduce">
            <p><strong><em>"Na era digital de hoje, a seguran√ßa dos dados n√£o √© apenas a pedra angular para proteger a privacidade pessoal e os segredos corporativos, mas tamb√©m a chave para manter a confian√ßa social e a estabilidade econ√¥mica."</em></strong></p>
            <div>
                <h2>O que √© um Valor de Hash?</h2>
                <p>
                    Um valor de hash √© uma cadeia ou n√∫mero de tamanho fixo gerado a partir de qualquer tamanho de dados de entrada por uma fun√ß√£o de hash. 
                    Essas fun√ß√µes aceitam entradas diversas como texto, imagens e v√≠deos, produzindo um valor de hash de comprimento fixo e irrevers√≠vel. 
                    Os valores de hash s√£o determin√≠sticos, o que significa que entradas id√™nticas sempre resultam na mesma sa√≠da. Eles tamb√©m possuem resist√™ncia a colis√µes, 
                    tornando desafiador encontrar entradas distintas que produzam a mesma sa√≠da.
                </p>
            </div>
            
            <div>
                <h2>Fun√ß√µes do Valor de Hash</h2>
                <p>
                    Os valores de hash desempenham pap√©is essenciais em toda a ci√™ncia da computa√ß√£o e tecnologia da informa√ß√£o, oferecendo um resumo de tamanho fixo dos dados, independentemente do tamanho. Essas fun√ß√µes facilitam v√°rias aplica√ß√µes:
                </p>
                <ul>
                    <li><strong>Verifica√ß√£o de Integridade de Dados:</strong> Usado para verificar se os dados permanecem inalterados durante a transmiss√£o, garantindo a integridade dos arquivos baixados.</li>
                    <li><strong>Armazenamento de Senhas:</strong> As senhas s√£o armazenadas como valores de hash para seguran√ßa, tornando dif√≠cil recuperar senhas originais de bancos de dados comprometidos.</li>
                    <li><strong>Recupera√ß√£o R√°pida de Dados:</strong> Os valores de hash atuam como √≠ndices em tabelas de hash, permitindo opera√ß√µes eficientes com dados.</li>
                    <li><strong>Deduplica√ß√£o de Dados:</strong> Ajuda na identifica√ß√£o e remo√ß√£o de itens de dados duplicados comparando valores de hash.</li>
                    <li><strong>Assinatura Digital e Verifica√ß√£o:</strong> Garante a integridade e origem dos dados por meio de criptografia de chave p√∫blica e fun√ß√µes de hash.</li>
                    <li><strong>Tecnologia Blockchain:</strong> Utiliza valores de hash para garantir registros de transa√ß√µes e garantir a imutabilidade dos dados.</li>
                    <li><strong>Carimbos de Tempo √† Prova de Manipula√ß√£o:</strong> Fornece um carimbo de tempo irrevers√≠vel para dados, √∫til em prote√ß√µes legais e de direitos autorais.</li>
                </ul>
                <p>
                    A raz√£o pela qual os valores de hash s√£o eficazes nessas √°reas √© devido √†s suas caracter√≠sticas-chave de velocidade, determinismo, irreversibilidade e resist√™ncia a colis√µes. Devidamente utilizadas, as fun√ß√µes de hash podem fornecer suporte robusto na seguran√ßa de dados, 
                    aumentando a efici√™ncia e verificando a autenticidade das informa√ß√µes.
                </p>
            </div>            

            <div>
                <h2>O que √© uma fun√ß√£o de hash?</h2>
                <p>Uma fun√ß√£o de hash √© uma constru√ß√£o matem√°tica que mapeia dados de entrada (ou "mensagem") para uma cadeia de tamanho fixo, tipicamente um valor num√©rico, conforme ilustrado no diagrama abaixo. Amplamente utilizado em gerenciamento de dados e seguran√ßa da informa√ß√£o, 
                    uma fun√ß√£o de hash √© caracterizada por sua efici√™ncia computacional, comprimento de sa√≠da consistente, irreversibilidade, sensibilidade a varia√ß√µes de entrada e resist√™ncia a colis√µes.
                </p>
                <figure>
                    <img src="./images/Hash input output.jpg" alt="Diagrama de Fluxo de Trabalho da Fun√ß√£o de Hash" />
                    <figcaption class="workflow">Diagrama de Fluxo de Trabalho da Fun√ß√£o de Hash</figcaption>
                </figure>
            </div>
            
            <div>
                <h3>Desempenho Computacional Eficiente</h3>
                <p>
                    As fun√ß√µes de hash podem calcular rapidamente valores de hash a partir de dados de qualquer forma, independentemente do tamanho dos dados. Essa caracter√≠stica √© crucial para aplica√ß√µes que requerem acesso r√°pido aos dados, como tabelas de hash. 
                    Isso ocorre porque, ao armazenar dados em tabelas de hash, a velocidade da fun√ß√£o de hash determina a velocidade de recupera√ß√£o de dados. As tabelas de hash usam fun√ß√µes de hash para localizar rapidamente o local de armazenamento dos dados, dependendo da r√°pida capacidade computacional das fun√ß√µes de hash.
                </p>
            
                <p>
                    Al√©m disso, em sistemas que precisam processar grandes quantidades de dados, a efici√™ncia das fun√ß√µes de hash impacta diretamente o desempenho geral do sistema. Se uma fun√ß√£o de hash funcionar lentamente, ela se tornar√° um gargalo no desempenho do sistema. Alguns sistemas em tempo real, 
                    como filtragem de pacotes em dispositivos de rede, exigem a computa√ß√£o imediata de valores de hash para dados tomarem decis√µes r√°pidas. Nesses casos, a efici√™ncia das fun√ß√µes de hash √© igualmente crucial.
                </p>
            
                <p>
                    Por exemplo, considere uma plataforma de com√©rcio eletr√¥nico online onde os usu√°rios podem digitar nomes de produtos na barra de pesquisa para encontrar produtos. O sistema backend pode usar fun√ß√µes de hash para localizar rapidamente informa√ß√µes de produtos armazenadas em tabelas de hash. 
                    Se o processo de c√°lculo da fun√ß√£o de hash for lento, a experi√™ncia do usu√°rio ser√° severamente afetada, pois eles ter√£o que esperar mais tempo para obter resultados de pesquisa. Nessa situa√ß√£o, o desempenho computacional eficiente das fun√ß√µes de hash garante tempos de resposta r√°pidos, melhorando assim a experi√™ncia do usu√°rio.
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent1">[Saiba mais]</a>
                </p>
            </div>
            
            <div id="moreContent1" class="moreContent" style="display:none;" style="color: #007bff; font-size: 1.0em;">
                <p>As raz√µes pelas quais as fun√ß√µes de hash podem melhorar a efici√™ncia computacional s√£o principalmente devido √†s seguintes caracter√≠sticas de design:</p>
                <ul>
                    <li><strong>Opera√ß√µes Simples:</strong> As fun√ß√µes de hash geralmente usam opera√ß√µes matem√°ticas e bitwise simples, que s√£o executadas muito rapidamente devido ao suporte direto de hardware da CPU.</li>
                    <li><strong>Avoidando Depend√™ncias de Loop:</strong> Ao evitar depend√™ncias de loop, as fun√ß√µes de hash permitem o processamento em pipeline, aumentando assim a velocidade.</li>
                    <li><strong>Processamento Paralelo:</strong> As fun√ß√µes de hash modernas s√£o projetadas para processamento paralelo, aumentando a efici√™ncia em processadores de v√°rios n√∫cleos.</li>
                    <li><strong>Tamanho de Sa√≠da Fixo:</strong> A sa√≠da de comprimento fixo simplifica a aloca√ß√£o de mem√≥ria e a compara√ß√£o de dados, melhorando o modelo de programa√ß√£o e a efici√™ncia.</li>
                    <li><strong>Pr√©-processamento e P√≥s-processamento:</strong> As fun√ß√µes de hash podem lidar com grandes dados dividindo-os em blocos, calculando valores de hash separadamente e, em seguida, combinando-os, o que aumenta a efici√™ncia.</li>
                    <li><strong>Caminhos de Algoritmo Otimizados:</strong> Reduzir o ramifica√ß√£o durante a execu√ß√£o aumenta a precis√£o da previs√£o de instru√ß√µes em CPUs, aumentando assim a velocidade.</li>
                    <li><strong>Amig√°vel ao Cache:</strong> Projetar fun√ß√µes de hash para minimizar as faltas de cache aumenta significativamente a velocidade de processamento.</li>
                    <li><strong>Otimiza√ß√£o de Hardware:</strong> Aceleradores de hardware dedicados podem aumentar significativamente a velocidade dos c√°lculos de hash, especialmente para fun√ß√µes de hash criptogr√°ficas como a s√©rie SHA.</li>
                    <li><strong>Sem Estado:</strong> As fun√ß√µes de hash n√£o mant√™m informa√ß√µes de estado, permitindo o processamento leve de cada nova entrada.</li>
                    <li><strong>Universalidade:</strong> As fun√ß√µes de hash s√£o universais para todos os tipos de dados de entrada, eliminando a necessidade de algoritmos personalizados para diferentes tipos de dados.</li>
                </ul>
            </div>
            
            <div>
                <h3>Consist√™ncia do Comprimento da Sa√≠da em Fun√ß√µes de Hash</h3>
                <p>
                    As fun√ß√µes de hash convertem entradas de qualquer comprimento em uma sa√≠da de comprimento fixo por meio de uma s√©rie complexa de c√°lculos. Esse processo frequentemente envolve dividir os dados de entrada em blocos de tamanho fixo (para entradas que excedem o tamanho da unidade de processamento), 
                    aplicar uma s√©rie de opera√ß√µes matem√°ticas e l√≥gicas a cada bloco e, em seguida, combinar ou acumular os resultados dessas opera√ß√µes de alguma forma para produzir um valor de hash de tamanho fixo.
                </p>
                <p>
                    <strong>Por que √© importante?</strong>
                    A consist√™ncia do comprimento da sa√≠da ajuda a garantir a seguran√ßa das fun√ß√µes de hash. Se o comprimento da sa√≠da do hash pudesse variar, isso poderia vazar informa√ß√µes sobre o tamanho dos dados originais, o que poderia ser potencialmente explorado para atacar o sistema em alguns cen√°rios. 
                    Al√©m disso, um comprimento de sa√≠da fixo tamb√©m dificulta que os atacantes inferem caracter√≠sticas dos dados de entrada analisando o comprimento da sa√≠da. Ao mesmo tempo, as sa√≠das de comprimento fixo simplificam o armazenamento e a compara√ß√£o de valores de hash. 
                    Os projetistas de sistemas podem saber com anteced√™ncia quanto espa√ßo cada valor de hash ocupar√°, o que √© muito importante para cen√°rios como design de banco de dados e transmiss√£o de rede. Al√©m disso, a consist√™ncia do comprimento da sa√≠da torna-se muito eficiente para comparar se os valores de hash s√£o iguais, 
                    pois requer apenas a compara√ß√£o de dados de um comprimento fixo. Isso √© particularmente importante ao usar tabelas de hash para recupera√ß√£o r√°pida de dados.
                </p>
                <p>
                    Tomando SHA-256 como exemplo, esta fun√ß√£o de hash criptogr√°fica amplamente utilizada sempre produz um valor de hash de 256 bits (ou seja, 32 bytes), independentemente se os dados de entrada s√£o um √∫nico byte ou v√°rios milh√µes de bytes. Essa consist√™ncia garante que os valores de hash SHA-256 possam ser usados para v√°rias aplica√ß√µes de seguran√ßa, 
                    como assinaturas digitais e C√≥digos de Autentica√ß√£o de Mensagem (MACs), ao mesmo tempo que simplifica o fluxo de trabalho de processamento e armazenamento de dados.
                </p>
            </div>
            
            <div>
                <h3>Irreversibilidade das Fun√ß√µes de Hash</h3>
                <p>
                    As fun√ß√µes de hash s√£o unidirecionais, o que significa que √© imposs√≠vel inferir os dados originais a partir do valor de hash. Esta caracter√≠stica √© particularmente importante ao armazenar senhas, pois mesmo que o banco de dados seja comprometido, os atacantes n√£o podem recuperar as senhas a partir dos valores de hash. 
                    A irreversibilidade das fun√ß√µes de hash baseia-se principalmente nos seguintes princ√≠pios e caracter√≠sticas:
                </p>
                <ul>
                    <li><strong>Compress√£o:</strong> As fun√ß√µes de hash podem mapear entradas de qualquer tamanho (que podem ser muito grandes em uso pr√°tico) para uma sa√≠da de tamanho fixo. Isso significa que h√° infinitamente muitas entradas poss√≠veis mapeadas para um n√∫mero finito de sa√≠das. Como o espa√ßo de sa√≠da (valores de hash) √© muito menor que o espa√ßo de entrada, diferentes entradas inevitavelmente produzir√£o a mesma sa√≠da, um fen√¥meno conhecido como "colis√£o". Devido a essa compress√£o, √© imposs√≠vel determinar a entrada espec√≠fica a partir de uma sa√≠da dada (valor de hash).</li>
                    <li><strong>Alta N√£o-linearidade e Complexidade:</strong> As fun√ß√µes de hash s√£o projetadas usando opera√ß√µes matem√°ticas e l√≥gicas complexas (como opera√ß√µes bitwise, opera√ß√µes de m√≥dulo, etc.), para garantir que a sa√≠da seja altamente sens√≠vel √† entrada. Mesmo pequenas altera√ß√µes na entrada (por exemplo, mudar um bit) podem causar mudan√ßas significativas e imprevis√≠veis na sa√≠da (valor de hash). Esse alto grau de n√£o-linearidade e a aleatoriedade da sa√≠da tornam extremamente dif√≠cil deduzir a entrada original a partir do valor de hash.</li>
                    <li><strong>Unidirecionalidade:</strong> O design das fun√ß√µes de hash garante que sua opera√ß√£o seja unidirecional; ou seja, enquanto calcular o valor de hash √© f√°cil, o processo reverso (recuperar os dados originais a partir do valor de hash) n√£o √© vi√°vel. Isso ocorre porque o processo de computa√ß√£o de fun√ß√µes de hash envolve uma s√©rie de opera√ß√µes irrevers√≠veis (como a irreversibilidade de opera√ß√µes de m√≥dulo), garantindo que mesmo com o valor de hash, seja imposs√≠vel engenharia reversa dos dados originais.</li>
                    <li><strong>Mapeamento Aleat√≥rio:</strong> Uma fun√ß√£o de hash ideal deve atuar como um "mapeador aleat√≥rio", o que significa que toda entrada poss√≠vel tem a mesma probabilidade de ser mapeada para qualquer ponto no espa√ßo de sa√≠da. Essa propriedade garante que n√£o h√° maneira vi√°vel de prever para qual sa√≠da uma entrada espec√≠fica ser√° mapeada, aumentando a irreversibilidade da fun√ß√£o de hash.</li>
                    <li><strong>Funda√ß√£o Matem√°tica:</strong> Matematicamente, a irreversibilidade das fun√ß√µes de hash pode ser entendida atrav√©s de sua depend√™ncia em "problemas de logaritmo discreto", "problemas de fatora√ß√£o de inteiros grandes" ou outros problemas de teoria dos n√∫meros que s√£o dif√≠ceis de resolver com as capacidades matem√°ticas e computacionais atuais. Por exemplo, o design de alguns algoritmos de hash pode depender indiretamente da dificuldade computacional desses problemas, garantindo assim sua irreversibilidade.</li>
                </ul>
                <figure>
                    <img src="./images/Irreversibility.jpg" alt="Irreversibilidade das Fun√ß√µes de Hash" />
                    <figcaption class="Irreversibility">Irreversibilidade das Fun√ß√µes de Hash</figcaption>
                </figure>
            </div>
            
            <div>
                <h3>Sensibilidade √† Entrada e o Efeito Avalanche</h3>
                <p>
                    No design das fun√ß√µes de hash, opera√ß√µes matem√°ticas e l√≥gicas complexas (como opera√ß√µes bitwise, opera√ß√µes de m√≥dulo, etc.) s√£o utilizadas para garantir que a sa√≠da seja altamente sens√≠vel √† entrada. 
                    Mesmo pequenas altera√ß√µes na entrada (por exemplo, mudar um √∫nico bit) resultar√£o em mudan√ßas significativas e imprevis√≠veis na sa√≠da (o valor de hash), um fen√¥meno conhecido como "efeito avalanche".
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent2">[Saiba Mais]</a>
                </p>
            </div>
            
            <div id="moreContent2" class="moreContent" style="display:none;">
                <p>O <a href="https://en.wikipedia.org/wiki/Avalanche_effect" target="_blank" rel="noopener noreferrer" style="color: #007bff; font-size: 1.0em;">efeito avalanche</a> pode ter diferentes interpreta√ß√µes em v√°rios campos:</p>
                <ul>
                    <li><strong>Em criptografia: </strong> O efeito avalanche √© uma propriedade desej√°vel de algoritmos de criptografia (especialmente cifras de bloco e fun√ß√µes de hash criptogr√°ficas). Ele ocorre quando a menor mudan√ßa na entrada (por exemplo, inverter um bit bin√°rio) leva a mudan√ßas indistingu√≠veis na sa√≠da (com uma probabilidade de 50% de inverter cada bit bin√°rio na sa√≠da). Esse atributo ajuda a melhorar a seguran√ßa da criptografia porque mudan√ßas significativas na sa√≠da podem ocorrer mesmo com pequenas mudan√ßas na entrada, tornando mais dif√≠cil quebrar a criptografia analisando a rela√ß√£o entre entrada e sa√≠da.</li>
                    <li><strong>Nos neg√≥cios e na tecnologia: </strong> O efeito avalanche refere-se ao fen√¥meno em que uma energia significativa pode ser liberada desmontando e recombinando adequadamente a estrutura e o sistema inerentes aos neg√≥cios e √† tecnologia. Essa energia pode destruir sistemas industriais antigos como uma avalanche, ou at√© mesmo fazer uma ind√∫stria inteira desaparecer. Sob a imensa press√£o da avalanche, a conex√£o inerente entre neg√≥cios e tecnologia √© completamente interrompida, exigindo a aceita√ß√£o de novas transforma√ß√µes e integra√ß√µes. Esse efeito acaba desencadeando uma s√©rie de inova√ß√µes revolucion√°rias.</li>
                    <li><strong>Na arquitetura de microsservi√ßos: </strong> O efeito avalanche descreve o cen√°rio em que, devido √†s depend√™ncias entre servi√ßos, uma falha ou indisponibilidade em um servi√ßo pode se propagar pela cadeia de chamadas, levando √† paralisia de todo o sistema. As causas do efeito avalanche podem incluir falhas de hardware, picos de tr√°fego, penetra√ß√£o de cache, bugs de programa e bloqueios do JVM, entre outros.</li>
                    <li><strong>No mundo natural: </strong> O efeito avalanche refere-se ao fen√¥meno em que uma pequena pedra rolando por uma montanha de neve pode desencadear uma avalanche. Isso ocorre porque o impacto da pequena pedra faz com que as camadas de neve ao redor se soltem e deslizem, levando a uma avalanche em maior escala. Esse fen√¥meno tamb√©m pode descrever metaforicamente como eventos ou fatores menores podem desencadear rea√ß√µes em cadeia massivas.</li>
                </ul>
            </div>
            
            <div>
                <h3>Resist√™ncia a Colis√µes em Criptografia</h3>
                <p>
                    A resist√™ncia a colis√µes de uma fun√ß√£o de hash √© um conceito crucial em criptografia, indicando o n√≠vel de seguran√ßa de uma fun√ß√£o de hash contra ataques de colis√£o. Essa propriedade implica que, para qualquer fun√ß√£o de hash <strong>H</strong>, encontrar duas entradas distintas <strong>x</strong> e <strong>y</strong> (<strong>x ‚â† y</strong>) tal que <strong>H(x) = H(y)</strong> √© computacionalmente invi√°vel. Uma fun√ß√£o de hash com robusta resist√™ncia a colis√µes torna extremamente desafiador encontrar duas entradas diferentes que levem ao mesmo valor de sa√≠da.
                </p>
                <figure>
                    <img src="./images/Collision Resistance.jpg" alt="Ilustra√ß√£o da Resist√™ncia √† Colis√£o">
                    <figcaption class="Resistance">Ilustra√ß√£o da Resist√™ncia √† Colis√£o</figcaption>
                </figure>
                <p>
                    A resist√™ncia a colis√µes desempenha um papel vital na manuten√ß√£o da integridade e verifica√ß√£o dos dados. Ao transformar informa√ß√µes de entrada em uma sa√≠da de tamanho fixo (ou resumo), as fun√ß√µes de hash garantem que duas entradas diferentes n√£o produzam a mesma sa√≠da. Essa caracter√≠stica √∫nica permite que o valor de hash identifique com precis√£o o valor original.
                </p>
                <p>
                    Durante a cria√ß√£o ou armazenamento de dados, um valor de hash (ou resumo) √© gerado usando uma fun√ß√£o de hash. Este valor √© armazenado ou transmitido juntamente com os dados originais. Por exemplo, sites de download de software frequentemente exibem valores de hash de arquivos para verifica√ß√£o de integridade. Os destinat√°rios podem recalcular independentemente o valor de hash dos dados recebidos para confirmar sua integridade. Se os valores de hash original e recalculado coincidirem, a integridade dos dados √© verificada. Caso contr√°rio, os dados podem ter sido adulterados ou corrompidos durante a transmiss√£o ou armazenamento.
                </p>
                <p>
                    Comparar valores de hash tamb√©m oferece a vantagem de verificar a integridade dos dados sem exigir espa√ßo de armazenamento significativo. Este m√©todo permite que os destinat√°rios confirmem a autenticidade dos dados simplesmente comparando os valores de hash antes e ap√≥s a transmiss√£o.
                </p>
                <figure>
                    <img src="./images/Compare Hash.jpg" alt="Processo de Compara√ß√£o de Valores de Hash">
                    <figcaption class="Compare">Processo de Compara√ß√£o de Valores de Hash</figcaption>
                </figure>
            </div>
            
            <div>
                <h2>√â poss√≠vel encontrar colis√µes de hash?</h2>
                <p>
                    Atrav√©s das caracter√≠sticas das fun√ß√µes de hash mencionadas acima, compreendemos a resist√™ncia a colis√µes. Mas √© poss√≠vel que colis√µes de hash existam, ou seja, que duas entradas diferentes produzam a mesma sa√≠da? 
                    A resposta √© afirmativa, colis√µes realmente existem. De acordo com o <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank" style="color: #007bff; font-size: 1.0em;">princ√≠pio da gaveta de pombos</a>, enquanto o espa√ßo de entrada for suficientemente grande, h√° uma possibilidade de colis√µes de hash. 
                    Isso ocorre porque o espa√ßo de sa√≠da das fun√ß√µes de hash geralmente √© muito menor que o espa√ßo de entrada, levando inevitavelmente a m√∫ltiplas entradas diferentes mapeadas para a mesma sa√≠da.
                </p>
                
                <p>
                    O princ√≠pio da gaveta de pombos √© um princ√≠pio simples e intuitivo da matem√°tica combinat√≥ria, afirmando que se mais do que n objetos forem colocados em n cont√™ineres, ent√£o pelo menos um cont√™iner conter√° dois ou mais objetos. 
                    Este princ√≠pio tamb√©m pode ser usado para explicar problemas como o paradoxo do anivers√°rio.
                </p>
                <p>
                    A aplica√ß√£o do princ√≠pio da gaveta de pombos √© muito ampla, com usos importantes em campos como criptografia, ci√™ncia da computa√ß√£o e matem√°tica. Por exemplo, em ci√™ncia da computa√ß√£o, o princ√≠pio da gaveta de pombos √© usado para provar a corre√ß√£o de certos algoritmos ou para analisar a complexidade temporal de algoritmos. 
                    Na criptografia, o princ√≠pio da gaveta de pombos tamb√©m √© usado para projetar certos m√©todos de ataque criptogr√°fico, como o ataque do anivers√°rio.
                </p>
                <p>
                    O paradoxo do anivers√°rio √© uma aplica√ß√£o cl√°ssica do princ√≠pio da gaveta de pombos. Suponha que haja n pessoas em uma sala. 
                    Se quisermos que a probabilidade de pelo menos duas pessoas compartilharem o mesmo anivers√°rio seja maior que 50%, quantas pessoas s√£o necess√°rias? De acordo com o princ√≠pio da gaveta de pombos, 
                    se 367 pessoas (assumindo que existam 366 dias em um ano, mais um dia extra para 29 de fevereiro em um ano bissexto) forem colocadas em 366 "gavetas de pombos" (ou seja, anivers√°rios), ent√£o pelo menos uma "gaveta de pombos" conter√° duas pessoas, significando que pelo menos duas pessoas compartilham o mesmo anivers√°rio. Isso ilustra o paradoxo do anivers√°rio.
                </p>
                <p>
                    √â importante observar que, embora o princ√≠pio da gaveta de pombos seja simples e intuitivo, sua aplica√ß√£o deve considerar o contexto espec√≠fico. 
                    Por exemplo, ao aplicar o princ√≠pio da gaveta de pombos, √© necess√°rio garantir que as vari√°veis aleat√≥rias envolvidas sejam independentes entre si; caso contr√°rio, pode levar a conclus√µes incorretas. Al√©m disso, em alguns casos, tamb√©m √© necess√°rio considerar fatores como o tamanho e a forma das gavetas de pombos.
                </p>
            </div>
            
            <div>
                <p>
                    No entanto, tentar encontrar colis√µes de hash simplesmente percorrendo o espa√ßo de entrada pode n√£o ser pr√°tico, principalmente por duas raz√µes:
                </p>
                <ul>
                    <li><strong>Complexidade computacional: </strong> Para a maioria das fun√ß√µes de hash, o espa√ßo de entrada √© vasto. Tome SHA-256 como exemplo; sua sa√≠da √© um valor de hash de 256 bits, o que significa que possui 2^256 sa√≠das poss√≠veis. Uma vez que um dos objetivos de design das fun√ß√µes de hash √© minimizar as colis√µes tanto quanto poss√≠vel, teoricamente, 
                            encontrar uma colis√£o de hash para SHA-256 exigiria percorrer cerca de 2^(256/2) = 2^128 entradas, de acordo com o paradoxo do anivers√°rio, que √© o n√∫mero aproximado esperado de entradas para encontrar uma colis√£o. Mesmo com os supercomputadores mais poderosos atualmente dispon√≠veis, levaria muito al√©m de uma vida humana para concluir uma tarefa dessas. 
                            tornando considerado imposs√≠vel encontrar uma colis√£o de hash SHA-256 atrav√©s de uma simples travessia.</li>
                    <li><strong>Design de fun√ß√µes de hash: </strong> As fun√ß√µes de hash geralmente s√£o projetadas para tornar a descoberta de colis√µes computacionalmente invi√°vel. Isso significa que, embora as colis√µes teoricamente existam, elas s√£o praticamente imposs√≠veis de encontrar na pr√°tica. Esta √© uma caracter√≠stica importante das fun√ß√µes de hash criptogr√°ficas (como SHA-256), 
                            que s√£o amplamente utilizadas em √°reas como assinaturas digitais, armazenamento de senhas e outros.</li>
                </ul>
                <p>
                    Claro, tamb√©m podemos usar algoritmos espec√≠ficos para tentar encontrar colis√µes de hash. Esses algoritmos frequentemente exploram algumas propriedades ou fraquezas conhecidas das fun√ß√µes de hash para encontrar colis√µes. Aqui est√£o algumas t√©cnicas e m√©todos comuns para encontrar colis√µes de hash:
                </p>
                <ul>
                    <li><strong>Ataque do Anivers√°rio: </strong> Este √© um m√©todo simples baseado em probabilidade usado para estimar o tempo necess√°rio para encontrar uma colis√£o quando as entradas s√£o escolhidas aleatoriamente. O princ√≠pio do ataque do anivers√°rio √© que se houver muitas pessoas em uma sala, a probabilidade de duas pessoas terem o mesmo anivers√°rio aumenta com o n√∫mero de pessoas. 
                            Da mesma forma, em fun√ß√µes de hash, se um n√∫mero suficiente de entradas for selecionado aleatoriamente, √© prov√°vel que duas entradas eventualmente produzam a mesma sa√≠da de hash.</li>
                    <li><strong>Ataque de For√ßa Bruta: </strong> Este √© o m√©todo mais direto, que envolve percorrer todas as entradas poss√≠veis para encontrar uma colis√£o. No entanto, este m√©todo √© impratic√°vel para fun√ß√µes de hash com grandes espa√ßos de entrada devido aos enormes recursos computacionais e tempo necess√°rios.</li>
                    <li><strong>Tabelas Arco-√çris:</strong> Esta t√©cnica √© usada para pr√©-calcular e armazenar um grande n√∫mero de valores de hash e suas entradas correspondentes. As tabelas arco-√≠ris s√£o especialmente √∫teis para quebrar senhas que n√£o utilizaram ofusca√ß√£o de dados aleat√≥rios ou t√™m uma fun√ß√£o de hash conhecida. Ao procurar na tabela arco-√≠ris, um atacante pode rapidamente encontrar uma entrada que corresponda a um valor de hash espec√≠fico.</li>
                    <li><strong>Ataques de Extens√£o de Hash: </strong> Certas fun√ß√µes de hash permitem que os atacantes combinem dados adicionais com um valor de hash conhecido sem conhecer a entrada original, gerando assim um novo valor de hash. Este ataque pode ser usado para construir colis√µes ou realizar outros tipos de ataques.</li>
                    <li><strong>Entradas Especialmente Constru√≠das: </strong> √Äs vezes, os atacantes podem explorar fraquezas espec√≠ficas ou comportamentos n√£o lineares em fun√ß√µes de hash para construir entradas especiais que s√£o mais propensas a produzir colis√µes na fun√ß√£o de hash.</li>
                </ul>                
            </div>

            <div>
                <h2>Quais s√£o as fun√ß√µes de hash comumente usadas?</h2>
                <h3>MD5 (Message Digest Algorithm 5)</h3>
                <p>
                    MD5 √© uma fun√ß√£o de hash criptogr√°fica amplamente utilizada, projetada por Ronald Rivest na d√©cada de 1990 para substituir o antigo algoritmo MD4. Ele pode converter uma mensagem de qualquer comprimento em um valor de hash de comprimento fixo (128 bits, ou 16 bytes). 
                    O objetivo de design do MD5 era fornecer uma maneira r√°pida e relativamente segura de gerar uma impress√£o digital digital de dados. No entanto, foram descobertos m√©todos de colis√£o para <a href="https://en.wikipedia.org/wiki/MD5" target="_blank" style="color: #007bff; font-size: 1.0em;"> MD5 </a>, tornando o algoritmo inseguro, mas ainda amplamente utilizado em situa√ß√µes onde a seguran√ßa n√£o √© uma preocupa√ß√£o prim√°ria.
                <br>
                <br>O processo de c√°lculo do MD5 envolve as seguintes etapas:
                </p>
                <ul>
                    <li><strong>Preenchimento: </strong> Inicialmente, os dados originais s√£o preenchidos para que seu comprimento em bytes seja um m√∫ltiplo de 512. O preenchimento come√ßa com um 1, seguido de 0s at√© que o requisito de comprimento seja atendido.</li>
                    <li><strong>Adi√ß√£o de Comprimento: </strong> Um valor de comprimento de 64 bits, que √© a representa√ß√£o bin√°ria do comprimento da mensagem original, √© adicionado √† mensagem preenchida, tornando o comprimento final da mensagem um m√∫ltiplo de 512 bits.</li>
                    <li><strong>Inicializa√ß√£o do Buffer MD: </strong> Quatro registradores de 32 bits (A, B, C, D) s√£o inicializados para armazenar os valores de hash intermedi√°rios e finais.</li> 
                    <li><strong>Processamento de Blocos de Mensagem: </strong> A mensagem preenchida e processada em termos de comprimento √© dividida em blocos de 512 bits, e cada bloco √© processado atrav√©s de quatro rodadas de opera√ß√£o. Cada rodada inclui 16 opera√ß√µes semelhantes baseadas em fun√ß√µes n√£o lineares (F, G, H, I), opera√ß√µes de deslocamento circular √† esquerda e adi√ß√£o m√≥dulo 32.</li> 
                    <li><strong>Sa√≠da: </strong> O valor de hash final √© o conte√∫do do √∫ltimo estado dos quatro registradores A, B, C, D concatenados juntos (cada registro tem 32 bits), formando um valor de hash de 128 bits.</li> 
                </ul>
                
                <h3>SHA-1 (Secure Hash Algorithm 1)</h3>
                <p>
                    SHA-1 foi projetado pela Ag√™ncia de Seguran√ßa Nacional dos Estados Unidos (NSA) e lan√ßado como um Padr√£o de Processamento de Informa√ß√µes Federais (FIPS PUB 180-1) pelo Instituto Nacional de Padr√µes e Tecnologia (NIST) em 1995. 
                    SHA-1 destina-se a ser utilizado em assinaturas digitais e outras aplica√ß√µes criptogr√°ficas, gerando um valor de hash de 160 bits (20 bytes) conhecido como digest de mensagem. Embora seja agora conhecido que <a href="https://en.wikipedia.org/wiki/SHA-1" target="_blank" style="color: #007bff; font-size: 1.0em;"> SHA-1 </a> tem vulnerabilidades de seguran√ßa e foi substitu√≠do por algoritmos mais seguros como SHA-256 e SHA-3, 
                    entender seu princ√≠pio de funcionamento ainda possui valor educacional e hist√≥rico.
                <br>
                <br>O prop√≥sito de design do SHA-1 √© pegar uma mensagem de comprimento arbitr√°rio e produzir um digest de mensagem de 160 bits para verificar a integridade dos dados. Seu processo de computa√ß√£o pode ser dividido nas seguintes etapas:
                </p>
                <ul>
                    <li><strong>Preenchimento: </strong> Inicialmente, a mensagem original √© preenchida para que seu comprimento (em bits) m√≥dulo 512 seja igual a 448. O preenchimento sempre come√ßa com um bit "1", seguido por v√°rios bits "0", at√© que a condi√ß√£o de comprimento acima seja atendida.</li>
                    <li><strong>Adi√ß√£o de Comprimento: </strong> Um bloco de 64 bits √© adicionado √† mensagem preenchida, representando o comprimento da mensagem original (em bits), tornando o comprimento final da mensagem um m√∫ltiplo de 512 bits.</li>
                    <li><strong>Inicializa√ß√£o do Buffer: </strong> O algoritmo SHA-1 usa um buffer de 160 bits, dividido em cinco registradores de 32 bits (A, B, C, D, E), para armazenar os valores de hash intermedi√°rios e finais. Esses registradores s√£o inicializados com valores constantes espec√≠ficos no in√≠cio do algoritmo.</li>
                    <li><strong>Processamento de Blocos de Mensagem: </strong> A mensagem pr√©-processada √© dividida em blocos de 512 bits. Para cada bloco, o algoritmo executa um loop principal contendo 80 etapas semelhantes. Essas 80 etapas s√£o divididas em quatro rodadas, cada uma com 20 etapas. Cada etapa usa uma fun√ß√£o n√£o linear diferente (F, G, H, I) e uma constante (K). Essas fun√ß√µes s√£o projetadas para aumentar a complexidade e seguran√ßa das opera√ß√µes. Nestas etapas, o algoritmo usa opera√ß√µes bitwise (como AND, OR, XOR, NOT) e adi√ß√£o m√≥dulo 32, bem como deslocamentos circulares √† esquerda.</li>
                    <li><strong>Sa√≠da: </strong> Ap√≥s processar todos os blocos, os valores acumulados nos cinco registradores s√£o concatenados para formar o valor de hash final de 160 bits.</li>
                </ul>
                
                <h3>SHA-2 (Secure Hash Algorithm 2)</h3>
                <p>
                    SHA-2 √© uma fam√≠lia de fun√ß√µes de hash criptogr√°ficas, incluindo v√°rias vers√µes diferentes, consistindo principalmente de seis variantes: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 e SHA-512/256. 
                    SHA-2 foi projetado pela Ag√™ncia de Seguran√ßa Nacional dos Estados Unidos (NSA) e publicado como um Padr√£o Federal de Processamento de Informa√ß√µes (FIPS) pelo Instituto Nacional de Padr√µes e Tecnologia (NIST). Comparado ao seu antecessor, SHA-1, SHA-2 oferece seguran√ßa aprimorada, principalmente refletida em valores de hash mais longos e maior resist√™ncia a ataques de colis√£o.
                <br>
                <br>O funcionamento da fam√≠lia <a href="https://en.wikipedia.org/wiki/SHA-2" rel="noopener noreferrer" target="_blank" style="color: #007bff; font-size: 1.0em;">SHA-2</a> √© semelhante ao SHA-1 em muitos aspectos, mas fornece maior seguran√ßa atrav√©s do uso de valores de hash mais longos e um procedimento de processamento mais complexo. Aqui est√£o as principais etapas do algoritmo SHA-2:
                </p>
                <ul>
                    <li><strong>Preenchimento: </strong> A mensagem de entrada √© primeiro preenchida para que seu comprimento, menos 64 bits, seja igual a 448 ou 896 em uma base m√≥dulo 512 (para SHA-224 e SHA-256) ou m√≥dulo 1024 (para SHA-384 e SHA-512). O m√©todo de preenchimento √© o mesmo que o SHA-1, que envolve adicionar um "1" no final da mensagem, seguido por v√°rios "0"s, e finalmente uma representa√ß√£o bin√°ria de 64 bits (para SHA-224 e SHA-256) ou 128 bits (para SHA-384 e SHA-512) do comprimento original da mensagem em bits.</li>
                    <li><strong>Inicializa√ß√£o do Buffer: </strong> O algoritmo SHA-2 usa um conjunto de valores de hash inicializados como o buffer de in√≠cio, dependendo da variante SHA-2 escolhida. Por exemplo, SHA-256 usa oito registradores de 32 bits, enquanto SHA-512 usa oito registradores de 64 bits. Esses registradores s√£o inicializados com valores constantes espec√≠ficos.</li>
                    <li><strong>Processamento de Blocos de Mensagem: </strong> A mensagem preenchida √© dividida em blocos de 512 ou 1024 bits, e cada bloco passa por m√∫ltiplas rodadas de opera√ß√µes criptogr√°ficas. SHA-256 e SHA-224 realizam 64 rodadas de opera√ß√µes, enquanto SHA-512, SHA-384, SHA-512/224 e SHA-512/256 realizam 80 rodadas. Cada rodada de opera√ß√£o inclui uma s√©rie de opera√ß√µes bitwise complexas, incluindo opera√ß√µes l√≥gicas, adi√ß√£o modular e condicional, baseadas em diferentes fun√ß√µes n√£o lineares e constantes predefinidas. Essas opera√ß√µes aumentam a complexidade e a seguran√ßa do algoritmo.</li>
                    <li><strong>Sa√≠da: </strong> Finalmente, ap√≥s processar todos os blocos, os valores no buffer s√£o combinados para formar o valor de hash final. Dependendo da variante SHA-2, este valor de hash pode ter 224, 256, 384 ou 512 bits de comprimento.</li>
                </ul>
                <P>
                    Voc√™ pode estar curioso para saber por que a entrada para uma fun√ß√£o de hash pode ter um comprimento arbitr√°rio, mas a sa√≠da √© fixa. A raz√£o √© que a fam√≠lia SHA-2 usa a transforma√ß√£o Merkle-Damg√•rd, que permite a constru√ß√£o de fun√ß√µes de hash que podem processar mensagens de qualquer comprimento a partir de uma fun√ß√£o de compress√£o de comprimento fixo. A transforma√ß√£o Merkle-Damg√•rd √© adotada em muitas fun√ß√µes de hash tradicionais, incluindo MD5 e SHA-1.
                </P>
                <p>
                    A ideia central da transforma√ß√£o Merkle-Damg√•rd √© dividir a mensagem de entrada em blocos de tamanho fixo e, em seguida, processar esses blocos um por um, com cada etapa de processamento dependendo do resultado da anterior, produzindo finalmente um valor de hash de tamanho fixo. A etapa de preenchimento do SHA-256 incorpora os princ√≠pios b√°sicos da transforma√ß√£o Merkle-Damg√•rd, ou seja, preenchendo adequadamente para processar mensagens de qualquer comprimento e garantindo que o comprimento da mensagem processada final atenda a certas condi√ß√µes (como ser um m√∫ltiplo de um comprimento fixo). Portanto, pode-se dizer que a etapa de preenchimento do SHA-256 segue o m√©todo de transforma√ß√£o Merkle-Damg√•rd.
                </p>
                <figure>
                    <img src="./images/Merkle-Damg√•rd Padding.jpg" alt="Princ√≠pio de preenchimento Merkle-Damg√•rd">
                    <figcaption class="Merkle-Damg√•rd">Princ√≠pio de preenchimento Merkle-Damg√•rd</figcaption>
                </figure>
                <p>
                    No entanto, o SHA-256 n√£o √© apenas uma implementa√ß√£o direta da transforma√ß√£o Merkle-Damg√•rd. Ele tamb√©m inclui uma s√©rie de etapas computacionais complexas (como expans√£o de mensagem, m√∫ltiplas rodadas de fun√ß√µes de compress√£o, etc.), que s√£o designs exclusivos do SHA-256, com o objetivo de melhorar sua seguran√ßa. Portanto, embora o SHA-256 siga os princ√≠pios da transforma√ß√£o Merkle-Damg√•rd em sua etapa de preenchimento, ele aumenta a seguran√ßa geral introduzindo outros mecanismos de seguran√ßa, tornando-o n√£o apenas limitado ao esquema b√°sico da transforma√ß√£o Merkle-Damg√•rd.
                </p>
                
                <h3>SHA-3 (Secure Hash Algorithm 3) </h3>
                <p>
                    SHA-3 √© o mais recente padr√£o de hash seguro, oficialmente aprovado pelo Instituto Nacional de Padr√µes e Tecnologia (NIST) em 2015 como um Padr√£o Federal de Processamento de Informa√ß√µes (FIPS 202). SHA-3 n√£o se destina a substituir o SHA-1 ou SHA-2 anteriores (j√° que o SHA-2 ainda √© considerado seguro), 
                    mas sim complementar e oferecer uma op√ß√£o alternativa dentro da fam√≠lia SHA, fornecendo um algoritmo de hash criptogr√°fico diferente. SHA-3 √© baseado no algoritmo Keccak, projetado por Guido Bertoni e outros, e foi o vencedor da competi√ß√£o SHA-3 realizada pelo NIST em 2012.
                <br>
                <br>O princ√≠pio de funcionamento do SHA-3 difere significativamente do SHA-2, principalmente porque utiliza um m√©todo conhecido como "<strong>constru√ß√£o de esponja</strong>" para absorver e espremer dados, produzindo o valor de hash final. Este m√©todo permite ao SHA-3 produzir flexivelmente valores de hash de diferentes comprimentos, oferecendo assim uma gama mais ampla de aplica√ß√µes do que o SHA-2. As principais etapas do SHA-3 s√£o as seguintes:
                </p>
                <figure>
                    <img src="./images/sponge construction.jpg" alt="Diagrama Esquem√°tico da Constru√ß√£o Esponja">
                    <figcaption class="sponge">Diagrama Esquem√°tico da Constru√ß√£o Esponja</figcaption>
                </figure>
                <h4>Fase de absor√ß√£o: </h4>
                <p>
                    Na fase de absor√ß√£o, a estrutura de esponja divide primeiro os dados de entrada em blocos de tamanho fixo. Esses blocos de dados s√£o "absorvidos" sequencialmente no estado interno da esponja, que √© tipicamente maior do que um √∫nico bloco de dados, para garantir que uma grande quantidade de dados possa ser processada sem transbordamento. 
                    Especificamente, cada bloco de dados √© mesclado com uma parte do estado interno de alguma maneira (como por uma opera√ß√£o XOR), seguido pela aplica√ß√£o de uma fun√ß√£o de permuta√ß√£o fixa (no SHA-3, isso √© <a href="https://en.wikipedia.org/wiki/SHA-3" target="_blank" style="color: #007bff; font-size: 1.0em;">Keccak-f</a>) para transformar o estado inteiro, evitando assim a interfer√™ncia entre diferentes blocos de dados de entrada. Esse processo √© repetido at√© que todos os blocos de dados de entrada tenham sido processados.
                </p>
                <p>
                    Keccak-f √© a fun√ß√£o de permuta√ß√£o central usada no algoritmo de hash criptogr√°fico SHA-3. √â um componente central da fam√≠lia de algoritmos Keccak. O SHA-3 √© baseado no algoritmo Keccak, que venceu a competi√ß√£o de algoritmos de hash criptogr√°fico realizada pelo NIST e foi selecionado como o padr√£o para o SHA-3. A fun√ß√£o Keccak-f tem v√°rias variantes, 
                    sendo a mais comumente usada a Keccak-f[1600], onde o n√∫mero indica a largura de bits em que opera. 
                </p>
                <p>
                    Keccak-f √© composto por v√°rias rodadas da mesma opera√ß√£o (chamadas de rodadas). Para Keccak-f[1600], h√° um total de 24 rodadas de opera√ß√µes. Cada rodada inclui cinco etapas b√°sicas: <em>Œ∏ (Theta), œÅ (Rho), œÄ (Pi), œá (Chi) e Œπ (Iota)</em>. Essas etapas atuam em conjunto no array de estado, transformando gradualmente seu conte√∫do, 
                    aumentando a confus√£o e a difus√£o para aumentar a seguran√ßa. Abaixo est√° uma breve descri√ß√£o dessas etapas:
                </p>
                <ul>
                    <li><strong>Etapa Œ∏ (Theta): </strong> Realiza opera√ß√µes XOR em todos os bits de cada coluna, em seguida, XORs o resultado em colunas adjacentes, fornecendo difus√£o entre colunas.</li>
                    <li><strong>Etapa œÅ (Rho): </strong> Opera√ß√£o de rota√ß√£o de bits, onde cada bit √© rotacionado um n√∫mero diferente de bits de acordo com regras predeterminadas, aumentando a complexidade dos dados.</li>
                    <li><strong>Etapa œÄ (Pi): </strong> Rearranja os bits no array de estado, mudando a posi√ß√£o dos bits para alcan√ßar difus√£o entre linhas e colunas.</li>
                    <li><strong>Etapa œá (Chi): </strong> Uma etapa n√£o linear que realiza opera√ß√µes XOR em cada bit de cada linha, incluindo ele mesmo, seu vizinho imediato e o complemento do vizinho. Esta √© uma opera√ß√£o local que aumenta as caracter√≠sticas n√£o lineares do algoritmo criptogr√°fico.</li>
                    <li><strong>Etapa Œπ (Iota): </strong> Introduz uma constante de rodada em parte do array de estado, com a constante diferindo em cada rodada, para evitar que todas as rodadas operem de forma id√™ntica, introduzindo imprevisibilidade.</li>
                </ul>
                <p>
                    Keccak-f fornece um alto n√≠vel de seguran√ßa atrav√©s dessas etapas. Seu design garante que mesmo mudan√ßas m√≠nimas na entrada levem a mudan√ßas generalizadas e imprevis√≠veis no array de estado, alcan√ßado atrav√©s dos princ√≠pios de confus√£o (tornando dif√≠cil para os atacantes inferir a entrada a partir da sa√≠da) e difus√£o (onde mudan√ßas m√≠nimas na entrada afetam v√°rias partes da sa√≠da).
                </p>
                <p>
                    O design de Keccak-f permite o ajuste de par√¢metros (como tamanho de estado e n√∫mero de rodadas) em diferentes n√≠veis de seguran√ßa e cen√°rios de aplica√ß√£o, oferecendo grande flexibilidade. Keccak-f[1600] √© renomado por sua implementa√ß√£o eficiente, alcan√ßando altas velocidades de processamento tanto em hardware quanto em software, especialmente ao lidar com grandes quantidades de dados.
                </p>
                
                <h4>Fase de Espremer: </h4>
                <p>
                    Uma vez que todos os blocos de dados de entrada foram absorvidos no estado interno, a estrutura de esponja entra na fase de espremer. Nesta etapa, partes do estado interno s√£o progressivamente produzidas como resultado da fun√ß√£o de hash. Se o comprimento de sa√≠da necess√°rio exceder a quantidade que pode ser espremida de uma vez, a estrutura de esponja aplica a fun√ß√£o de permuta√ß√£o para transformar o estado interno novamente e depois continua a produzir mais dados. Este processo √© realizado at√© que o comprimento de sa√≠da desejado seja alcan√ßado.
                </p>
                
                <p>
                    O objetivo do design do SHA-3 √© fornecer uma seguran√ßa mais alta do que o SHA-2 e uma melhor resist√™ncia contra ataques de computa√ß√£o qu√¢ntica. Gra√ßas √† sua estrutura de esponja √∫nica, o SHA-3 √© teoricamente capaz de resistir a todos os m√©todos de ataque criptogr√°fico atualmente conhecidos, incluindo ataques de colis√£o, ataques de pr√©-imagem e ataques de segunda pr√©-imagem.
                </p>
                
                <h3>RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest)</h3>
                <p>
                    RIPEMD-160 √© uma fun√ß√£o de hash criptogr√°fica projetada para fornecer um algoritmo de hash seguro. Foi desenvolvido em 1996 por Hans Dobbertin e outros, e √© membro da fam√≠lia RIPEMD (RACE Integrity Primitives Evaluation Message Digest).
                </p>
                <p>
                    RIPEMD-160 produz um valor de hash de 160 bits (20 bytes), que √© a origem do "160" em seu nome. √â baseado no design de MD4 e influenciado por outros algoritmos de hash como MD5 e SHA-1. RIPEMD-160 inclui duas opera√ß√µes paralelas e semelhantes que processam os dados de entrada separadamente e depois combinam os resultados desses dois processos para gerar o valor de hash final. Este design visa aumentar a seguran√ßa.
                <br>
                <br>O processo de computa√ß√£o do <a href="https://en.wikipedia.org/wiki/RIPEMD" target="_blank" style="color: #007bff; font-size: 1.0em;">RIPEMD-160</a> inclui v√°rias etapas b√°sicas: preenchimento, processamento de bloco e compress√£o:
                </p>
                <ul>
                    <li><strong>Preenchimento: </strong> A mensagem de entrada √© primeiro preenchida para garantir que seu comprimento m√≥dulo 512 bits seja igual a 448 bits. O preenchimento sempre come√ßa com um √∫nico bit de 1 seguido de uma s√©rie de bits 0, terminando com uma representa√ß√£o de 64 bits do comprimento da mensagem original.</li>
                    <li><strong>Processamento de Bloco: </strong> A mensagem preenchida √© dividida em blocos de 512 bits.</li>
                    <li><strong>Inicializa√ß√£o: </strong> Usa cinco registros de 32 bits (A, B, C, D, E), que s√£o inicializados com valores espec√≠ficos.</li>
                    <li><strong>Fun√ß√£o de Compress√£o: </strong> Cada bloco √© processado por vez, atualizando os valores desses cinco registros por meio de uma s√©rie de opera√ß√µes complexas. Este processo inclui opera√ß√µes bitwise (como adi√ß√£o, AND, OR, NOT, deslocamentos circulares para a esquerda) e o uso de um conjunto de constantes fixas.</li>
                    <li><strong>Sa√≠da: </strong> Ap√≥s todos os blocos terem sido processados, os valores desses cinco registros s√£o concatenados para formar o valor de hash final de 160 bits.</li>
                </ul>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="support-links">
            <h3>Suporte</h3>
            <ul>
                <li><a href="https://tap5ai.com/" target="_blank" rel="noopener noreferrer">Tap5 AI</a></li>
            </ul>
        </div>

        <div class="social-links">
            <a href="https://twitter.com/xinli_111219" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-twitter"></i>
            </a>
            <a href="https://www.youtube.com/@xinli-vj3js" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-youtube"></i>
            </a> 
        </div>
    
        <div class="info">
            <p>¬© 2024 chatcipher Tools. Todos os direitos reservados.</p>
            <p>
                <a href="https://chatcipherai.com/pt/Privacy_Policy.html" title="Privacy Policy">Pol√≠tica de Privacidade</a>
                |
                <a href="https://chatcipherai.com/pt/Terms_of_Use.html" title="Terms of Use">Termos de Uso</a>
                |
                <a href="https://chatcipherai.com/pt/About_Us.html" title="About Us">Sobre N√≥s</a>
                |
                <a href="https://chatcipherai.com/pt/Disclaimer.html" title="Disclaimer">Aviso Legal</a>
            </p>
            <button id="backToTop" onclick="scrollToTop()">Voltar ao Topo</button>
        </div>
    </footer>

    <script>
        let shortcutsEnabled = true;

        function manageShortcuts(enable) {
            shortcutsEnabled = enable;
        }

        function handleKeyPress(event) {
            if (!shortcutsEnabled) {
                console.log('Shortcuts are disabled');
                return;
            }

            switch (event.key.toUpperCase()) {
                case 'A':
                    clearAll();
                    console.log('Clear All triggered');
                    break;
                case 'L':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('light-mode');
                        console.log('Light style activated');
                    }
                    break;
                case 'N':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('dark-mode');
                        console.log('Dark style activated');
                    }
                    break;
                case 'B':
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                    console.log('Scrolled to top');
                    break;
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Ensure all handlers are set up once the DOM is fully loaded
            document.addEventListener('keydown', handleKeyPress);

            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
            
            setupEventListeners(); // Setup other event listeners
            adjustButton();
        });

        let generatedTextHash = '';
        let generatedFileHash = '';

        async function generateHash() {
            const text = document.getElementById('textInput').value;
            document.getElementById('processOutput').textContent = text.length ? "Calculando o valor do hash..." : '';
            const msgUint8 = new TextEncoder().encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('hashOutput').textContent = `Valor de hash (SHA-256): ${hashHex}`;
            generatedTextHash = hashHex;
            document.getElementById('processOutput').textContent = "";
        }

        async function generateFileHash() {
            const fileInput = document.getElementById('fileInput');
            if (!fileInput.files.length) {
                alert("Selecione um arquivo.");
                return;
            }
            document.getElementById('fileHashOutput').textContent = "Calculando o valor do hash do arquivo...";
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('fileHashOutput').textContent = `Valor de hash (SHA-256): ${hashHex}`;
                generatedFileHash = hashHex;
            };
            reader.onerror = function () {
                alert("Erro de leitura de arquivo.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareTextHash() {
            const compareHash = document.getElementById('hashCompareInput').value;
            if (!generatedTextHash) {
                alert('Por favor, gere um hash do texto primeiro.');
                return;
            }
            const resultText = generatedTextHash === compareHash ? "<strong>Conclus√£o: </strong>Os hashes correspondem e os dados n√£o foram adulterados." : "<strong>Conclus√£o: </strong>Os hashes n√£o correspondem e os dados podem ter sido adulterados em tr√¢nsito ou ocorreu um erro durante o armazenamento.";
            document.getElementById('textCompareResult').innerHTML = resultText;
            document.getElementById('textCompareResult').style.color = generatedTextHash === compareHash ? "black" : "red";
        }

        async function compareFileHash() {
            const fileInput = document.getElementById('compareFileInput');
            if (!fileInput.files.length) {
                alert("Selecione um arquivo para comparar.");
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                document.getElementById('fileCompareResult').textContent = `Valor de hash (SHA-256): ${hashHex}`;

                if (generatedFileHash === hashHex) {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Conclus√£o:  </strong>Os hashes correspondem e os dados n√£o foram adulterados.";
                    document.getElementById('fileCompareResult').style.color = "black";
                } else {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Conclus√£o:  </strong>Os hashes n√£o correspondem e os dados podem ter sido adulterados em tr√¢nsito ou ocorreu um erro durante o armazenamento.";
                    document.getElementById('fileCompareResult').style.color = "red";
                }
            };
            reader.onerror = function () {
                alert("Erro de leitura de arquivo.");
            };
            reader.readAsArrayBuffer(file);
        }

        function copyTextHash() {
            const hashValue = document.getElementById('hashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("Falha ao copiar o hash de texto.");
                });
            }
        }

        function compareHashValues() {
            var hashValue1 = document.getElementById('hashInput1').value.trim();
            var hashValue2 = document.getElementById('hashInput2').value.trim();

            var resultDisplay = document.getElementById('hashComparisonResult');

            resultDisplay.style.fontWeight = 'bold';

            if (hashValue1 === "" || hashValue2 === "") {
                resultDisplay.textContent = 'Ambos os valores de hash devem ser inseridos.';
                resultDisplay.style.color = 'black';
            } else if (hashValue1 === hashValue2) {
                resultDisplay.textContent = 'Os valores de hash correspondem!';
                resultDisplay.style.color = 'black';
            } else {
                resultDisplay.textContent = 'Os valores de hash n√£o correspondem.';
                resultDisplay.style.color = 'red';
            }
        }

        function copyFileHash() {
            const hashValue = document.getElementById('fileHashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("Falha ao copiar o hash do arquivo.");
                });
            }
        }

        function clearAll() {
            document.getElementById('textInput').value = '';
            document.getElementById('hashOutput').textContent = '';
            document.getElementById('hashCompareInput').value = '';
            document.getElementById('textCompareResult').textContent = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('fileHashOutput').textContent = '';
            document.getElementById('compareFileInput').value = '';
            document.getElementById('fileCompareResult').textContent = '';
            document.getElementById('hashInput1').value = '';
            document.getElementById('hashInput2').value = '';
            document.getElementById('hashComparisonResult').textContent = '';
        }

        document.getElementById('menuIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .menuUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });
        document.getElementById('languageIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .langUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });

        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var menunavbarUl = document.querySelector('.navbar .menuUl');

            var languageIcon = document.getElementById('languageIcon');
            var langnavbarUl = document.querySelector('.navbar .langUl');

            if (!menuIcon.contains(event.target) && !menunavbarUl.contains(event.target)) {
                menunavbarUl.style.display = 'none';
            }
            if (!languageIcon.contains(event.target) && !langnavbarUl.contains(event.target)) {
                langnavbarUl.style.display = 'none';
            }
        });
        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var navbarUl = document.querySelector('.navbar ul');

            if (!menuIcon.contains(event.target) && !navbarUl.contains(event.target)) {
                navbarUl.style.display = 'none';
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
        });

        document.getElementById('lightStyle').addEventListener('click', function () {
            setStyle('light-mode');
        });

        document.getElementById('darkStyle').addEventListener('click', function () {
            setStyle('dark-mode');
        });

        function setStyle(style) {
            document.body.className = style;
            localStorage.setItem('style', style);
            updateButtonStyles();
            updateNavbarStyles(style);
        }

        function updateNavbarStyles(style) {
            var navbar = document.querySelector('.navbar');
            var ul = navbar.querySelector('ul');
            navbar.style.backgroundColor = style === 'dark-mode' ? '#0A0F24' : '#FFFFFF';
            ul.style.backgroundColor = style === 'dark-mode' ? 'rgba(119, 136, 153, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            ul.style.color = style === 'dark-mode' ? '#FFFFFF' : '#0A0F24';
        }

        document.querySelectorAll('.learnMore').forEach(function (link) {
            link.addEventListener('click', function () {
                var targetId = this.getAttribute('data-target');
                var moreContent = document.getElementById(targetId);
                if (moreContent.style.display === "none" || moreContent.style.display === "") {
                    moreContent.style.display = "block";
                    this.textContent = "[Fecho]";
                } else {
                    moreContent.style.display = "none";
                    this.textContent = "[Saber mais]";
                }
            });
        });

        window.onscroll = function () { scrollFunction(); };
        function scrollFunction() {
            if (document.body.scrollTop > 10 || document.documentElement.scrollTop > 20) {
                document.getElementById("backToTop").style.display = "block";
            } else {
                document.getElementById("backToTop").style.display = "none";
            }
        }
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        document.addEventListener('DOMContentLoaded', function () {
            var navbar = document.querySelector('.navbar');
            window.onscroll = function () {
                if (window.scrollY > 50) {
                    navbar.classList.add('solid');
                } else {
                    navbar.classList.remove('solid');
                }
            };
        });

        function adjustButton() {
            var button = document.getElementById('backToTop');
            if (window.innerWidth < 768) {
                button.innerHTML = '‚ñ≤';
            } else {
                button.innerHTML = 'Voltar ao Topo(<span class="highlight-key">B</span>)';
            }
        }

        window.onload = adjustButton;
        window.onresize = adjustButton;

    </script>
    <div style="display: none;">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-LZTEEH0M4K"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
    
            gtag('config', 'G-LZTEEH0M4K');
        </script>
    </div>
</body>
</html>