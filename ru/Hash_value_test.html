<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Хэш SHA-256 Эксплорер: Необратимый скульптор цифрового мира.</title>
    <meta name="keywords" content="шифр, хеш, данные, хеш-функции, хеш-значения, функции"/>
    <meta name="description"
        content="Создание уникального отпечатка информации с помощью 256-битного шифрования, обеспечивающее целостность и аутентичность данных.">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="icon" type="image/jpg" href="./images/cipher.jpg">
    <style>    
        html {
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100vh;
            align-items: center;
            margin: 0;
            padding: 0 20px 20px 20px;
            background-color: #0A0F24;
            color: #FFFFFF;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(10, 15, 36, 0.0);
            transition: background-color 0.5s ease;
            z-index: 1000;
            height: 40px;
        }

        .navbar.solid {
            background-color: rgba(10, 15, 36, 1);
        }

        #menuIcon {
            cursor: pointer;
            transition: color 0.3s ease;
        }

        #menuIcon:hover {
            color: #a3a2a2;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            position: relative;
            left: -10px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        .navbar .langUl {
            left: 87px;
            width: 100px;
        }

        .navbar.active ul {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 35px;
            left: 10px;
            width: 15%;
            background-color: rgba(119, 136, 153, 0.8);
            padding: 10px 0;
        }

        .navbar.active ul li {
            margin-bottom: 1px;
        }

        .navbar.active ul li:last-child {
            margin-bottom: 0;
        }

        .navbar ul {
            display: none;
            flex-direction: column;
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: transparent;
            padding: 10px 0;
            list-style: none;
            margin: 0;
            width: 13%;
        }

        .navbar.active ul {
            display: flex;
        }

        .section.interactive-tool {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #bbbaba;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 1000px;
            margin-top: 30px;
            margin-bottom: 150px;
        }

        .sections-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 120px;
            margin-right: -10px;
        }

        .sections-container h2,
        .sections-container p {
            text-align: left;
            width: 80%;
        }

        p {
            margin-bottom: 30px;
            text-align: left;
            font-size: 1.2em;
            line-height: 1.6;
            margin-bottom: 15px;
            text-align: center; 
        }

        h2 {
            margin-bottom: 10px;
            font-size: 28px;
            margin-top: 50px;
        }

        h3 {
            margin-top: 50px;
            font-size: 22px;
        }

        h4 {
            font-size: 20px;
        }

        .sections-container h2:hover {
            color: #4bcfcf;
            transition: color 0.3s ease;
        }

        .navbar li a {
            color: white;
            padding: 5px;
            text-decoration: none;
            font-size: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            display: block;
            border-radius: 5px;
        }

        .navbar ul li {
            margin-bottom: 1px;
        }

        .navbar ul li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .navbar h1 {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 35px;
            margin-right: 0;
            font-size: 30px;
        }

        .navbar-dark {
            background-color: #0A0F24;
        }

        .morse-code-container {
            display: flex;
            align-items: center;
        }

        .morse-code-container .copy-button {
            margin-right: 5px;
            margin-left: 0;
        }

        button {
            cursor: pointer;
            margin: 10px;
            padding: 8px 15px;
            margin-left: 5px;
            background-color: #c0c0c0;
            border: none;
            border-radius: 5px;
            color: #FFFFFF;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #a8a8a8;
        }

        .style-selector {
            position: absolute;
            top: 0px;
            right: 50px;
            margin-top: 10px;
        }

        .style-selector button {
            background-color: #0a0f24;
            padding: 5px 10px;
            margin-right: 1px;
            color: #F5F5F5;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .style-selector button:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .dark-mode {
            background-color: #0A0F24;
            color: white;
        }

        .light-mode {
            background-color: white;
            color: #0A0F24;
        }

        .light-mode .navbar,
        .light-mode .container {
            background-color: #FFFFFF;
            color: #0A0F24;
        }

        .light-mode .navbar ul {
            background-color: transparent;
            color: #0A0F24;
        }

        .dark-mode .navbar ul li a:hover {
            color: #30eded;
        }

        .light-mode .navbar ul li:hover {
            color: #0A0F24;
            background-color: rgba(255, 255, 255, 1);
            border-radius: 5px;
        }

        .navbar {
            justify-content: flex-start;
        }

        #languageIcon {
            cursor: pointer;
            transition: color 0.3s ease;
            margin-left: 30px;
        }

        #languageIcon:hover {
            color: #a3a2a2;
        }

        #languageSelect {
            padding: 5px 10px;
            margin-left: 10px;
            border-radius: 5px;
            border: none;
            background-color: #5f9ea0;
            color: white;
            cursor: pointer;
        }

        #languageSelect:hover {
            background-color: #2F4F4F;
        }

        .language-dropdown {
            width: 6%;
            display: none;
            list-style: none;
            padding: 10px 0;
            margin: 0;
            position: absolute;
            top: 40px;
            left: 100px;
            background-color: rgba(119, 136, 153, 0.8);
        }

        .language-dropdown li a {
            color: #FFFFFF;
            padding: 5px;
            margin: 1px;
            text-decoration: none;
            display: block;
            border-radius: 8px;
        }

        .language-dropdown li a:hover {
            background-color: rgba(255, 255, 255, 0.206);
            color: #0A0F24;
        }

        .table-container {
            display: none;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .table-container.active {
            display: block;
        }

        .button-container {
            display: flex;
            justify-content: center;
            margin-right: 20px
        }

        .button-container button {
            margin-right: 30px;
        }

        .footer {
            position: relative;
            width: 100%;
            background-color: #0A0F24;
            color: #FFFFFF;
            text-align: center;
            padding: 10px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            margin-bottom: -20px;
        }

        .footer a {
            color: #F5F5F5;
            text-decoration: none;
            margin: 0 12px;
            transition: color 0.3s ease;
        }

        .footer a:hover {
            color: #a3a2a2;
        }

        .footer p {
            margin: 0;
            font-size: 16px;
        }

        .learnMore {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .moreContent {
            width: 80%;
            margin: auto;
            text-align: left;
            padding: 10px;
            display: none;
            margin-left: 0px;
        }

        .moreContent p {
            margin-bottom: 16px;
            font-size: 1.2em;
            line-height: 1.6;
            padding-bottom: 5px;
        }

        #moreContent1 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent1 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        #moreContent2 {
            color: #0A0F24;
            background-color: #e9f4f4;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 77%;
        }

        #moreContent2 ul li {
            margin-bottom: 15px; /* This adds 15px of space below each list item */
        }

        .clear-all-button {
            background-color: #47d7ff;
        }

        .clear-all-button:hover {
            background-color: #57f7ff;
        }

        figure {
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            text-align: center;
            width: 100%;
            margin: 0 auto;
        }

        img {
            max-width: 75%;
            height: auto;
            margin-left: -290px;
            margin-top: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);   
        }

        figcaption.workflow,
        figcaption.Irreversibility,
        figcaption.Resistance,
        figcaption.Merkle-Damgård,
        figcaption.Compare,
        figcaption.sponge {
            width: 100%;
            margin-left: -300px;
            color: #007bff;
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 10px;
        }

        .navbar li {
            position: relative;
        }

        .navbar li>a {
            display: block;
        }

        .navbar .submenu {
            display: none;
            position: absolute;
            left: 101%;
            top: 0;
            background-color: transparent;
            border-radius: 5px;
            padding: 0;
            min-width: 150px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .navbar .submenu li {
            display: block;
            border-bottom: none;
            width: 90%;
        }

        .navbar .submenu li:last-child {
            border-bottom: none;
        }

        .navbar li:hover>.submenu {
            display: block;
        }

        .navbar .submenu a {
            color: #ffffff;
            padding: 5px;
            text-decoration: none;
            display: block;
            transition: background-color 0.3s ease;
        }

        .navbar .submenu a:hover {
            background-color: rgba(255, 255, 255, 0.206);
        }

        .input-group {
            display: flex;
            width: 83%;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 40px;
        }

        .input-group>div {
            flex: 1;
            margin-right: 20px;
        }

        .input-group>div:last-child {
            margin-right: 0;
        }

        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 10px 15px 10px 5px;
            border: 1px solid #eae6e6;
            border-radius: 5px;
            box-sizing: border-box;
        }

        button,
        input[type="submit"],
        input[type="file"]::file-selector-button {
            background-color: #0a0f24;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s;
        }

        button:hover,
        input[type="submit"]:hover,
        input[type="file"]::file-selector-button:hover {
            background-color: #c0c0c0;
            color: #0A0F24;
        }

        .compare-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        input[type="file"] {
            display: block;
        }

        .outPut {
            width: 100%;
            white-space: normal;
            word-break: break-all;
        }

        #backToTop {
            position: absolute;
            bottom: 5px;
            right: 30px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #0a0f24;
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
            display: block;
        }

        #backToTop:hover {
            background-color: #c0c0c0;
            color: #0a0f24;
        }

        .introduce {
            margin-left: 220px;
        }

        .introduce li {
            font-size: 17px;
            line-height: 1.5;
            word-wrap: break-word;
            width: 80%;
            padding-bottom: 10px; 
        }

        .language-list{
            float: right;
        }
        .language-list a{
            margin-left: 20px;
            color: white;
        }

        .language-list a:hover{
            color: #4bcfcf;
        }

        .language-list a {
            text-decoration: none;
        }

        .attention {
            margin-top: 20px;
            font-size: 0.8em;
        }

        .highlight-key { 
            font-weight: 800;
        }

        @media screen and (max-width: 768px) {
            .navbar h1 {
                font-size: 18px;
                position: absolute;
                top: -25px;
            }

            .sections-container {
                margin-left: auto;
                margin-right: auto;
                align-items: center;
                width: 100%;
            }

            .sections-container h2 {
                font-size: 1.2em;
            }

            .sections-container p {
                font-size: 0.9em;
            }
            
            .introduce {
                width: 100%;
                padding: 10px;
                margin-left: 90px;
            }

            .introduce h2 {
                font-size: 1.2em; 
            }

            h3 {
                font-size: 0.9em; 
            }

            h4 {
                font-size: 0.8em; 
            }

            .introduce p {
                font-size: 0.9em; 
            }

            .introduce li {
                font-size: 14px;
                margin-left: -20px;
            }

            figure {
                display: flex;
                flex-direction: column;
                align-items: center; 
                justify-content: center; 
                text-align: center;
                width: 100%;
                margin: 0 auto;
            }

            img {
                max-width: 80%;
                height: auto;
                margin-left: -90px;
                margin-top: 20px;
            }

            figcaption.workflow,
            figcaption.Irreversibility,
            figcaption.Resistance,
            figcaption.Merkle-Damgård,
            figcaption.Compare,
            figcaption.sponge {
                width: 100%;
                margin-left: -100px;
                color: #007bff;
                font-size: 0.8em;
                font-weight: bold;
                margin-top: 10px;
            }

            .footer p {
                margin: 0;
                font-size: 10px;
            }

            pre {
                display: none;
            }

            #backToTop {
                content: '▲';
                padding: 4px 5px;
                font-size: 14px;
                right: 10px;
                bottom: 0px;
            }
   
            .input-group {
                flex-direction: column;
            }

            .section.interactive-tool {
                width: 320px;
            }
            .navbar ul {
                width: 25%;
            }

            .navbar ul li {
                padding: 0 5px 0 0;
            }

            .navbar li a {
                padding: 5px;
            }

            .navbar li a {
                font-size: 10px;
                width: 100%;
                padding: 5px 0px 5px 5px;
            }

            .navbar .submenu {
                left: 100%;
            }

            .navbar .submenu li {
                display: block;
                border-bottom: none;
                width: 55%;
                padding: 0 5px 0 0;
            }

            .navbar .submenu li a {
                padding: 5px 0px 5px 5px;
            }

            #menuIcon {
                font-size: 0; /* Hide text */
            }
            #menuIcon::before {
                content: '\2630'; /* Unicode character for ☰ */
                font-size: 16px; /* Or any other size you prefer */
            }

            #languageIcon {
                font-size: 0;
            }

            #languageIcon::before {
                content: '\2637'; /* Unicode character for ☰ */
                font-size: 16px; /* Or any other size you prefer */
            }

            .navbar .langUl {
                left: 42px;
                width: 65px;
            }

            #darkStyle {
                font-size: 0;
                margin-left: 10px;
                padding: 5px 8px;
            }

            #lightStyle {
                font-size: 0;
                margin-right: -10px;
            }

            #darkStyle::before {
                font-size: 9px;
            }

            #lightStyle::before {
                font-size: 10px;
            }

            #darkStyle::before {
                content: "🌙";
            }

            #lightStyle::before {
                content: "☀";
            }

            #hashCompareInput {
                width: 240px;
            }

            .social-links i {
                font-size: 12px;
            }

            .attention {
                margin-top: 10px;
                font-size: 0.5em;
            }
        }
    </style>
</head>

<body class="dark-mode">
    <header>
        <nav class="navbar">
            <div id="menuIcon">&#9776; меню</div>
            <div id="menuItems"></div>
            <ul class="menuUl">
                <li>
                    <a href="https://chatcipherai.com/ru/chatcipherai.html"><strong>Мир криптосистем</strong></a>
                    <ul class="submenu">
                        <li><a href="https://chatcipherai.com/ru/Caesar_Cipher.html"><strong>Шифр Цезаря</strong></a></li>
                        <li><a href="https://chatcipherai.com/ru/Playfair_Cipher.html"><strong>Шифр Плейфера</strong></a></li>
                        <li><a href="https://chatcipherai.com/ru/Hill_Cipher.html"><strong>Шифр Хилла</strong></a></li>  
                    </ul>
                </li>
                <li><a href="https://chatcipherai.com/ru/Hash_value_test.html"><strong>Тест хеш-значения</strong></a></li>
                <li><a href="https://chatcipherai.com/ru/Morsecode_main.html"><strong>Переводчик Морзе</strong></a></li>
                <li><a href="https://chatcipherai.com/ru/Shortcut_Key_Description.html"><strong>Описание сочетания клавиш</strong></a></li>
            </ul>
            
            <div id="languageIcon">&#x2637; язык</div>
            <div id="languageItems">
                <ul class="langUl">
                    <li><a href="https://chatcipherai.com/en/Hash_value_test.html" title="English">English</a></li>
                    <li><a href="https://chatcipherai.com/fr/Hash_value_test.html" title="Français">Français</a></li>
                    <li><a href="https://chatcipherai.com/es/Hash_value_test.html" title="Español">Español</a></li>
                    <li><a href="https://chatcipherai.com/zh-CN/Hash_value_test.html" title="中文（简体）">中文（简体）</a></li>
                    <li><a href="https://chatcipherai.com/zh-TW/Hash_value_test.html" title="中文（繁体）">中文（繁体）</a></li>
                    <li><a href="https://chatcipherai.com/ar/Hash_value_test.html" title="العربية">العربية</a></li>
                    <li><a href="https://chatcipherai.com/ru/Hash_value_test.html" title="Русский">Русский</a></li>
                    <li><a href="https://chatcipherai.com/pt/Hash_value_test.html" title="Português">Português</a></li>
                    <li><a href="https://chatcipherai.com/de/Hash_value_test.html" title="Deutsch">Deutsch</a></li>
                    <li><a href="https://chatcipherai.com/hi/Hash_value_test.html" title="हिन्दी">हिन्दी</a></li>
                    <li><a href="https://chatcipherai.com/nl/Hash_value_test.html" title="Nederlands">Nederlands</a></li>
                </ul> 
            </div>

            <h1>Хеширование SHA-256 Explorer</h1>
            <div class="style-selector">
                <button id="darkStyle">🌙 Тёмный стиль(<span class="highlight-key">N</span>)</button>
                <button id="lightStyle">☀ Светлый стиль(<span class="highlight-key">L</span>)</button>
            </div>  
        </nav>
    </header>

    <main class="sections-container">
        <section class="section interactive-tool">
            <h2>Тестирование хеш-значения</h2>
            <p>Введите текст для просмотра процесса его преобразования в хеш-значение в реальном времени,
                <br>
                или выберите файл для вычисления его хеш-значения.
            </p>
            
            <div class="input-group">
                <div>
                    <p>Создать текстовый хеш</p>
                    <input type="text" class="input_value" id="textInput" placeholder="Введите текст" oninput="generateHash()" />
                    <button onclick="copyTextHash()">Скопировать хеш-значение текста</button>
                    <div id="processOutput"></div>
                    <div id="hashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Сравнить хеш-значение текста</p>
                    <input type="text" class="input_value" id="hashCompareInput"
                        placeholder="Введите хеш-значение для сравнения" />
                    <button onclick="compareTextHash()">Сравнить</button>
                    <div id="textCompareResult"></div>
                </div>
            </div>
            
            <div class="input-group">
                <div>
                    <p>Создать хэш файла</p>
                    <input type="file" id="fileInput" onchange="generateFileHash()" />
                    <button onclick="copyFileHash()">Скопировать хеш-значение файла</button>
                    <div id="fileHashOutput" class="outPut"></div>
                </div>
                <div>
                    <p>Сравнить хеш-значение файла</p>
                    <input type="file" id="compareFileInput" onchange="compareFileHash()" />
                    <div id="fileCompareResult" class="outPut"></div>
                </div>
            </div>

            <div class="input-group">
                <div>
                    <p>Введите хеш-значение 1</p>
                    <input type="text" class="input_value" id="hashInput1" placeholder="Введите хеш-значение 1" />
                </div>
                <div>
                    <p>Введите хеш-значение 2</p>
                    <input type="text" class="input_value" id="hashInput2" placeholder="Введите хеш-значение 2" />
                    <button onclick="compareHashValues()">Сравнить</button>
                    <div id="hashComparisonResult" class="outPut"></div>
                </div>
            </div>
            
            <button id="clearAllButton" class="clear-all-button" onclick="clearAll()">Очистить все(<span class="highlight-key">A</span>)</button>
            <div class="attention">
                Доброе напоминание: Перед вводом данных, пожалуйста, тщательно проверьте точность и конфиденциальность информации. Мы рекомендуем с осторожностью загружать на сервер важные данные. Это поможет лучше защитить вашу конфиденциальность и безопасность.
            </div>            
        </section>
        
        <section class="introduce">
            <p><strong><em>"В современную цифровую эпоху, безопасность данных не только является краеугольным камнем защиты личной конфиденциальности и корпоративных секретов, но и ключом к поддержанию социального доверия и экономической стабильности."</em></strong></p>
            <div>
                <h2>Что такое хеш-значение?</h2>
                <p>
                    Хеш-значение - это строка или число фиксированного размера, созданное из данных любого размера с помощью хеш-функции. 
                    Эти функции принимают разнообразные данные, такие как текст, изображения и видео, и производят хеш-значение фиксированной длины, которое нельзя обратно преобразовать. 
                    Хеш-значения детерминированны, что означает, что идентичные входные данные всегда приводят к одному и тому же результату. Они также обладают устойчивостью к коллизиям, 
                    что делает сложным нахождение различных входных данных, приводящих к одному и тому же результату.
                </p>
            </div>
            
            <div>
                <h2>Функции хеш-значения</h2>
                <p>
                    Хеш-значения играют важную роль в компьютерных науках и информационных технологиях, предоставляя фиксированный суммарный размер данных независимо от их размера. Эти функции облегчают различные приложения:
                </p>
                <ul>
                    <li><strong>Проверка целостности данных:</strong> Используется для проверки, остаются ли данные неизменными во время передачи, обеспечивая целостность загруженных файлов.</li>
                    <li><strong>Хранение паролей:</strong> Пароли хранятся в виде хеш-значений для обеспечения безопасности, что делает восстановление исходных паролей из компрометированных баз данных трудным.</li>
                    <li><strong>Быстрый доступ к данным:</strong> Хеш-значения действуют как индексы в хеш-таблицах, обеспечивая эффективные операции с данными.</li>
                    <li><strong>Дедупликация данных:</strong> Помогает в определении и удалении дублирующихся элементов данных путем сравнения их хеш-значений.</li>
                    <li><strong>Цифровая подпись и верификация:</strong> Обеспечивает целостность и подлинность данных с помощью криптографии с открытым ключом и хеш-функций.</li>
                    <li><strong>Технология блокчейна:</strong> Использует хеш-значения для обеспечения безопасности записей транзакций и обеспечения неизменности данных.</li>
                    <li><strong>Неизменяемые временные метки:</strong> Предоставляет необратимую временную метку для данных, полезную для юридической и авторской защиты.</li>
                </ul>
                <p>
                    Причиной эффективности хеш-значений в этих областях являются их ключевые характеристики - скорость, детерминизм, необратимость и устойчивость к коллизиям. Правильно использованные хеш-функции могут обеспечить надежную поддержку при обеспечении безопасности данных, 
                    повышении эффективности и проверке подлинности информации.
                </p>
            </div>
            
            <div>
                <h2>Что такое хеш-функция?</h2>
                <p>
                    Хеш-функция - это математическая конструкция, которая отображает входные данные (или "сообщение") на строку фиксированного размера, обычно числовое значение, как показано на диаграмме ниже. Широко используется в управлении данными и информационной безопасности, 
                    хеш-функция характеризуется своей эффективной вычислительной производительностью, постоянной длиной вывода, необратимостью, чувствительностью к вариациям ввода и устойчивостью к коллизиям.
                </p>
                <figure>
                    <img src="./images/Hash input output.jpg" alt="Диаграмма рабочего процесса хеш-функции" />
                    <figcaption class="workflow">Диаграмма рабочего процесса хеш-функции</figcaption>
                </figure>
            </div>

            <div>
                <h3>Эффективная вычислительная производительность</h3>
                <p>
                    Хеш-функции могут быстро вычислять хеш-значения из данных любой формы, независимо от их размера. Эта характеристика критически важна для приложений, которые требуют быстрого доступа к данным, таких как хеш-таблицы. 
                    Это связано с тем, что при сохранении данных в хеш-таблицах скорость хеш-функции определяет скорость доступа к данным. Хеш-таблицы используют хеш-функции для быстрого определения места хранения данных, полагаясь на быструю вычислительную способность хеш-функций. 
                </p>
            
                <p>
                    Более того, в системах, которым необходимо обрабатывать большие объемы данных, эффективность хеш-функций напрямую влияет на общую производительность системы. Если хеш-функция работает медленно, она станет узким местом в производительности системы. Некоторые системы реального времени, 
                    такие как фильтрация пакетов в сетевых устройствах, требуют немедленного вычисления хеш-значений для данных, чтобы быстро принимать решения. В этих случаях эффективность хеш-функций также является крайне важной.
                </p>
            
                <p>
                    Например, представьте онлайн-платформу электронной коммерции, где пользователи могут вводить названия товаров в строку поиска для поиска продуктов. Бэкенд-система может использовать хеш-функции для быстрого поиска информации о продуктах, сохраненной в хеш-таблицах. 
                    Если процесс вычисления хеш-функции медленный, пользовательский опыт будет серьезно нарушен, так как им придется дольше ждать результатов поиска. В этой ситуации эффективная вычислительная производительность хеш-функций обеспечивает быстрое время отклика, тем самым улучшая пользовательский опыт.
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent1">[Узнать больше]</a>
                </p>
            </div>

            <div id="moreContent1" class="moreContent" style="display:none;" style="color: #007bff; font-size: 1.0em;">
                <p>Причины, по которым хеш-функции могут повысить вычислительную эффективность, в основном связаны с следующими конструктивными характеристиками:</p>
                <ul>
                    <li><strong>Простые операции:</strong> Хеш-функции обычно используют простые математические и битовые операции, которые выполняются очень быстро благодаря прямой поддержке аппаратных средств ЦП.</li>
                    <li><strong>Избежание зависимостей от цикла:</strong> Избегая зависимостей от цикла, хеш-функции позволяют пайплайн-обработку, тем самым увеличивая скорость.</li>
                    <li><strong>Параллельная обработка:</strong> Современные хеш-функции разработаны для параллельной обработки, увеличивая эффективность на многоядерных процессорах.</li>
                    <li><strong>Фиксированный размер вывода:</strong> Фиксированный размер вывода упрощает выделение памяти и сравнение данных, улучшая программную модель и эффективность.</li>
                    <li><strong>Предварительная обработка и постобработка:</strong> Хеш-функции могут обрабатывать большие данные, разбивая их на блоки, вычисляя хеш-значения отдельно, а затем объединяя их, что повышает эффективность.</li>
                    <li><strong>Оптимизированные алгоритмические пути:</strong> Уменьшение ветвлений во время выполнения повышает точность предсказания инструкций на ЦП, тем самым увеличивая скорость.</li>
                    <li><strong>Дружественность к кэшу:</strong> Проектирование хеш-функций для минимизации промахов кэша значительно повышает скорость обработки.</li>
                    <li><strong>Оптимизация аппаратного обеспечения:</strong> Специализированные аппаратные ускорители могут значительно увеличить скорость вычисления хеша, особенно для криптографических хеш-функций, таких как серия SHA.</li>
                    <li><strong>Безсостоятельность:</strong> Хеш-функции не сохраняют информацию о состоянии, что позволяет легко обрабатывать каждый новый ввод.</li>
                    <li><strong>Универсальность:</strong> Хеш-функции универсальны для всех типов входных данных, что устраняет необходимость в пользовательских алгоритмах для различных типов данных.</li>
                </ul>
            </div>
            
            <div>
                <h3>Постоянная длина вывода в хеш-функциях</h3>
                <p>
                    Хеш-функции преобразуют входные данные любой длины в вывод фиксированной длины с помощью сложной серии вычислений. Этот процесс часто включает в себя разделение входных данных на блоки фиксированного размера (для вводов, превышающих размер обрабатываемого блока), 
                    применение серии математических и логических операций к каждому блоку, а затем объединение или накопление результатов этих операций каким-либо образом, чтобы в конечном итоге получить хеш-значение фиксированного размера.
                </p>
                <p>
                    <strong>Почему это важно?</strong>
                    Постоянная длина вывода помогает обеспечить безопасность хеш-функций. Если длина вывода хеша может изменяться, это может утечь информацию о размере исходных данных, что в некоторых случаях может быть использовано для атаки на систему. 
                    Более того, фиксированная длина вывода также делает сложным для злоумышленников вывод характеристик входных данных путем анализа длины вывода. В то же время фиксированная длина вывода упрощает хранение и сравнение хеш-значений. 
                    Проектировщики систем могут заранее знать, сколько места займет каждое хеш-значение, что очень важно для сценариев, таких как проектирование баз данных и передача по сети. Более того, постоянная длина вывода становится очень эффективной для сравнения хеш-значений на равенство, 
                    поскольку для этого требуется только сравнение данных фиксированной длины. Это особенно важно при использовании хеш-таблиц для быстрого доступа к данным.
                </p>
                <p>
                    Возьмем SHA-256 в качестве примера, эта широко используемая криптографическая хеш-функция всегда выдает хеш-значение длиной 256 бит (т.е. 32 байта), независимо от того, являются ли входные данные одним байтом или несколькими миллионами байт. Эта постоянство гарантирует, что хеш-значения SHA-256 могут использоваться для различных приложений безопасности, 
                    таких как цифровые подписи и коды аутентификации сообщений (MAC), упрощая при этом рабочий процесс обработки и хранения данных.
                </p>
            </div>

            <div>
                <h3>Необратимость хеш-функций</h3>
                <p>
                    Хеш-функции являются однонаправленными, что означает, что невозможно вывести исходные данные из хеш-значения. Эта характеристика особенно важна при хранении паролей, так как даже если база данных скомпрометирована, злоумышленники не смогут восстановить пароли из хеш-значений. Необратимость хеш-функций в основном основана на следующих принципах и характеристиках:
                </p>
                <ul>
                    <li><strong>Сжатие:</strong> Хеш-функции могут отображать входы любой длины (которые могут быть очень большими в практическом использовании) в вывод фиксированной длины. Это означает, что существует бесконечно много возможных входов, отображаемых на конечное количество выводов. Поскольку пространство вывода (хеш-значения) намного меньше пространства ввода, разные входы неизбежно будут производить одинаковый вывод, явление, известное как "коллизия". Из-за этого сжатия невозможно определить конкретный вход из заданного вывода (хеш-значения).</li>
                    <li><strong>Высокая нелинейность и сложность:</strong> Хеш-функции разрабатываются с использованием сложных математических и логических операций (таких как битовые операции, операции по модулю и т. д.), чтобы обеспечить высокую чувствительность вывода к вводу. Даже незначительные изменения во входных данных (например, изменение одного бита) могут вызвать значительные и непредсказуемые изменения в выводе (хеш-значении). Этот высокий уровень нелинейности и случайности вывода делает крайне сложным вывод исходных данных из хеш-значения.</li>
                    <li><strong>Однонаправленность:</strong> Конструкция хеш-функций обеспечивает однонаправленность их работы; то есть, хотя вычисление хеш-значения легко, обратный процесс (восстановление исходных данных из хеш-значения) невозможен. Это потому, что процесс вычисления хеш-значения включает в себя серию необратимых операций (например, необратимость операций по модулю), обеспечивая тем самым невозможность обратной инженерии исходных данных даже с хеш-значением.</li>
                    <li><strong>Случайное отображение:</strong> Идеальная хеш-функция должна действовать как "случайное отображение", что означает, что каждый возможный вход одинаково вероятно будет отображен в любую точку в пространстве вывода. Это свойство обеспечивает отсутствие практического способа предсказать, к какому выводу конкретный ввод будет отображен, что усиливает необратимость хеш-функции.</li>
                    <li><strong>Математическое основание:</strong> Математически необратимость хеш-функций можно понять через их зависимость от "задачи дискретного логарифма", "задач разложения больших целых чисел" или других задач теории чисел, решение которых сложно с текущими математическими и вычислительными возможностями. Например, конструкция некоторых хеш-алгоритмов может косвенно зависеть от вычислительной сложности этих задач, тем самым обеспечивая их необратимость.</li>
                </ul>
                <figure>
                    <img src="./images/Irreversibility.jpg" alt="Необратимость хеш-функций" />
                    <figcaption class="Irreversibility">Необратимость хеш-функций</figcaption>
                </figure>
            </div>
            
            <div>
                <h3>Чувствительность к входу и эффект лавины</h3>
                <p>
                    В проектировании хеш-функций используются сложные математические и логические операции (такие как битовые операции, операции по модулю и т. д.), чтобы обеспечить высокую чувствительность вывода к вводу. Даже незначительные изменения во входных данных (например, изменение одного бита) приведут к значительным и непредсказуемым изменениям в выводе (хеш-значении), явление, известное как "эффект лавины".
                    <a href="javascript:void(0);" class="learnMore" data-target="moreContent2">[Узнать больше]</a>
                </p>
            </div>            
            
            <div id="moreContent2" class="moreContent" style="display:none;">
                <p><a href="https://en.wikipedia.org/wiki/Avalanche_effect" target="_blank" rel="noopener noreferrer" style="color: #007bff; font-size: 1.0em;">Эффект лавины</a>может иметь разные интерпретации в различных областях:</p>
                <ul>
                    <li><strong>В криптографии: </strong> Эффект лавины является желательным свойством алгоритмов шифрования (особенно блочных шифров и криптографических хеш-функций). Он проявляется, когда даже малейшее изменение во входных данных (например, переворачивание бинарного бита) приводит к неотличимым изменениям в выводе (с 50% вероятностью переворота каждого бинарного бита в выводе). Это свойство помогает повысить безопасность шифрования, потому что значительные изменения в выводе могут произойти даже при незначительных изменениях во входных данных, что делает взлом шифрования сложнее путем анализа отношений между входом и выводом.</li>
                    <li><strong>В бизнесе и технологиях: </strong> Эффект лавины означает явление, при котором значительная энергия может быть высвобождена путем соответствующего демонтажа и перекомбинации структуры и системы, присущих бизнесу и технологиям. Эта энергия может уничтожить старые промышленные системы, подобно лавине, или даже вызвать исчезновение всей отрасли. Под огромным давлением лавины присущее соединение между бизнесом и технологиями полностью разрушается, что требует принятия новых трансформаций и интеграций. Этот эффект в конечном итоге запускает серию революционных инноваций.</li>
                    <li><strong>В микросервисной архитектуре: </strong> Эффект лавины описывает сценарий, при котором из-за зависимостей между сервисами отказ или недоступность одного сервиса может распространиться через цепь вызовов, приводя к парализации всей системы. Причинами эффекта лавины могут быть сбои оборудования, всплески трафика, проникновение в кеш, ошибки программы и блокировки JVM, среди прочего.</li>
                    <li><strong>В природе: </strong> Эффект лавины описывает явление, при котором маленький камень, скатывающийся с заснеженной горы, может запустить лавину. Это происходит потому, что удар маленького камня вызывает ослабление и скольжение окружающих слоев снега, что приводит к более масштабной лавине. Это явление также метафорически описывает, как незначительные события или факторы могут запустить масштабные цепные реакции.</li>
                </ul>
            </div>
            
            <div>
                <h3>Стойкость к коллизиям в криптографии</h3>
                <p>
                    Стойкость к коллизиям хеш-функции - это важное понятие в криптографии, указывающее на уровень безопасности хеш-функции от атак на коллизии. Это свойство подразумевает, что для любой хеш-функции <strong>H</strong> нахождение двух различных входов <strong>x</strong> и <strong>y</strong> (<strong>x ≠ y</strong>), таких что <strong>H(x) = H(y)</strong>, вычислительно невозможно. Хеш-функция с надежной стойкостью к коллизиям делает крайне сложным нахождение двух разных входов, приводящих к одному и тому же значению вывода.
                </p>
                <figure>
                    <img src="./images/Collision Resistance.jpg" alt="Иллюстрация устойчивости к коллизиям">
                    <figcaption class="Resistance">Иллюстрация устойчивости к коллизиям</figcaption>
                </figure>
                <p>
                    Стойкость к коллизиям играет важную роль в поддержании целостности и проверки данных. Преобразуя входную информацию в фиксированный размер вывода (или дайджест), хеш-функции гарантируют, что никакие два различных входа не произведут одинакового вывода. Это уникальное свойство позволяет идентифицировать исходное значение хеша с высокой точностью.
                </p>
                <p>
                    Во время создания или хранения данных создается хеш-значение (или дайджест) с использованием хеш-функции. Это значение хранится или передается вместе с исходными данными. Например, сайты загрузки программного обеспечения часто отображают хеш-значения файлов для проверки целостности. Получатели могут независимо пересчитать хеш-значение полученных данных, чтобы подтвердить их целостность. Если исходное и пересчитанное хеш-значения совпадают, целостность данных подтверждается. В противном случае данные могли быть изменены или повреждены во время передачи или хранения.
                </p>
                <p>
                    Сравнение хеш-значений также предлагает преимущество проверки целостности данных без необходимости большого объема хранения. Этот метод позволяет получателям подтвердить подлинность данных, просто сравнивая хеш-значения до и после передачи.
                </p>
                <figure>
                    <img src="./images/Compare Hash.jpg" alt="Процесс сравнения хеш-значений">
                    <figcaption class="Compare">Процесс сравнения хеш-значений</figcaption>
                </figure>
            </div>
            
            <div>
                <h2>Могут ли быть найдены коллизии хешей?</h2>
                <p>
                    Через характеристики вышеупомянутых хеш-функций мы поняли стойкость к коллизиям. Но возможны ли коллизии хешей, то есть, что два разных входа могут дать одинаковый вывод? 
                    Ответ утвердительный, коллизии действительно существуют. Согласно <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B4%D0%B6%D1%83%D0%BD%D0%B3%D0%BB%D0%B5%D0%B9" target="_blank" style="color: #007bff; font-size: 1.0em;">принципу джунглей</a>, при достаточно большом пространстве входных данных возможны коллизии хешей. 
                    Это происходит потому, что пространство вывода хеш-функций обычно намного меньше пространства входных данных, что неизбежно приводит к тому, что несколько разных входов отображаются на один и тот же вывод.
                </p>
                
                <p>
                    Принцип джунглей - это простой и интуитивный принцип комбинаторной математики, который гласит, что если более чем n объектов помещаются в n контейнеров, то как минимум один контейнер будет содержать два или более объекта. 
                    Этот принцип также может быть использован для объяснения проблем, таких как парадокс дней рождения.
                </p>
                <p>
                    Применение принципа джунглей очень широко, с важным применением в таких областях, как криптография, информатика и математика. Например, в информатике принцип джунглей используется для доказательства корректности определенных алгоритмов или для анализа временной сложности алгоритмов. 
                    В криптографии принцип джунглей также используется для разработки определенных методов криптографических атак, таких как атака дня рождения.
                </p>
                <p>
                    Парадокс дней рождения - это классическое применение принципа джунглей. Предположим, в комнате находится n человек. 
                    Если мы хотим, чтобы вероятность того, что как минимум два человека делят один и тот же день рождения, была больше 50%, сколько человек нужно? Согласно принципу джунглей, 
                    если 367 человек (предполагая, что в году 366 дней, плюс дополнительный день за 29 февраля в високосный год) помещаются в 366 "ящиков" (то есть дни рождения), то как минимум один "ящик" будет содержать двух человек, что означает, что как минимум два человека делят один и тот же день рождения. Это иллюстрирует парадокс дней рождения.
                </p>
                <p>
                    Важно отметить, что хотя принцип джунглей прост и интуитивен, его применение должно учитывать конкретный контекст. 
                    Например, при применении принципа джунглей необходимо убедиться, что случайные переменные, вовлеченные в процесс, независимы друг от друга; в противном случае это может привести к неверным выводам. Кроме того, в некоторых случаях также необходимо учитывать такие факторы, как размер и форма ящиков.
                </p>
            </div>
            
            <div>
                <p>
                    Однако попытка найти коллизии хешей путем простого обхода пространства входных данных может оказаться непрактичной, в основном по двум причинам:
                </p>
                <ul>
                    <li><strong>Вычислительная сложность: </strong> Для большинства хеш-функций пространство входных данных огромно. Возьмем SHA-256 в качестве примера; его вывод - это 256-битное хеш-значение, что означает, что у него есть 2^256 возможных выводов. Поскольку одной из целей проектирования хеш-функций является минимизация коллизий насколько это возможно, теоретически, 
                            нахождение коллизии хеша для SHA-256 потребовало бы обхода около 2^(256/2) = 2^128 входов, согласно парадоксу дней рождения, который является приблизительным ожидаемым количеством входов для нахождения коллизии. Даже с использованием самых мощных суперкомпьютеров, доступных в настоящее время, потребовалось бы гораздо больше времени, чем человеческая жизнь, чтобы выполнить такую задачу. 
                            что делает невозможным найти коллизию хеша SHA-256 путем простого обхода.</li>
                    <li><strong>Проектирование хеш-функций: </strong> Хеш-функции обычно проектируются так, чтобы нахождение коллизий было вычислительно невозможно. Это означает, что, хотя коллизии теоретически существуют, практически их невозможно найти на практике. Это важная характеристика криптографических хеш-функций (таких как SHA-256), 
                            которые широко используются в областях цифровых подписей, хранения паролей и многих других.</li>
                </ul>
                <p>
                    Конечно, мы также можем использовать специфические алгоритмы для поиска коллизий хешей. Эти алгоритмы часто используют некоторые известные свойства или уязвимости хеш-функций для поиска коллизий. Вот некоторые общие техники и методы для нахождения коллизий хешей:
                </p>
                <ul>
                    <li><strong>Атака дня рождения: </strong> Это методика, основанная на вероятности, используемая для оценки времени, необходимого для нахождения коллизии при случайном выборе входных данных. Принцип атаки дня рождения заключается в том, что если в комнате много людей, вероятность того, что два человека будут иметь одинаковый день рождения, увеличивается с увеличением числа людей. 
                            Аналогично, в хеш-функциях, если достаточное количество входов выбрано случайным образом, вероятно, что два входа в конечном итоге произведут одинаковый хеш-вывод.</li>
                    <li><strong>Атака методом грубой силы: </strong> Это самый простой метод, который включает обход всех возможных входов для нахождения коллизии. Однако этот метод непрактичен для хеш-функций с большими пространствами входных данных из-за огромных вычислительных ресурсов и времени, необходимых для этого.</li>
                    <li><strong>Радужные таблицы:</strong> Этот метод используется для предварительного вычисления и хранения большого количества хеш-значений и соответствующих им входных данных. Радужные таблицы особенно полезны для взлома паролей, которые не использовали обфускацию случайных данных или имеют известную хеш-функцию. Просматривая радужную таблицу, атакующий может быстро найти входные данные, соответствующие определённому хеш-значению.</li>
                    <li><strong>Атаки на расширение хеша: </strong> Некоторые хеш-функции позволяют злоумышленникам объединять дополнительные данные с известным хеш-значением без знания исходных данных, тем самым генерируя новое хеш-значение. Эта атака может быть использована для конструирования коллизий или выполнения других типов атак.</li>
                    <li><strong>Специально сконструированные входные данные: </strong> Иногда злоумышленники могут использовать конкретные уязвимости или нелинейные характеристики хеш-функций для создания специальных входных данных, которые более вероятно приведут к коллизиям в хеш-функции.</li>
                </ul>
            </div>            

            <div>
                <h2>Какие хеш-функции чаще всего используются?</h2>
                <h3>MD5 (Message Digest Algorithm 5)</h3>
                <p>
                    MD5 - это широко используемая криптографическая хеш-функция, разработанная Рональдом Ривестом в 1990-х годах для замены старого алгоритма MD4. Она может преобразовывать сообщение любой длины в фиксированное хеш-значение (128 бит, или 16 байт). 
                    Цель создания MD5 состояла в том, чтобы обеспечить быстрый и относительно безопасный способ генерации цифрового отпечатка данных. Однако были обнаружены методы коллизий для <a href="https://ru.wikipedia.org/wiki/MD5" target="_blank" style="color: #007bff; font-size: 1.0em;"> MD5 </a>, что делает алгоритм небезопасным, но он все еще широко используется в ситуациях, где безопасность не является первостепенной задачей.
                <br>
                <br>Процесс вычисления MD5 включает следующие шаги:
                </p>
                <ul>
                    <li><strong>Дополнение: </strong> Исходные данные сначала дополняются так, чтобы их байтовая длина была кратна 512. Дополнение начинается с 1, за которым следуют нули до выполнения требования по длине.</li>
                    <li><strong>Добавление длины: </strong> К дополненному сообщению добавляется 64-битное значение длины, которое является двоичным представлением длины исходного сообщения, делая окончательную длину сообщения кратной 512 битам.</li>
                    <li><strong>Инициализация буфера MD: </strong> Четыре 32-битных регистра (A, B, C, D) инициализируются для хранения промежуточных и конечных значений хеша.</li> 
                    <li><strong>Обработка блоков сообщений: </strong> Дополненное и обработанное по длине сообщение делится на блоки по 512 бит, и каждый блок обрабатывается через четыре раунда операций. Каждый раунд включает 16 аналогичных операций на основе нелинейных функций (F, G, H, I), операций циклического сдвига влево и сложения по модулю 32.</li> 
                    <li><strong>Вывод: </strong> Окончательное хеш-значение - это содержимое последнего состояния четырех регистров A, B, C, D, объединенных вместе (каждый регистр имеет 32 бита), образуя 128-битовое хеш-значение.</li> 
                </ul>
                
                <h3>SHA-1 (Secure Hash Algorithm 1)</h3>
                <p>
                    SHA-1 был разработан Национальным управлением по безопасности США (NSA) и выпущен в качестве Федерального стандарта обработки информации (FIPS PUB 180-1) Национальным институтом стандартов и технологий (NIST) в 1995 году. 
                    SHA-1 предназначен для использования в цифровых подписях и других криптографических приложениях, генерируя 160-битовое (20-байтовое) хеш-значение, известное как хеш-дайджест. Хотя теперь известно, что <a href="https://ru.wikipedia.org/wiki/SHA-1" target="_blank" style="color: #007bff; font-size: 1.0em;"> SHA-1 </a> имеет уязвимости в безопасности и был заменен более безопасными алгоритмами, такими как SHA-256 и SHA-3, 
                    понимание его рабочего принципа все еще имеет образовательную и историческую ценность.
                <br>
                <br>Цель создания SHA-1 состоит в том, чтобы взять сообщение произвольной длины и сгенерировать 160-битовый дайджест сообщения для проверки целостности данных. Его процесс вычисления можно разделить на следующие шаги:
                </p>
                <ul>
                    <li><strong>Дополнение: </strong> Исходное сообщение сначала дополняется так, чтобы его длина (в битах) по модулю 512 была равна 448. Дополнение всегда начинается с бита "1", за которым следует несколько битов "0", пока не будет выполнено указанное условие по длине.</li>
                    <li><strong>Добавление длины: </strong> К дополненному сообщению добавляется 64-битный блок, представляющий длину исходного сообщения (в битах), делая окончательную длину сообщения кратной 512 битам.</li>
                    <li><strong>Инициализация буфера: </strong> Алгоритм SHA-1 использует 160-битный буфер, разделенный на пять 32-битных регистров (A, B, C, D, E), для хранения промежуточных и конечных значений хеша. Эти регистры инициализируются определенными постоянными значениями в начале алгоритма.</li>
                    <li><strong>Обработка блоков сообщений: </strong> Предварительно обработанное сообщение делится на блоки по 512 бит. Для каждого блока алгоритм выполняет основной цикл, содержащий 80 аналогичных шагов. Эти 80 шагов разделены на четыре раунда, каждый из которых содержит 20 шагов. Каждый шаг использует различную нелинейную функцию (F, G, H, I) и константу (K). Эти функции разработаны для увеличения сложности и безопасности операций. На этих шагах алгоритм использует побитовые операции (например, И, ИЛИ, ИСКЛЮЧАЮЩЕЕ ИЛИ, НЕ) и сложение по модулю 32, а также циклические сдвиги влево.</li>
                    <li><strong>Вывод: </strong> После обработки всех блоков накопленные значения в пяти регистрах объединяются для формирования окончательного 160-битового хеш-значения.</li>
                </ul>                

                <h3>SHA-2 (Secure Hash Algorithm 2)</h3>
                <p>
                    SHA-2 - это семейство криптографических хеш-функций, включающее несколько различных версий, в основном состоящее из шести вариантов: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 и SHA-512/256. 
                    SHA-2 был разработан Национальным управлением по безопасности США (NSA) и опубликован как Федеральный информационный стандарт (FIPS) Национальным институтом стандартов и технологий (NIST). По сравнению с его предшественником, SHA-1, SHA-2 обеспечивает улучшенную безопасность, в основном отраженную в длинных значениях хеша и более сильной устойчивости к атакам коллизий.
                <br>
                <br>Операция семейства <a href="https://ru.wikipedia.org/wiki/SHA-2" rel="noopener noreferrer" target="_blank" style="color: #007bff; font-size: 1.0em;"> SHA-2 </a> во многом аналогична SHA-1, но обеспечивает более высокую безопасность благодаря использованию длинных значений хеша и более сложной процедуре обработки. Вот основные шаги алгоритма SHA-2:
                </p>
                <ul>
                    <li><strong>Дополнение: </strong> Входное сообщение сначала дополняется, чтобы его длина, за вычетом 64 бит, была равна 448 или 896 по модулю 512 (для SHA-224 и SHA-256) или по модулю 1024 (для SHA-384 и SHA-512). Метод дополнения такой же, как и у SHA-1, и включает добавление "1" в конце сообщения, за которым следует несколько "0", и, наконец, двоичное представление длины исходного сообщения в битах в 64 бита (для SHA-224 и SHA-256) или 128 бит (для SHA-384 и SHA-512).</li>
                    <li><strong>Инициализация буфера: </strong> Алгоритм SHA-2 использует набор инициализированных значений хеша в качестве начального буфера, в зависимости от выбранного варианта SHA-2. Например, SHA-256 использует восемь 32-битных регистров, в то время как SHA-512 использует восемь 64-битных регистров. Эти регистры инициализируются определенными постоянными значениями.</li>
                    <li><strong>Обработка блоков сообщений: </strong> Дополненное сообщение делится на блоки по 512 или 1024 бита, и каждый блок проходит через несколько раундов криптографических операций. SHA-256 и SHA-224 выполняют 64 раунда операций, в то время как SHA-512, SHA-384, SHA-512/224 и SHA-512/256 выполняют 80 раундов. Каждый раунд операции включает серию сложных побитовых операций, включая логические, модульные сложения и условные операции, основанные на различных нелинейных функциях и предопределенных константах. Эти операции увеличивают сложность и безопасность алгоритма.</li>
                    <li><strong>Вывод: </strong> Наконец, после обработки всех блоков, значения в буфере объединяются для формирования окончательного хеш-значения. В зависимости от варианта SHA-2, это хеш-значение может быть длиной 224, 256, 384 или 512 бит.</li>
                </ul>
                <P>
                    Вас, возможно, интересует, почему вход в хеш-функцию может быть произвольной длины, а выход фиксированной. Причина в том, что семейство SHA-2 использует преобразование Меркла — Дамгарда, которое позволяет создавать хеш-функции, способные обрабатывать сообщения произвольной длины из сжатия функции фиксированной длины. Преобразование Меркла — Дамгарда применяется во многих традиционных хеш-функциях, включая MD5 и SHA-1.
                </P>
                <p>
                    Основная идея преобразования Меркла — Дамгарда заключается в разделении входного сообщения на блоки фиксированного размера, а затем обработке этих блоков один за другим, при этом каждый этап обработки зависит от результата предыдущего, что в конечном итоге приводит к формированию хеш-значения фиксированного размера. Шаг дополнения SHA-256 воплощает основные принципы преобразования Меркла — Дамгарда, то есть путем правильного дополнения для обработки сообщений произвольной длины и обеспечения того, что окончательная обработанная длина сообщения соответствует определенным условиям (например, является кратной фиксированной длине). Поэтому можно сказать, что шаг дополнения SHA-256 следует методу преобразования Меркла — Дамгарда.
                </p>
                <p>
                    Однако SHA-256 не просто прямая реализация преобразования Меркла — Дамгарда. Он также включает в себя серию сложных вычислительных шагов (таких как расширение сообщения, многократные раунды сжатия функций и т. д.), которые являются уникальными конструкциями SHA-256, направленными на повышение его безопасности. Поэтому, хотя SHA-256 следует принципам преобразования Меркла — Дамгарда на этапе дополнения, он повышает общую безопасность путем внедрения других механизмов безопасности, что делает его не ограничивающимся только базовой структурой преобразования Меркла — Дамгарда.
                </p>
                <figure>
                    <img src="./images/Merkle-Damgård Padding.jpg" alt="Принцип паддинга Merkle-Damgård">
                    <figcaption class="Merkle-Damgård">Принцип паддинга Merkle-Damgård</figcaption>
                </figure>
                
                <h3>SHA-3 (Secure Hash Algorithm 3) </h3>
                <p>
                    SHA-3 - последний стандарт безопасного хеширования, официально утвержденный Национальным институтом стандартов и технологий (NIST) в 2015 году как Федеральный информационный стандарт (FIPS 202). SHA-3 не предназначен для замены предыдущих SHA-1 или SHA-2 (поскольку SHA-2 по-прежнему считается безопасным), а скорее для дополнения и предложения альтернативного варианта в семействе SHA, предоставляя другой криптографический алгоритм хеширования. SHA-3 основан на алгоритме Keccak, разработанном Гвидо Бертони и другими, и стал победителем соревнования по SHA-3, проведенного NIST в 2012 году.
                <br>
                <br>Принцип работы SHA-3 существенно отличается от SHA-2, в основном потому, что он использует метод, известный как "<strong>конструкция губки</strong>", для поглощения и сжатия данных, производя окончательное хеш-значение. Этот метод позволяет SHA-3 гибко выводить хеш-значения разной длины, что обеспечивает более широкий спектр применений по сравнению с SHA-2. Основные этапы SHA-3 следующие:
                </p>
                <figure>
                    <img src="./images/sponge construction.jpg" alt="Схематическая диаграмма конструкции 'Губка'">
                    <figcaption class="sponge">Схематическая диаграмма конструкции "Губка"</figcaption>
                </figure>
                <h4>Фаза поглощения: </h4>
                <p>
                    На этапе поглощения структура губки сначала делит входные данные на блоки фиксированного размера. Эти блоки данных последовательно "поглощаются" во внутреннее состояние губки, которое обычно больше, чем один блок данных, чтобы обеспечить возможность обработки большого объема данных без переполнения. 
                    Конкретно, каждый блок данных сливается с частью внутреннего состояния каким-то образом (например, операцией XOR), за которой следует применение фиксированной перестановочной функции (в SHA-3 это <a href="https://ru.wikipedia.org/wiki/SHA-3" target="_blank" style="color: #007bff; font-size: 1.0em;">Keccak-f</a>), чтобы преобразовать всё состояние, тем самым предотвращая взаимное влияние между различными блоками входных данных. Этот процесс повторяется, пока все блоки входных данных не будут обработаны.
                </p>
                <p>
                    Keccak-f - это основная перестановочная функция, используемая в криптографическом хеш-алгоритме SHA-3. Она является центральным компонентом семейства алгоритмов Keccak. SHA-3 основан на алгоритме Keccak, который победил в конкурсе криптографических хеш-алгоритмов, проведенном NIST, и был выбран в качестве стандарта для SHA-3. Функция Keccak-f имеет несколько вариантов, 
                    наиболее часто используемым из которых является Keccak-f[1600], где число указывает на разрядность, на которой она работает. 
                </p>
                <p>
                    Keccak-f состоит из множества раундов одинаковых операций (называемых раундами). Для Keccak-f[1600] всего 24 раунда операций. Каждый раунд включает пять базовых шагов: <em>θ (Тета), ρ (Ро), π (Пи), χ (Хи) и ι (Иота)</em>. Эти шаги действуют вместе над массивом состояния, постепенно трансформируя его содержимое, 
                    увеличивая путаницу и диффузию для повышения безопасности. Ниже краткое описание этих шагов:
                </p>
                <ul>
                    <li><strong>Шаг θ (Тета): </strong> Выполняет операции XOR над всеми битами каждого столбца, а затем XOR'ит результат с соседними столбцами, обеспечивая диффузию между столбцами.</li>
                    <li><strong>Шаг ρ (Ро): </strong> Операция побитового сдвига, при которой каждый бит сдвигается на разное количество битов в соответствии с предопределенными правилами, увеличивая сложность данных.</li>
                    <li><strong>Шаг π (Пи): </strong> Переупорядочивает биты в массиве состояния, изменяя положение битов для достижения диффузии по строкам и столбцам.</li>
                    <li><strong>Шаг χ (Хи): </strong> Нелинейный шаг, выполняющий операции XOR над каждым битом каждой строки, включая сам бит, его непосредственного соседа и дополнение соседа. Это локальная операция, которая увеличивает нелинейные характеристики криптографического алгоритма.</li>
                    <li><strong>Шаг ι (Иота): </strong> Вводит в массив состояния константу раунда, отличающуюся в каждом раунде, чтобы избежать одинаковости всех раундов, вводя непредсказуемость.</li>
                </ul>
                <p>
                    Keccak-f обеспечивает высокий уровень безопасности через эти шаги. Его конструкция гарантирует, что даже незначительные изменения во входных данных приводят к широким и непредсказуемым изменениям в массиве состояния, достигаемым через принципы путаницы (сложно для злоумышленников вывести входные данные из вывода) и диффузии (где незначительные изменения во входных данных влияют на несколько частей вывода).
                </p>
                <p>
                    Конструкция Keccak-f позволяет настраивать параметры (такие как размер состояния и количество раундов) в различных уровнях безопасности и сценариях применения, обеспечивая большую гибкость. Keccak-f[1600] известен своей эффективной реализацией, достигая высоких скоростей обработки как в аппаратном, так и в программном обеспечении, особенно при обработке больших объемов данных.
                </p>
                
                <h4>Фаза сжатия: </h4>
                <p>
                    Как только все блоки входных данных были поглощены во внутреннее состояние, структура губки переходит в фазу сжатия. На этом этапе части внутреннего состояния последовательно выводятся в качестве результата хеш-функции. Если требуемая длина вывода превышает количество данных, которое может быть сжато сразу, структура губки применяет функцию перестановки для снова преобразования внутреннего состояния, затем продолжает выводить больше данных. Этот процесс продолжается, пока не будет достигнута желаемая длина вывода.
                </p>
                
                <p>
                    Целью дизайна SHA-3 является обеспечение более высокой безопасности по сравнению с SHA-2 и лучшей устойчивости к атакам квантовых вычислений. Благодаря своей уникальной структуре губки, SHA-3 теоретически способен сопротивляться всем текущим известным криптографическим методам атак, включая атаки коллизий, атаки предобразования и вторые атаки предобразования.
                </p>
                
                <h3>RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest)</h3>
                <p>
                    RIPEMD-160 - криптографическая хеш-функция, разработанная для обеспечения безопасного алгоритма хеширования. Он был разработан в 1996 году Хансом Доббертином и другими и является членом семейства RIPEMD (RACE Integrity Primitives Evaluation Message Digest).
                </p>
                <p>
                    RIPEMD-160 создает хеш-значение длиной 160 бит (20 байт), что является основой "160" в его названии. Он основан на дизайне MD4 и вдохновлен другими алгоритмами хеширования, такими как MD5 и SHA-1. RIPEMD-160 включает две параллельные, 
                    похожие операции, которые обрабатывают входные данные отдельно, а затем объединяют результаты этих двух процессов для генерации конечного хеш-значения. Этот дизайн направлен на увеличение безопасности.
                <br>
                <br>Вычислительный процесс <a href="https://ru.wikipedia.org/wiki/RIPEMD" target="_blank" style="color: #007bff; font-size: 1.0em;">RIPEMD-160 </a> включает несколько основных этапов: дополнение, обработку блоков и сжатие:
                </p>
                <ul>
                    <li><strong>Дополнение: </strong> Входное сообщение сначала дополняется, чтобы его длина по модулю 512 бит равнялась 448 битам. Дополнение всегда начинается с одного бита 1, за которым следует серия битов 0, заканчиваясь 64-битным представлением исходной длины сообщения.</li>
                    <li><strong>Обработка блоков: </strong> Дополненное сообщение разбивается на блоки по 512 бит.</li>
                    <li><strong>Инициализация: </strong> Используются пять 32-битных регистров (A, B, C, D, E), которые инициализируются определенными конкретными значениями.</li>
                    <li><strong>Функция сжатия: </strong> Каждый блок обрабатывается поочередно, обновляя значения этих пяти регистров через серию сложных операций. Этот процесс включает побитовые операции (такие как сложение, AND, OR, NOT, кольцевые левые сдвиги) и использование набора фиксированных констант.</li>
                    <li><strong>Вывод: </strong> После обработки всех блоков значения этих пяти регистров объединяются для формирования конечного хеш-значения длиной 160 бит.</li>
                </ul>                
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="social-links">
            <a href="https://twitter.com/xinli_111219" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-twitter"></i>
            </a>
            <a href="https://www.youtube.com/@xinli-vj3js" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-youtube"></i>
            </a> 
        </div>
    
        <div class="info">
            <p>© 2024 chatcipher Tools. Все права защищены.</p>
            <p>
                <a href="https://chatcipherai.com/ru/Privacy_Policy.html" title="Privacy Policy">Политика конфиденциальности</a>
                |
                <a href="https://chatcipherai.com/ru/Terms_of_Use.html" title="Terms of Use">Условия использования</a>
                |
                <a href="https://chatcipherai.com/ru/About_Us.html" title="About Us">О нас</a>
                |
                <a href="https://chatcipherai.com/ru/Disclaimer.html" title="Disclaimer">Отказ от ответственности</a>
            </p> 
            <button id="backToTop" onclick="scrollToTop()">Вернуться наверх</button>
        </div>  
    </footer>

    <script>
        let shortcutsEnabled = true;

        function manageShortcuts(enable) {
            shortcutsEnabled = enable;
        }

        function handleKeyPress(event) {
            if (!shortcutsEnabled) {
                console.log('Shortcuts are disabled');
                return;
            }

            switch (event.key.toUpperCase()) {
                case 'A':
                    clearAll();
                    console.log('Clear All triggered');
                    break;
                case 'L':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('light-mode');
                        console.log('Light style activated');
                    }
                    break;
                case 'N':
                    if (document.activeElement.type !== 'text' && document.activeElement.type !== 'textarea') {
                        setStyle('dark-mode');
                        console.log('Dark style activated');
                    }
                    break;
                case 'B':
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                    console.log('Scrolled to top');
                    break;
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Ensure all handlers are set up once the DOM is fully loaded
            document.addEventListener('keydown', handleKeyPress);

            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
            
            setupEventListeners(); // Setup other event listeners
            adjustButton();
        });

        let generatedTextHash = '';
        let generatedFileHash = '';

        async function generateHash() {
            const text = document.getElementById('textInput').value;
            document.getElementById('processOutput').textContent = text.length ? "Вычисление хеш-значения..." : '';
            const msgUint8 = new TextEncoder().encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('hashOutput').textContent = `Хэш-значение (SHA-256): ${hashHex}`;
            generatedTextHash = hashHex;
            document.getElementById('processOutput').textContent = "";
        }

        async function generateFileHash() {
            const fileInput = document.getElementById('fileInput');
            if (!fileInput.files.length) {
                alert("Пожалуйста, выберите файл.");
                return;
            }
            document.getElementById('fileHashOutput').textContent = "Вычисление хеш-значения файла...";
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('fileHashOutput').textContent = `Хэш-значение (SHA-256): ${hashHex}`;
                generatedFileHash = hashHex;
            };
            reader.onerror = function () {
                alert("Ошибка чтения файла.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareTextHash() {
            const compareHash = document.getElementById('hashCompareInput').value;
            if (!generatedTextHash) {
                alert('Пожалуйста, сначала сгенерируйте хэш текста.');
                return;
            }
            const resultText = generatedTextHash === compareHash ? "<strong>Заключение:</strong>Хэши совпадают, и данные не были подделаны." : "<strong>Заключение:</strong>Хэши не совпадают, возможно, данные были подделаны при передаче или во время хранения произошла ошибка.";
            document.getElementById('textCompareResult').innerHTML = resultText;
            document.getElementById('textCompareResult').style.color = generatedTextHash === compareHash ? "black" : "red";
        }

        async function compareFileHash() {
            const fileInput = document.getElementById('compareFileInput');
            if (!fileInput.files.length) {
                alert("Пожалуйста, выберите файл для сравнения.");
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = async function (event) {
                const arrayBuffer = event.target.result;
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                document.getElementById('fileCompareResult').textContent = `Хэш-значение (SHA-256): ${hashHex}`;

                if (generatedFileHash === hashHex) {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Заключение:</strong>Хэши совпадают, и данные не были подделаны.";
                    document.getElementById('fileCompareResult').style.color = "black";
                } else {
                    document.getElementById('fileCompareResult').innerHTML += "<br><strong>Заключение:</strong>Хэши не совпадают, возможно, данные были подделаны при передаче или во время хранения произошла ошибка.";
                    document.getElementById('fileCompareResult').style.color = "red";
                }
            };
            reader.onerror = function () {
                alert("Ошибка чтения файла.");
            };
            reader.readAsArrayBuffer(file);
        }

        function compareHashValues() {
            var hashValue1 = document.getElementById('hashInput1').value.trim();
            var hashValue2 = document.getElementById('hashInput2').value.trim();

            var resultDisplay = document.getElementById('hashComparisonResult');

            resultDisplay.style.fontWeight = 'bold';

            if (hashValue1 === "" || hashValue2 === "") {
                resultDisplay.textContent = 'Необходимо ввести оба хеш-значения.';
                resultDisplay.style.color = 'black';
            } else if (hashValue1 === hashValue2) {
                resultDisplay.textContent = 'Хеш-значения совпадают!';
                resultDisplay.style.color = 'black';
            } else {
                resultDisplay.textContent = 'Хеш-значения не совпадают.';
                resultDisplay.style.color = 'red';
            }
        }

        function copyTextHash() {
            const hashValue = document.getElementById('hashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("Не удалось скопировать текстовый хэш.");
                });
            }
        }

        function copyFileHash() {
            const hashValue = document.getElementById('fileHashOutput').textContent;
            const hash = hashValue.split(": ")[1];
            if (hash) {
                navigator.clipboard.writeText(hash).then(() => {
                }, () => {
                    console.error("Не удалось скопировать хэш файла.");
                });
            }
        }

        function clearAll() {
            document.getElementById('textInput').value = '';
            document.getElementById('hashOutput').textContent = '';
            document.getElementById('hashCompareInput').value = '';
            document.getElementById('textCompareResult').textContent = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('fileHashOutput').textContent = '';
            document.getElementById('compareFileInput').value = '';
            document.getElementById('fileCompareResult').textContent = '';
            document.getElementById('hashInput1').value = '';
            document.getElementById('hashInput2').value = '';
            document.getElementById('hashComparisonResult').textContent = '';
        }

        document.getElementById('menuIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .menuUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });
        document.getElementById('languageIcon').addEventListener('click', function () {
            var navbarUl = document.querySelector('.navbar .langUl');
            if (navbarUl.style.display === 'flex') {
                navbarUl.style.display = 'none';
            } else {
                navbarUl.style.display = 'flex';
            }
        });

        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var menunavbarUl = document.querySelector('.navbar .menuUl');

            var languageIcon = document.getElementById('languageIcon');
            var langnavbarUl = document.querySelector('.navbar .langUl');

            if (!menuIcon.contains(event.target) && !menunavbarUl.contains(event.target)) {
                menunavbarUl.style.display = 'none';
            }
            if (!languageIcon.contains(event.target) && !langnavbarUl.contains(event.target)) {
                langnavbarUl.style.display = 'none';
            }
        });
        document.addEventListener('click', function (event) {
            var menuIcon = document.getElementById('menuIcon');
            var navbarUl = document.querySelector('.navbar ul');

            if (!menuIcon.contains(event.target) && !navbarUl.contains(event.target)) {
                navbarUl.style.display = 'none';
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            var savedStyle = localStorage.getItem('style') || 'dark-mode';
            setStyle(savedStyle);
        });

        document.getElementById('lightStyle').addEventListener('click', function () {
            setStyle('light-mode');
        });

        document.getElementById('darkStyle').addEventListener('click', function () {
            setStyle('dark-mode');
        });

        function setStyle(style) {
            document.body.className = style;
            localStorage.setItem('style', style);
            updateButtonStyles();
            updateNavbarStyles(style);
        }

        function updateNavbarStyles(style) {
            var navbar = document.querySelector('.navbar');
            var ul = navbar.querySelector('ul');
            navbar.style.backgroundColor = style === 'dark-mode' ? '#0A0F24' : '#FFFFFF';
            ul.style.backgroundColor = style === 'dark-mode' ? 'rgba(119, 136, 153, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            ul.style.color = style === 'dark-mode' ? '#FFFFFF' : '#0A0F24';
        }

        document.querySelectorAll('.learnMore').forEach(function (link) {
            link.addEventListener('click', function () {
                var targetId = this.getAttribute('data-target');
                var moreContent = document.getElementById(targetId);
                if (moreContent.style.display === "none" || moreContent.style.display === "") {
                    moreContent.style.display = "block";
                    this.textContent = "[закрытие]";
                } else {
                    moreContent.style.display = "none";
                    this.textContent = "[Узнать больше]";
                }
            });
        });

        window.onscroll = function () { scrollFunction(); };
        function scrollFunction() {
            if (document.body.scrollTop > 10 || document.documentElement.scrollTop > 20) {
                document.getElementById("backToTop").style.display = "block";
            } else {
                document.getElementById("backToTop").style.display = "none";
            }
        }
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        document.addEventListener('DOMContentLoaded', function () {
            var navbar = document.querySelector('.navbar');
            window.onscroll = function () {
                if (window.scrollY > 50) {
                    navbar.classList.add('solid');
                } else {
                    navbar.classList.remove('solid');
                }
            };
        });

        function adjustButton() {
            var button = document.getElementById('backToTop');
            if (window.innerWidth < 768) {
                button.innerHTML = '▲';
            } else {
                button.innerHTML = 'Вернуться наверх(<span class="highlight-key">B</span>)';
            }
        }

        window.onload = adjustButton;
        window.onresize = adjustButton;

    </script>
    <div style="display: none;">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-LZTEEH0M4K"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
    
            gtag('config', 'G-LZTEEH0M4K');
        </script>
    </div>
</body>
</html>